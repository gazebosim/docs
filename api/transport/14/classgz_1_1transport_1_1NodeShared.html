<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Transport">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Transport: NodeShared Class Reference</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Transport</h1>
        <h2>API Reference</h2>
        <div class="version">
        14.0.0
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.8 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegz.html">gz</a></li><li class="navelem"><a class="el" href="namespacegz_1_1transport.html">transport</a></li><li class="navelem"><a class="el" href="classgz_1_1transport_1_1NodeShared.html">NodeShared</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classgz_1_1transport_1_1NodeShared-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle"><div class="title">NodeShared Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Private data for the <a class="el" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">Node</a> class. This class should not be directly used. You should use the <a class="el" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">Node</a> class.  
 <a href="classgz_1_1transport_1_1NodeShared.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="NodeShared_8hh_source.html">gz/transport/NodeShared.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgz_1_1transport_1_1NodeShared_1_1HandlerInfo.html">HandlerInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structgz_1_1transport_1_1NodeShared_1_1HandlerInfo.html" title="HandlerInfo contains information about callback handlers which is useful for local publishers and mes...">HandlerInfo</a> contains information about callback handlers which is useful for local publishers and message receivers. You should only retrieve a <a class="el" href="structgz_1_1transport_1_1NodeShared_1_1HandlerInfo.html" title="HandlerInfo contains information about callback handlers which is useful for local publishers and mes...">HandlerInfo</a> by calling <a class="el" href="classgz_1_1transport_1_1NodeShared.html#abc62094ae368bdc1f00ad6ffebcb6bfb" title="Get information about the local and raw subscribers that are attached to this NodeShared.">CheckHandlerInfo(const std::string &amp;_topic) const</a>.  <a href="structgz_1_1transport_1_1NodeShared_1_1HandlerInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgz_1_1transport_1_1NodeShared_1_1HandlerWrapper.html">HandlerWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct wraps up the two different types of subscription handlers: normal (deserialized) and raw (serialized). This wrapper keeps the two sets of subscription handlers coordinated while allowing them to act independently when necessary.  <a href="structgz_1_1transport_1_1NodeShared_1_1HandlerWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgz_1_1transport_1_1NodeShared_1_1SubscriberInfo.html">SubscriberInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct provides information about the Subscribers of a <a class="el" href="classgz_1_1transport_1_1Publisher.html" title="This class stores all the information about a publisher. It stores the topic name that publishes,...">Publisher</a>. It should only be retrieved using <a class="el" href="classgz_1_1transport_1_1NodeShared.html#a47f61f3e393840fdd5ec544e6c30ffa7" title="Get information about the nodes that are subscribed to the publishers of this NodeShared.">CheckSubscriberInfo(const std::string&amp;, const std::string&amp;) const</a>. The relevant subscriber info is a superset of the relevant <a class="el" href="structgz_1_1transport_1_1NodeShared_1_1HandlerInfo.html" title="HandlerInfo contains information about callback handlers which is useful for local publishers and mes...">HandlerInfo</a> so we extend that struct.  <a href="structgz_1_1transport_1_1NodeShared_1_1SubscriberInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a141ffbcd254478db4c5ac918c47fc594" id="r_a141ffbcd254478db4c5ac918c47fc594"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a141ffbcd254478db4c5ac918c47fc594">AddGlobalRelay</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_relayAddress)</td></tr>
<tr class="memdesc:a141ffbcd254478db4c5ac918c47fc594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a unicast relay IP. All nodes in this process will send UDP unicast traffic to the address to connect networks when UDP multicast traffic is not forwarded. It's also possible to use the environment variable GZ_RELAY to add relays.  <br /></td></tr>
<tr class="separator:a141ffbcd254478db4c5ac918c47fc594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd50666146d77bf55df8f30637b0b30" id="r_aabd50666146d77bf55df8f30637b0b30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#aabd50666146d77bf55df8f30637b0b30">AdvertisePublisher</a> (const <a class="el" href="classgz_1_1transport_1_1ServicePublisher.html">ServicePublisher</a> &amp;_publisher)</td></tr>
<tr class="memdesc:aabd50666146d77bf55df8f30637b0b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass through to bool Advertise(const Pub &amp;_publisher)  <br /></td></tr>
<tr class="separator:aabd50666146d77bf55df8f30637b0b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc62094ae368bdc1f00ad6ffebcb6bfb" id="r_abc62094ae368bdc1f00ad6ffebcb6bfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgz_1_1transport_1_1NodeShared_1_1HandlerInfo.html">HandlerInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#abc62094ae368bdc1f00ad6ffebcb6bfb">CheckHandlerInfo</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_topic) const</td></tr>
<tr class="memdesc:abc62094ae368bdc1f00ad6ffebcb6bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about the local and raw subscribers that are attached to this <a class="el" href="classgz_1_1transport_1_1NodeShared.html" title="Private data for the Node class. This class should not be directly used. You should use the Node clas...">NodeShared</a>.  <br /></td></tr>
<tr class="separator:abc62094ae368bdc1f00ad6ffebcb6bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f61f3e393840fdd5ec544e6c30ffa7" id="r_a47f61f3e393840fdd5ec544e6c30ffa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgz_1_1transport_1_1NodeShared_1_1SubscriberInfo.html">SubscriberInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a47f61f3e393840fdd5ec544e6c30ffa7">CheckSubscriberInfo</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_topic, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_msgType) const</td></tr>
<tr class="memdesc:a47f61f3e393840fdd5ec544e6c30ffa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about the nodes that are subscribed to the publishers of this <a class="el" href="classgz_1_1transport_1_1NodeShared.html" title="Private data for the Node class. This class should not be directly used. You should use the Node clas...">NodeShared</a>.  <br /></td></tr>
<tr class="separator:a47f61f3e393840fdd5ec544e6c30ffa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7886b6094dcc493c7acaeec141928d3f" id="r_a7886b6094dcc493c7acaeec141928d3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a7886b6094dcc493c7acaeec141928d3f">DiscoverService</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_topic) const</td></tr>
<tr class="memdesc:a7886b6094dcc493c7acaeec141928d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass through to bool <a class="el" href="classgz_1_1transport_1_1Discovery.html#acc6843ffdac56b0cfa7a37f978af2b7e" title="Request discovery information about a topic. When using this method, the user might want to use SetCo...">Discovery::Discover(const std::string
&amp;_topic) const</a>.  <br /></td></tr>
<tr class="separator:a7886b6094dcc493c7acaeec141928d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f532d16ea0fad4a6e8c3ad25a2d77d" id="r_a17f532d16ea0fad4a6e8c3ad25a2d77d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a17f532d16ea0fad4a6e8c3ad25a2d77d">EnableStats</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_topic, bool _enable, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; void(const <a class="el" href="classgz_1_1transport_1_1TopicStatistics.html">TopicStatistics</a> &amp;_stats)&gt; _cb)</td></tr>
<tr class="memdesc:a17f532d16ea0fad4a6e8c3ad25a2d77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn topic statistics on or off.  <br /></td></tr>
<tr class="separator:a17f532d16ea0fad4a6e8c3ad25a2d77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0374fe589ed1dcadb571065a05b80b" id="r_ada0374fe589ed1dcadb571065a05b80b"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#ada0374fe589ed1dcadb571065a05b80b">GlobalRelays</a> () const</td></tr>
<tr class="memdesc:ada0374fe589ed1dcadb571065a05b80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the relay addresses configured for all nodes in this process.  <br /></td></tr>
<tr class="separator:ada0374fe589ed1dcadb571065a05b80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d90c6ed95f28c3cf951ed13b3eaddf" id="r_a49d90c6ed95f28c3cf951ed13b3eaddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a49d90c6ed95f28c3cf951ed13b3eaddf">OnEndRegistration</a> (const <a class="el" href="classgz_1_1transport_1_1MessagePublisher.html">MessagePublisher</a> &amp;_pub)</td></tr>
<tr class="memdesc:a49d90c6ed95f28c3cf951ed13b3eaddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback executed when a remote subscriber unregisters.  <br /></td></tr>
<tr class="separator:a49d90c6ed95f28c3cf951ed13b3eaddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd056093895b8583bdc2e4efb0f42f2" id="r_abdd056093895b8583bdc2e4efb0f42f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#abdd056093895b8583bdc2e4efb0f42f2">OnNewConnection</a> (const <a class="el" href="classgz_1_1transport_1_1MessagePublisher.html">MessagePublisher</a> &amp;_pub)</td></tr>
<tr class="memdesc:abdd056093895b8583bdc2e4efb0f42f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback executed when the discovery detects new topics.  <br /></td></tr>
<tr class="separator:abdd056093895b8583bdc2e4efb0f42f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148a4a10f05f661434c172408cbf28e7" id="r_a148a4a10f05f661434c172408cbf28e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a148a4a10f05f661434c172408cbf28e7">OnNewDisconnection</a> (const <a class="el" href="classgz_1_1transport_1_1MessagePublisher.html">MessagePublisher</a> &amp;_pub)</td></tr>
<tr class="memdesc:a148a4a10f05f661434c172408cbf28e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback executed when the discovery detects disconnections.  <br /></td></tr>
<tr class="separator:a148a4a10f05f661434c172408cbf28e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c88b79ac8be6af84c8879d4128b6102" id="r_a7c88b79ac8be6af84c8879d4128b6102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a7c88b79ac8be6af84c8879d4128b6102">OnNewRegistration</a> (const <a class="el" href="classgz_1_1transport_1_1MessagePublisher.html">MessagePublisher</a> &amp;_pub)</td></tr>
<tr class="memdesc:a7c88b79ac8be6af84c8879d4128b6102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback executed when a remote subscriber connects.  <br /></td></tr>
<tr class="separator:a7c88b79ac8be6af84c8879d4128b6102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8864215e8ccd2594a86607dc01600ce2" id="r_a8864215e8ccd2594a86607dc01600ce2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a8864215e8ccd2594a86607dc01600ce2">OnNewSrvConnection</a> (const <a class="el" href="classgz_1_1transport_1_1ServicePublisher.html">ServicePublisher</a> &amp;_pub)</td></tr>
<tr class="memdesc:a8864215e8ccd2594a86607dc01600ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback executed when the discovery detects a new service call.  <br /></td></tr>
<tr class="separator:a8864215e8ccd2594a86607dc01600ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1865c3f0e3d062fadc06abf3f55110ae" id="r_a1865c3f0e3d062fadc06abf3f55110ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a1865c3f0e3d062fadc06abf3f55110ae">OnNewSrvDisconnection</a> (const <a class="el" href="classgz_1_1transport_1_1ServicePublisher.html">ServicePublisher</a> &amp;_pub)</td></tr>
<tr class="memdesc:a1865c3f0e3d062fadc06abf3f55110ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback executed when a service call is no longer available.  <br /></td></tr>
<tr class="separator:a1865c3f0e3d062fadc06abf3f55110ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3880d2ef7da1102ce4112ed8913fb090" id="r_a3880d2ef7da1102ce4112ed8913fb090"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a3880d2ef7da1102ce4112ed8913fb090">OnSubscribers</a> ()</td></tr>
<tr class="memdesc:a3880d2ef7da1102ce4112ed8913fb090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback executed when a SUBSCRIBERS request is received.  <br /></td></tr>
<tr class="separator:a3880d2ef7da1102ce4112ed8913fb090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dc25a2a8c3da4e71b152a196294863" id="r_ab9dc25a2a8c3da4e71b152a196294863"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#ab9dc25a2a8c3da4e71b152a196294863">Publish</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_topic, char *_data, const size_t _dataSize, <a class="el" href="namespacegz_1_1transport.html#acf902668d74f410b5f800c62ea870e09">DeallocFunc</a> *_ffn, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_msgType)</td></tr>
<tr class="memdesc:ab9dc25a2a8c3da4e71b152a196294863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish data.  <br /></td></tr>
<tr class="separator:ab9dc25a2a8c3da4e71b152a196294863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810185d18710c7e2cac2175f6b5cf853" id="r_a810185d18710c7e2cac2175f6b5cf853"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a810185d18710c7e2cac2175f6b5cf853">RcvHwm</a> ()</td></tr>
<tr class="memdesc:a810185d18710c7e2cac2175f6b5cf853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the capacity of the buffer (High Water Mark) that stores incoming Gazebo Transport messages. Note that this is a global queue shared by all subscribers within the same process.  <br /></td></tr>
<tr class="separator:a810185d18710c7e2cac2175f6b5cf853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e2299170973c77293e8bb51b7f8b99" id="r_a31e2299170973c77293e8bb51b7f8b99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a31e2299170973c77293e8bb51b7f8b99">RecvMsgUpdate</a> ()</td></tr>
<tr class="memdesc:a31e2299170973c77293e8bb51b7f8b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method in charge of receiving the topic updates.  <br /></td></tr>
<tr class="separator:a31e2299170973c77293e8bb51b7f8b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7537cec2074b39b9454f8fbabb20e4" id="r_a4c7537cec2074b39b9454f8fbabb20e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a4c7537cec2074b39b9454f8fbabb20e4">RecvSrvRequest</a> ()</td></tr>
<tr class="memdesc:a4c7537cec2074b39b9454f8fbabb20e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method in charge of receiving the service call requests.  <br /></td></tr>
<tr class="separator:a4c7537cec2074b39b9454f8fbabb20e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45fcf30e979af958e3b01cfe4ecfa0c" id="r_ac45fcf30e979af958e3b01cfe4ecfa0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#ac45fcf30e979af958e3b01cfe4ecfa0c">RecvSrvResponse</a> ()</td></tr>
<tr class="memdesc:ac45fcf30e979af958e3b01cfe4ecfa0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method in charge of receiving the service call responses.  <br /></td></tr>
<tr class="separator:ac45fcf30e979af958e3b01cfe4ecfa0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79ddfa50c6c3bdae02efa0e7fda3c21" id="r_ad79ddfa50c6c3bdae02efa0e7fda3c21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#ad79ddfa50c6c3bdae02efa0e7fda3c21">RunReceptionTask</a> ()</td></tr>
<tr class="memdesc:ad79ddfa50c6c3bdae02efa0e7fda3c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data and control messages.  <br /></td></tr>
<tr class="separator:ad79ddfa50c6c3bdae02efa0e7fda3c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9508a12488f9f0c996c727162e7c9e7" id="r_aa9508a12488f9f0c996c727162e7c9e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#aa9508a12488f9f0c996c727162e7c9e7">SendPendingRemoteReqs</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_topic, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_reqType, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_repType)</td></tr>
<tr class="memdesc:aa9508a12488f9f0c996c727162e7c9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to send all the requests for a given service call and a pair of request/response types.  <br /></td></tr>
<tr class="separator:aa9508a12488f9f0c996c727162e7c9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321d5304fe91d7d1804db54e071a4923" id="r_a321d5304fe91d7d1804db54e071a4923"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a321d5304fe91d7d1804db54e071a4923">SndHwm</a> ()</td></tr>
<tr class="memdesc:a321d5304fe91d7d1804db54e071a4923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the capacity of the buffer (High Water Mark) that stores outgoing Gazebo Transport messages. Note that this is a global queue shared by all publishers within the same process.  <br /></td></tr>
<tr class="separator:a321d5304fe91d7d1804db54e071a4923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762717be8feb1d059c1263b0e957fa07" id="r_a762717be8feb1d059c1263b0e957fa07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a762717be8feb1d059c1263b0e957fa07">TopicPublishers</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_topic, <a class="el" href="namespacegz_1_1transport.html#ad2b1999c7bd16fa02d6399404ddf2ba0">SrvAddresses_M</a> &amp;_publishers) const</td></tr>
<tr class="memdesc:a762717be8feb1d059c1263b0e957fa07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass through to bool Publishers(const std::string &amp;_topic,
Addresses_M&lt;Pub&gt; &amp;_publishers) const.  <br /></td></tr>
<tr class="separator:a762717be8feb1d059c1263b0e957fa07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bea29832d73ef9912d01a98ea42a19" id="r_ab6bea29832d73ef9912d01a98ea42a19"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classgz_1_1transport_1_1TopicStatistics.html">TopicStatistics</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#ab6bea29832d73ef9912d01a98ea42a19">TopicStats</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_topic) const</td></tr>
<tr class="memdesc:ab6bea29832d73ef9912d01a98ea42a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current statistics for a topic. <a class="el" href="classgz_1_1transport_1_1Statistics.html" title="Computes the rolling average, min, max, and standard deviation for a set of samples.">Statistics</a> must have been enabled using the EnableStatistics function, otherwise the return value will be std::nullopt.  <br /></td></tr>
<tr class="separator:ab6bea29832d73ef9912d01a98ea42a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39525c8620fbc8b83b350328db85f83b" id="r_a39525c8620fbc8b83b350328db85f83b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a39525c8620fbc8b83b350328db85f83b">TriggerCallbacks</a> (const <a class="el" href="classgz_1_1transport_1_1MessageInfo.html">MessageInfo</a> &amp;_info, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_msgData, const <a class="el" href="structgz_1_1transport_1_1NodeShared_1_1HandlerInfo.html">HandlerInfo</a> &amp;_handlerInfo)</td></tr>
<tr class="memdesc:a39525c8620fbc8b83b350328db85f83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the <a class="el" href="classgz_1_1transport_1_1SubscriptionHandler.html" title="It creates a subscription handler for a specific protobuf message. &#39;T&#39; is the Protobuf message type t...">SubscriptionHandler</a> callbacks (local and raw) for this <a class="el" href="classgz_1_1transport_1_1NodeShared.html" title="Private data for the Node class. This class should not be directly used. You should use the Node clas...">NodeShared</a>.  <br /></td></tr>
<tr class="separator:a39525c8620fbc8b83b350328db85f83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a465c3f60c4bf0c163213b00a1bf72a3d" id="r_a465c3f60c4bf0c163213b00a1bf72a3d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classgz_1_1transport_1_1NodeShared.html">NodeShared</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a465c3f60c4bf0c163213b00a1bf72a3d">Instance</a> ()</td></tr>
<tr class="memdesc:a465c3f60c4bf0c163213b00a1bf72a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgz_1_1transport_1_1NodeShared.html" title="Private data for the Node class. This class should not be directly used. You should use the Node clas...">NodeShared</a> is a singleton. This method gets the <a class="el" href="classgz_1_1transport_1_1NodeShared.html" title="Private data for the Node class. This class should not be directly used. You should use the Node clas...">NodeShared</a> instance shared between all the nodes.  <br /></td></tr>
<tr class="separator:a465c3f60c4bf0c163213b00a1bf72a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af3ef730335fe33502be1f5c2daac5912" id="r_af3ef730335fe33502be1f5c2daac5912"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#af3ef730335fe33502be1f5c2daac5912">discoveryIP</a> = &quot;239.255.0.7&quot;</td></tr>
<tr class="memdesc:af3ef730335fe33502be1f5c2daac5912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default IP address used by the message discovery layer.  <br /></td></tr>
<tr class="separator:af3ef730335fe33502be1f5c2daac5912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a30b238a88023669211195c7126099a" id="r_a3a30b238a88023669211195c7126099a"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a3a30b238a88023669211195c7126099a">hostAddr</a></td></tr>
<tr class="memdesc:a3a30b238a88023669211195c7126099a"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP address of this host.  <br /></td></tr>
<tr class="separator:a3a30b238a88023669211195c7126099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f1e3d9c5cf0278394ec9b7dc466bd5" id="r_a07f1e3d9c5cf0278394ec9b7dc466bd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgz_1_1transport_1_1NodeShared_1_1HandlerWrapper.html">HandlerWrapper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a07f1e3d9c5cf0278394ec9b7dc466bd5">localSubscribers</a></td></tr>
<tr class="separator:a07f1e3d9c5cf0278394ec9b7dc466bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7534df3dab1c28ef54c1e2774f31d224" id="r_a7534df3dab1c28ef54c1e2774f31d224"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a7534df3dab1c28ef54c1e2774f31d224">msgDiscPort</a> = <a class="el" href="classgz_1_1transport_1_1NodeShared.html#a5ab7be97cfecac0aeea0cde4a9bdf97a">kDefaultMsgDiscPort</a></td></tr>
<tr class="memdesc:a7534df3dab1c28ef54c1e2774f31d224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Port used by the message discovery layer.  <br /></td></tr>
<tr class="separator:a7534df3dab1c28ef54c1e2774f31d224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754f5256fe35616a2d47ebeb5cd5c4ca" id="r_a754f5256fe35616a2d47ebeb5cd5c4ca"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/recursive_mutex.html">std::recursive_mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a754f5256fe35616a2d47ebeb5cd5c4ca">mutex</a></td></tr>
<tr class="memdesc:a754f5256fe35616a2d47ebeb5cd5c4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to guarantee exclusive access between all threads.  <br /></td></tr>
<tr class="separator:a754f5256fe35616a2d47ebeb5cd5c4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52533157bd2ff40e6692f341571aa2e6" id="r_a52533157bd2ff40e6692f341571aa2e6"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a52533157bd2ff40e6692f341571aa2e6">myAddress</a></td></tr>
<tr class="memdesc:a52533157bd2ff40e6692f341571aa2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">My pub/sub address.  <br /></td></tr>
<tr class="separator:a52533157bd2ff40e6692f341571aa2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0499ccd74c7501953161f6d27bfd2162" id="r_a0499ccd74c7501953161f6d27bfd2162"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a0499ccd74c7501953161f6d27bfd2162">myControlAddress</a></td></tr>
<tr class="memdesc:a0499ccd74c7501953161f6d27bfd2162"><td class="mdescLeft">&#160;</td><td class="mdescRight">My pub/sub control address.  <br /></td></tr>
<tr class="separator:a0499ccd74c7501953161f6d27bfd2162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51313319f500ead9e0e68be7698bbc2" id="r_ab51313319f500ead9e0e68be7698bbc2"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#ab51313319f500ead9e0e68be7698bbc2">myReplierAddress</a></td></tr>
<tr class="memdesc:ab51313319f500ead9e0e68be7698bbc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">My replier service call address.  <br /></td></tr>
<tr class="separator:ab51313319f500ead9e0e68be7698bbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc968562d68138fb00afe2ac0f8ee5f" id="r_a4fc968562d68138fb00afe2ac0f8ee5f"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a4fc968562d68138fb00afe2ac0f8ee5f">myRequesterAddress</a></td></tr>
<tr class="memdesc:a4fc968562d68138fb00afe2ac0f8ee5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">My requester service call address.  <br /></td></tr>
<tr class="separator:a4fc968562d68138fb00afe2ac0f8ee5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d760341ce5271134c4367fb0d1bcc28" id="r_a4d760341ce5271134c4367fb0d1bcc28"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a4d760341ce5271134c4367fb0d1bcc28">pUuid</a></td></tr>
<tr class="memdesc:a4d760341ce5271134c4367fb0d1bcc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process UUID.  <br /></td></tr>
<tr class="separator:a4d760341ce5271134c4367fb0d1bcc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acb16a02feeb34fa010076509459e31" id="r_a5acb16a02feeb34fa010076509459e31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgz_1_1transport_1_1TopicStorage.html">TopicStorage</a>&lt; <a class="el" href="classgz_1_1transport_1_1MessagePublisher.html">MessagePublisher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a5acb16a02feeb34fa010076509459e31">remoteSubscribers</a></td></tr>
<tr class="memdesc:a5acb16a02feeb34fa010076509459e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remote subscribers.  <br /></td></tr>
<tr class="separator:a5acb16a02feeb34fa010076509459e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80a02ebb4a3861918ae843f69fdd2ba" id="r_af80a02ebb4a3861918ae843f69fdd2ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgz_1_1transport_1_1Uuid.html">Uuid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#af80a02ebb4a3861918ae843f69fdd2ba">replierId</a></td></tr>
<tr class="memdesc:af80a02ebb4a3861918ae843f69fdd2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replier socket identity.  <br /></td></tr>
<tr class="separator:af80a02ebb4a3861918ae843f69fdd2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a673f452357508830a9f9591860557" id="r_aa8a673f452357508830a9f9591860557"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgz_1_1transport_1_1HandlerStorage.html">HandlerStorage</a>&lt; <a class="el" href="classgz_1_1transport_1_1IRepHandler.html">IRepHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#aa8a673f452357508830a9f9591860557">repliers</a></td></tr>
<tr class="memdesc:aa8a673f452357508830a9f9591860557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service call repliers.  <br /></td></tr>
<tr class="separator:aa8a673f452357508830a9f9591860557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab304a56cac09e0cc79ea1ec649e1ecdf" id="r_ab304a56cac09e0cc79ea1ec649e1ecdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgz_1_1transport_1_1HandlerStorage.html">HandlerStorage</a>&lt; <a class="el" href="classgz_1_1transport_1_1IReqHandler.html">IReqHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#ab304a56cac09e0cc79ea1ec649e1ecdf">requests</a></td></tr>
<tr class="memdesc:ab304a56cac09e0cc79ea1ec649e1ecdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pending service call requests.  <br /></td></tr>
<tr class="separator:ab304a56cac09e0cc79ea1ec649e1ecdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58f6c6b57599d7f24c322997c652fcf" id="r_ad58f6c6b57599d7f24c322997c652fcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgz_1_1transport_1_1Uuid.html">Uuid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#ad58f6c6b57599d7f24c322997c652fcf">responseReceiverId</a></td></tr>
<tr class="memdesc:ad58f6c6b57599d7f24c322997c652fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Response receiver socket identity.  <br /></td></tr>
<tr class="separator:ad58f6c6b57599d7f24c322997c652fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2cc208f300af40dd33438c14ec6483" id="r_a1a2cc208f300af40dd33438c14ec6483"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a1a2cc208f300af40dd33438c14ec6483">srvDiscPort</a> = <a class="el" href="classgz_1_1transport_1_1NodeShared.html#a258971062fee7fcf02dd37c5d59051b1">kDefaultSrvDiscPort</a></td></tr>
<tr class="memdesc:a1a2cc208f300af40dd33438c14ec6483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Port used by the service discovery layer.  <br /></td></tr>
<tr class="separator:a1a2cc208f300af40dd33438c14ec6483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af814050a071181e9843220c6b0ad8827" id="r_af814050a071181e9843220c6b0ad8827"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/thread.html">std::thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#af814050a071181e9843220c6b0ad8827">threadReception</a></td></tr>
<tr class="memdesc:af814050a071181e9843220c6b0ad8827"><td class="mdescLeft">&#160;</td><td class="mdescRight">thread in charge of receiving and handling incoming messages.  <br /></td></tr>
<tr class="separator:af814050a071181e9843220c6b0ad8827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2caeb4b6f130be43e5a2f0267dd453" id="r_a0b2caeb4b6f130be43e5a2f0267dd453"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a0b2caeb4b6f130be43e5a2f0267dd453">verbose</a></td></tr>
<tr class="memdesc:a0b2caeb4b6f130be43e5a2f0267dd453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print activity to stdout.  <br /></td></tr>
<tr class="separator:a0b2caeb4b6f130be43e5a2f0267dd453"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5ab7be97cfecac0aeea0cde4a9bdf97a" id="r_a5ab7be97cfecac0aeea0cde4a9bdf97a"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a5ab7be97cfecac0aeea0cde4a9bdf97a">kDefaultMsgDiscPort</a> = 10317</td></tr>
<tr class="memdesc:a5ab7be97cfecac0aeea0cde4a9bdf97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default port used by the message discovery layer.  <br /></td></tr>
<tr class="separator:a5ab7be97cfecac0aeea0cde4a9bdf97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258971062fee7fcf02dd37c5d59051b1" id="r_a258971062fee7fcf02dd37c5d59051b1"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a258971062fee7fcf02dd37c5d59051b1">kDefaultSrvDiscPort</a> = 10318</td></tr>
<tr class="memdesc:a258971062fee7fcf02dd37c5d59051b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default port used by the service discovery layer.  <br /></td></tr>
<tr class="separator:a258971062fee7fcf02dd37c5d59051b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0cc80580344aad39916e91dc087eefc7" id="r_a0cc80580344aad39916e91dc087eefc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a0cc80580344aad39916e91dc087eefc7">NodeShared</a> ()</td></tr>
<tr class="memdesc:a0cc80580344aad39916e91dc087eefc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a0cc80580344aad39916e91dc087eefc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df797834627fa506cca6b6661392b4d" id="r_a9df797834627fa506cca6b6661392b4d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1transport_1_1NodeShared.html#a9df797834627fa506cca6b6661392b4d">~NodeShared</a> ()</td></tr>
<tr class="memdesc:a9df797834627fa506cca6b6661392b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a9df797834627fa506cca6b6661392b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Private data for the <a class="el" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">Node</a> class. This class should not be directly used. You should use the <a class="el" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">Node</a> class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0cc80580344aad39916e91dc087eefc7" name="a0cc80580344aad39916e91dc087eefc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc80580344aad39916e91dc087eefc7">&#9670;&#160;</a></span>NodeShared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1transport_1_1NodeShared.html">NodeShared</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="a9df797834627fa506cca6b6661392b4d" name="a9df797834627fa506cca6b6661392b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df797834627fa506cca6b6661392b4d">&#9670;&#160;</a></span>~NodeShared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classgz_1_1transport_1_1NodeShared.html">NodeShared</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a141ffbcd254478db4c5ac918c47fc594" name="a141ffbcd254478db4c5ac918c47fc594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141ffbcd254478db4c5ac918c47fc594">&#9670;&#160;</a></span>AddGlobalRelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddGlobalRelay </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_relayAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a unicast relay IP. All nodes in this process will send UDP unicast traffic to the address to connect networks when UDP multicast traffic is not forwarded. It's also possible to use the environment variable GZ_RELAY to add relays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_relayAddress</td><td>IPv4 address of the relay to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabd50666146d77bf55df8f30637b0b30" name="aabd50666146d77bf55df8f30637b0b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd50666146d77bf55df8f30637b0b30">&#9670;&#160;</a></span>AdvertisePublisher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AdvertisePublisher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1transport_1_1ServicePublisher.html">ServicePublisher</a> &amp;&#160;</td>
          <td class="paramname"><em>_publisher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass through to bool Advertise(const Pub &amp;_publisher) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_publisher</td><td><a class="el" href="classgz_1_1transport_1_1Publisher.html" title="This class stores all the information about a publisher. It stores the topic name that publishes,...">Publisher</a>'s information to advertise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the method succeed or false otherwise (e.g. if the discovery has not been started). </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Pass through to bool Advertise(const Pub &amp;_publisher) </dd></dl>

</div>
</div>
<a id="abc62094ae368bdc1f00ad6ffebcb6bfb" name="abc62094ae368bdc1f00ad6ffebcb6bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc62094ae368bdc1f00ad6ffebcb6bfb">&#9670;&#160;</a></span>CheckHandlerInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgz_1_1transport_1_1NodeShared_1_1HandlerInfo.html">HandlerInfo</a> CheckHandlerInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_topic</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about the local and raw subscribers that are attached to this <a class="el" href="classgz_1_1transport_1_1NodeShared.html" title="Private data for the Node class. This class should not be directly used. You should use the Node clas...">NodeShared</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_topic</td><td>Information will only be returned for handlers that are subscribed to the given topic name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Information about local subscription handlers that are held by this <a class="el" href="classgz_1_1transport_1_1NodeShared.html" title="Private data for the Node class. This class should not be directly used. You should use the Node clas...">NodeShared</a>. </dd></dl>

</div>
</div>
<a id="a47f61f3e393840fdd5ec544e6c30ffa7" name="a47f61f3e393840fdd5ec544e6c30ffa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f61f3e393840fdd5ec544e6c30ffa7">&#9670;&#160;</a></span>CheckSubscriberInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgz_1_1transport_1_1NodeShared_1_1SubscriberInfo.html">SubscriberInfo</a> CheckSubscriberInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_msgType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about the nodes that are subscribed to the publishers of this <a class="el" href="classgz_1_1transport_1_1NodeShared.html" title="Private data for the Node class. This class should not be directly used. You should use the Node clas...">NodeShared</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_topic</td><td>Only information about subscribers to this topic will be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_msgType</td><td>If there are no remote subscribers listening for this message type, then <a class="el" href="structgz_1_1transport_1_1NodeShared_1_1SubscriberInfo.html#a41ed4eeba9f6f227c5df624711e1536d" title="True if this Publisher has any remote subscribers.">SubscriberInfo::haveRemote</a> will be false in the return value of this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Information about subscribers. </dd></dl>

</div>
</div>
<a id="a7886b6094dcc493c7acaeec141928d3f" name="a7886b6094dcc493c7acaeec141928d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7886b6094dcc493c7acaeec141928d3f">&#9670;&#160;</a></span>DiscoverService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DiscoverService </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_topic</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass through to bool <a class="el" href="classgz_1_1transport_1_1Discovery.html#acc6843ffdac56b0cfa7a37f978af2b7e" title="Request discovery information about a topic. When using this method, the user might want to use SetCo...">Discovery::Discover(const std::string
&amp;_topic) const</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_topic</td><td>Service name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the method succeeded or false otherwise (e.g. if the discovery has not been started). </dd></dl>
<dl class="section see"><dt>See also</dt><dd>bool <a class="el" href="classgz_1_1transport_1_1Discovery.html#acc6843ffdac56b0cfa7a37f978af2b7e" title="Request discovery information about a topic. When using this method, the user might want to use SetCo...">Discovery::Discover(const std::string &amp;_topic) const </a> </dd></dl>

</div>
</div>
<a id="a17f532d16ea0fad4a6e8c3ad25a2d77d" name="a17f532d16ea0fad4a6e8c3ad25a2d77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f532d16ea0fad4a6e8c3ad25a2d77d">&#9670;&#160;</a></span>EnableStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnableStats </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; void(const <a class="el" href="classgz_1_1transport_1_1TopicStatistics.html">TopicStatistics</a> &amp;_stats)&gt;&#160;</td>
          <td class="paramname"><em>_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn topic statistics on or off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_topic</td><td>The name of the topic on which to enable or disable statistics. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_enable</td><td>True to enable statistics, false to disable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_cb</td><td>Callback that is triggered whenever statistics are updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada0374fe589ed1dcadb571065a05b80b" name="ada0374fe589ed1dcadb571065a05b80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0374fe589ed1dcadb571065a05b80b">&#9670;&#160;</a></span>GlobalRelays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt; GlobalRelays </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the relay addresses configured for all nodes in this process. </p>
<dl class="section return"><dt>Returns</dt><dd>The relay addresses. </dd></dl>

</div>
</div>
<a id="a465c3f60c4bf0c163213b00a1bf72a3d" name="a465c3f60c4bf0c163213b00a1bf72a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465c3f60c4bf0c163213b00a1bf72a3d">&#9670;&#160;</a></span>Instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classgz_1_1transport_1_1NodeShared.html">NodeShared</a> * Instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classgz_1_1transport_1_1NodeShared.html" title="Private data for the Node class. This class should not be directly used. You should use the Node clas...">NodeShared</a> is a singleton. This method gets the <a class="el" href="classgz_1_1transport_1_1NodeShared.html" title="Private data for the Node class. This class should not be directly used. You should use the Node clas...">NodeShared</a> instance shared between all the nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the current <a class="el" href="classgz_1_1transport_1_1NodeShared.html" title="Private data for the Node class. This class should not be directly used. You should use the Node clas...">NodeShared</a> instance. </dd></dl>

</div>
</div>
<a id="a49d90c6ed95f28c3cf951ed13b3eaddf" name="a49d90c6ed95f28c3cf951ed13b3eaddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d90c6ed95f28c3cf951ed13b3eaddf">&#9670;&#160;</a></span>OnEndRegistration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OnEndRegistration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1transport_1_1MessagePublisher.html">MessagePublisher</a> &amp;&#160;</td>
          <td class="paramname"><em>_pub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback executed when a remote subscriber unregisters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pub</td><td>Information of the remote subscriber. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdd056093895b8583bdc2e4efb0f42f2" name="abdd056093895b8583bdc2e4efb0f42f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd056093895b8583bdc2e4efb0f42f2">&#9670;&#160;</a></span>OnNewConnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OnNewConnection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1transport_1_1MessagePublisher.html">MessagePublisher</a> &amp;&#160;</td>
          <td class="paramname"><em>_pub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback executed when the discovery detects new topics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pub</td><td>Information of the publisher in charge of the topic. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a148a4a10f05f661434c172408cbf28e7" name="a148a4a10f05f661434c172408cbf28e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148a4a10f05f661434c172408cbf28e7">&#9670;&#160;</a></span>OnNewDisconnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OnNewDisconnection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1transport_1_1MessagePublisher.html">MessagePublisher</a> &amp;&#160;</td>
          <td class="paramname"><em>_pub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback executed when the discovery detects disconnections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pub</td><td>Information of the publisher in charge of the topic. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c88b79ac8be6af84c8879d4128b6102" name="a7c88b79ac8be6af84c8879d4128b6102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c88b79ac8be6af84c8879d4128b6102">&#9670;&#160;</a></span>OnNewRegistration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OnNewRegistration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1transport_1_1MessagePublisher.html">MessagePublisher</a> &amp;&#160;</td>
          <td class="paramname"><em>_pub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback executed when a remote subscriber connects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pub</td><td>Information of the remote subscriber. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8864215e8ccd2594a86607dc01600ce2" name="a8864215e8ccd2594a86607dc01600ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8864215e8ccd2594a86607dc01600ce2">&#9670;&#160;</a></span>OnNewSrvConnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OnNewSrvConnection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1transport_1_1ServicePublisher.html">ServicePublisher</a> &amp;&#160;</td>
          <td class="paramname"><em>_pub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback executed when the discovery detects a new service call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pub</td><td>Information of the publisher in charge of the service. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1865c3f0e3d062fadc06abf3f55110ae" name="a1865c3f0e3d062fadc06abf3f55110ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1865c3f0e3d062fadc06abf3f55110ae">&#9670;&#160;</a></span>OnNewSrvDisconnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OnNewSrvDisconnection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1transport_1_1ServicePublisher.html">ServicePublisher</a> &amp;&#160;</td>
          <td class="paramname"><em>_pub</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback executed when a service call is no longer available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pub</td><td>Information of the publisher in charge of the service. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3880d2ef7da1102ce4112ed8913fb090" name="a3880d2ef7da1102ce4112ed8913fb090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3880d2ef7da1102ce4112ed8913fb090">&#9670;&#160;</a></span>OnSubscribers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OnSubscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback executed when a SUBSCRIBERS request is received. </p>

</div>
</div>
<a id="ab9dc25a2a8c3da4e71b152a196294863" name="ab9dc25a2a8c3da4e71b152a196294863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dc25a2a8c3da4e71b152a196294863">&#9670;&#160;</a></span>Publish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Publish </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>_dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1transport.html#acf902668d74f410b5f800c62ea870e09">DeallocFunc</a> *&#160;</td>
          <td class="paramname"><em>_ffn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_msgType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_topic</td><td>Topic to be published. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">_data</td><td>Serialized data. Note that this buffer will be automatically deallocated by ZMQ when all data has been published. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_dataSize</td><td>Data size (bytes). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">_ffn</td><td>Deallocation function. This function is executed by ZeroMQ when the data is published. This function deallocates the buffer containing the published data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://zeromq.org/blog:zero-copy">http://zeromq.org/blog:zero-copy</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_msgType</td><td>Message type in string format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when success or false otherwise. </dd></dl>

</div>
</div>
<a id="a810185d18710c7e2cac2175f6b5cf853" name="a810185d18710c7e2cac2175f6b5cf853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810185d18710c7e2cac2175f6b5cf853">&#9670;&#160;</a></span>RcvHwm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RcvHwm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the capacity of the buffer (High Water Mark) that stores incoming Gazebo Transport messages. Note that this is a global queue shared by all subscribers within the same process. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the buffer storing incoming messages (units are messages). A value of 0 indicates an unlimited buffer and -1 that the socket cannot be queried. The default buffer size is contained in the <a class="el" href="namespacegz_1_1transport.html#a5902ab68c34488c5ffd09d7caeab23af" title="The high water mark of the recieve message buffer.">kDefaultRcvHwm</a> variable. If the buffer is set to unlimited, then your buffer will grow until you run out of memory (and probably crash). If your buffer reaches the maximum capacity data will be dropped. </dd></dl>

</div>
</div>
<a id="a31e2299170973c77293e8bb51b7f8b99" name="a31e2299170973c77293e8bb51b7f8b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e2299170973c77293e8bb51b7f8b99">&#9670;&#160;</a></span>RecvMsgUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecvMsgUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method in charge of receiving the topic updates. </p>

</div>
</div>
<a id="a4c7537cec2074b39b9454f8fbabb20e4" name="a4c7537cec2074b39b9454f8fbabb20e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7537cec2074b39b9454f8fbabb20e4">&#9670;&#160;</a></span>RecvSrvRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecvSrvRequest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method in charge of receiving the service call requests. </p>

</div>
</div>
<a id="ac45fcf30e979af958e3b01cfe4ecfa0c" name="ac45fcf30e979af958e3b01cfe4ecfa0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45fcf30e979af958e3b01cfe4ecfa0c">&#9670;&#160;</a></span>RecvSrvResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RecvSrvResponse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method in charge of receiving the service call responses. </p>

</div>
</div>
<a id="ad79ddfa50c6c3bdae02efa0e7fda3c21" name="ad79ddfa50c6c3bdae02efa0e7fda3c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79ddfa50c6c3bdae02efa0e7fda3c21">&#9670;&#160;</a></span>RunReceptionTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RunReceptionTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data and control messages. </p>

</div>
</div>
<a id="aa9508a12488f9f0c996c727162e7c9e7" name="aa9508a12488f9f0c996c727162e7c9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9508a12488f9f0c996c727162e7c9e7">&#9670;&#160;</a></span>SendPendingRemoteReqs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SendPendingRemoteReqs </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_reqType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_repType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to send all the requests for a given service call and a pair of request/response types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_topic</td><td>Topic name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_reqType</td><td>Type of the request in string format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_repType</td><td>Type of the response in string format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a321d5304fe91d7d1804db54e071a4923" name="a321d5304fe91d7d1804db54e071a4923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321d5304fe91d7d1804db54e071a4923">&#9670;&#160;</a></span>SndHwm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SndHwm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the capacity of the buffer (High Water Mark) that stores outgoing Gazebo Transport messages. Note that this is a global queue shared by all publishers within the same process. </p>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the buffer storing outgoing messages (units are messages). A value of 0 indicates an unlimited buffer and -1 that the socket cannot be queried. The default buffer size is contained in the <a class="el" href="namespacegz_1_1transport.html#ab5c136b2b4ce2a10ef838638a7162d88" title="The high water mark of the send message buffer.">kDefaultSndHwm</a> variable. If the buffer is set to unlimited, then your buffer will grow until you run out of memory (and probably crash). If your buffer reaches the maximum capacity data will be dropped. </dd></dl>

</div>
</div>
<a id="a762717be8feb1d059c1263b0e957fa07" name="a762717be8feb1d059c1263b0e957fa07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762717be8feb1d059c1263b0e957fa07">&#9670;&#160;</a></span>TopicPublishers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TopicPublishers </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1transport.html#ad2b1999c7bd16fa02d6399404ddf2ba0">SrvAddresses_M</a> &amp;&#160;</td>
          <td class="paramname"><em>_publishers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass through to bool Publishers(const std::string &amp;_topic,
Addresses_M&lt;Pub&gt; &amp;_publishers) const. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_topic</td><td>Service name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_publishers</td><td>Collection of service publishers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the service is found and </dd></dl>
<dl class="section see"><dt>See also</dt><dd>bool Publishers(const std::string &amp;_topic,
Addresses_M&lt;Pub&gt; &amp;_publishers) const  </dd></dl>

</div>
</div>
<a id="ab6bea29832d73ef9912d01a98ea42a19" name="ab6bea29832d73ef9912d01a98ea42a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bea29832d73ef9912d01a98ea42a19">&#9670;&#160;</a></span>TopicStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classgz_1_1transport_1_1TopicStatistics.html">TopicStatistics</a> &gt; TopicStats </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_topic</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current statistics for a topic. <a class="el" href="classgz_1_1transport_1_1Statistics.html" title="Computes the rolling average, min, max, and standard deviation for a set of samples.">Statistics</a> must have been enabled using the EnableStatistics function, otherwise the return value will be std::nullopt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_topic</td><td>The name of the topic to get statistics for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classgz_1_1transport_1_1TopicStatistics.html" title="Encapsulates statistics for a single topic. The set of statistics include:">TopicStatistics</a> class, or std::nullopt if statistics were not enabled. </dd></dl>

</div>
</div>
<a id="a39525c8620fbc8b83b350328db85f83b" name="a39525c8620fbc8b83b350328db85f83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39525c8620fbc8b83b350328db85f83b">&#9670;&#160;</a></span>TriggerCallbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TriggerCallbacks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1transport_1_1MessageInfo.html">MessageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_msgData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgz_1_1transport_1_1NodeShared_1_1HandlerInfo.html">HandlerInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>_handlerInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the <a class="el" href="classgz_1_1transport_1_1SubscriptionHandler.html" title="It creates a subscription handler for a specific protobuf message. &#39;T&#39; is the Protobuf message type t...">SubscriptionHandler</a> callbacks (local and raw) for this <a class="el" href="classgz_1_1transport_1_1NodeShared.html" title="Private data for the Node class. This class should not be directly used. You should use the Node clas...">NodeShared</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_info</td><td>Message information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_msgData</td><td>The raw serialized data for the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_handlerInfo</td><td>Information for the handlers of this node, as generated by <a class="el" href="classgz_1_1transport_1_1NodeShared.html#abc62094ae368bdc1f00ad6ffebcb6bfb" title="Get information about the local and raw subscribers that are attached to this NodeShared.">CheckHandlerInfo(const std::string&amp;) const </a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af3ef730335fe33502be1f5c2daac5912" name="af3ef730335fe33502be1f5c2daac5912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ef730335fe33502be1f5c2daac5912">&#9670;&#160;</a></span>discoveryIP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> discoveryIP = &quot;239.255.0.7&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default IP address used by the message discovery layer. </p>

</div>
</div>
<a id="a3a30b238a88023669211195c7126099a" name="a3a30b238a88023669211195c7126099a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a30b238a88023669211195c7126099a">&#9670;&#160;</a></span>hostAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> hostAddr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IP address of this host. </p>

</div>
</div>
<a id="a5ab7be97cfecac0aeea0cde4a9bdf97a" name="a5ab7be97cfecac0aeea0cde4a9bdf97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab7be97cfecac0aeea0cde4a9bdf97a">&#9670;&#160;</a></span>kDefaultMsgDiscPort</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int kDefaultMsgDiscPort = 10317</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default port used by the message discovery layer. </p>

</div>
</div>
<a id="a258971062fee7fcf02dd37c5d59051b1" name="a258971062fee7fcf02dd37c5d59051b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258971062fee7fcf02dd37c5d59051b1">&#9670;&#160;</a></span>kDefaultSrvDiscPort</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int kDefaultSrvDiscPort = 10318</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default port used by the service discovery layer. </p>

</div>
</div>
<a id="a07f1e3d9c5cf0278394ec9b7dc466bd5" name="a07f1e3d9c5cf0278394ec9b7dc466bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f1e3d9c5cf0278394ec9b7dc466bd5">&#9670;&#160;</a></span>localSubscribers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgz_1_1transport_1_1NodeShared_1_1HandlerWrapper.html">HandlerWrapper</a> localSubscribers</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7534df3dab1c28ef54c1e2774f31d224" name="a7534df3dab1c28ef54c1e2774f31d224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7534df3dab1c28ef54c1e2774f31d224">&#9670;&#160;</a></span>msgDiscPort</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msgDiscPort = <a class="el" href="classgz_1_1transport_1_1NodeShared.html#a5ab7be97cfecac0aeea0cde4a9bdf97a">kDefaultMsgDiscPort</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Port used by the message discovery layer. </p>

</div>
</div>
<a id="a754f5256fe35616a2d47ebeb5cd5c4ca" name="a754f5256fe35616a2d47ebeb5cd5c4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754f5256fe35616a2d47ebeb5cd5c4ca">&#9670;&#160;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/recursive_mutex.html">std::recursive_mutex</a> mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex to guarantee exclusive access between all threads. </p>

</div>
</div>
<a id="a52533157bd2ff40e6692f341571aa2e6" name="a52533157bd2ff40e6692f341571aa2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52533157bd2ff40e6692f341571aa2e6">&#9670;&#160;</a></span>myAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> myAddress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>My pub/sub address. </p>

</div>
</div>
<a id="a0499ccd74c7501953161f6d27bfd2162" name="a0499ccd74c7501953161f6d27bfd2162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0499ccd74c7501953161f6d27bfd2162">&#9670;&#160;</a></span>myControlAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> myControlAddress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>My pub/sub control address. </p>

</div>
</div>
<a id="ab51313319f500ead9e0e68be7698bbc2" name="ab51313319f500ead9e0e68be7698bbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51313319f500ead9e0e68be7698bbc2">&#9670;&#160;</a></span>myReplierAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> myReplierAddress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>My replier service call address. </p>

</div>
</div>
<a id="a4fc968562d68138fb00afe2ac0f8ee5f" name="a4fc968562d68138fb00afe2ac0f8ee5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc968562d68138fb00afe2ac0f8ee5f">&#9670;&#160;</a></span>myRequesterAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> myRequesterAddress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>My requester service call address. </p>

</div>
</div>
<a id="a4d760341ce5271134c4367fb0d1bcc28" name="a4d760341ce5271134c4367fb0d1bcc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d760341ce5271134c4367fb0d1bcc28">&#9670;&#160;</a></span>pUuid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> pUuid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process UUID. </p>

</div>
</div>
<a id="a5acb16a02feeb34fa010076509459e31" name="a5acb16a02feeb34fa010076509459e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acb16a02feeb34fa010076509459e31">&#9670;&#160;</a></span>remoteSubscribers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1transport_1_1TopicStorage.html">TopicStorage</a>&lt;<a class="el" href="classgz_1_1transport_1_1MessagePublisher.html">MessagePublisher</a>&gt; remoteSubscribers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remote subscribers. </p>

</div>
</div>
<a id="af80a02ebb4a3861918ae843f69fdd2ba" name="af80a02ebb4a3861918ae843f69fdd2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80a02ebb4a3861918ae843f69fdd2ba">&#9670;&#160;</a></span>replierId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1transport_1_1Uuid.html">Uuid</a> replierId</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replier socket identity. </p>

</div>
</div>
<a id="aa8a673f452357508830a9f9591860557" name="aa8a673f452357508830a9f9591860557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a673f452357508830a9f9591860557">&#9670;&#160;</a></span>repliers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1transport_1_1HandlerStorage.html">HandlerStorage</a>&lt;<a class="el" href="classgz_1_1transport_1_1IRepHandler.html">IRepHandler</a>&gt; repliers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Service call repliers. </p>

</div>
</div>
<a id="ab304a56cac09e0cc79ea1ec649e1ecdf" name="ab304a56cac09e0cc79ea1ec649e1ecdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab304a56cac09e0cc79ea1ec649e1ecdf">&#9670;&#160;</a></span>requests</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1transport_1_1HandlerStorage.html">HandlerStorage</a>&lt;<a class="el" href="classgz_1_1transport_1_1IReqHandler.html">IReqHandler</a>&gt; requests</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pending service call requests. </p>

</div>
</div>
<a id="ad58f6c6b57599d7f24c322997c652fcf" name="ad58f6c6b57599d7f24c322997c652fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58f6c6b57599d7f24c322997c652fcf">&#9670;&#160;</a></span>responseReceiverId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1transport_1_1Uuid.html">Uuid</a> responseReceiverId</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Response receiver socket identity. </p>

</div>
</div>
<a id="a1a2cc208f300af40dd33438c14ec6483" name="a1a2cc208f300af40dd33438c14ec6483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2cc208f300af40dd33438c14ec6483">&#9670;&#160;</a></span>srvDiscPort</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int srvDiscPort = <a class="el" href="classgz_1_1transport_1_1NodeShared.html#a258971062fee7fcf02dd37c5d59051b1">kDefaultSrvDiscPort</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Port used by the service discovery layer. </p>

</div>
</div>
<a id="af814050a071181e9843220c6b0ad8827" name="af814050a071181e9843220c6b0ad8827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af814050a071181e9843220c6b0ad8827">&#9670;&#160;</a></span>threadReception</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/thread.html">std::thread</a> threadReception</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>thread in charge of receiving and handling incoming messages. </p>

</div>
</div>
<a id="a0b2caeb4b6f130be43e5a2f0267dd453" name="a0b2caeb4b6f130be43e5a2f0267dd453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2caeb4b6f130be43e5a2f0267dd453">&#9670;&#160;</a></span>verbose</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int verbose</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print activity to stdout. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="NodeShared_8hh_source.html">NodeShared.hh</a></li>
</ul>
</div><!-- contents -->
      </div>
    </main>
  </div>
</body>
