<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Transport">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Transport: Development</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Transport</h1>
        <h2>API Reference</h2>
        <div class="version">
        15.0.0
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Development</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Next Tutorial: <a class="el" href="topicstatistics.html">Topic Statistics</a> Previous Tutorial: <a class="el" href="envvars.html">Environment Variables</a></p>
<h2><a class="anchor" id="overview-8"></a>
Overview</h2>
<p><b>Note: This section describes some high level concepts of Gazebo Transport but the implementation details only apply to the zeromq middleware backend.</b></p>
<p>The purpose of this section is to describe the internal design of Gazebo Transport. You don't need to read this section if you just want to use the library in your code. This section will help you to understand our source code if you're interested in making code contributions.</p>
<p>Gazebo Transport's internal architecture can be illustrated with the following diagram: </p><pre class="fragment">+=================================================+  +=====================+
|                         Host #1                 |  |       Host #2       |
| +-------------------------+ +-----------------+ |  | +------------------+|
| |      Process #1         | |  Process #2     | |  | |   Process #3     ||
| |  +-------+   +-------+  | |  +-------+      | |  | |    +-------+     ||
| |  |Node #1|   |Node #2|  | |  |Node #3|      | |  | |    |Node #4|     ||
| |  +-------+   +-------+  | |  +-------+      | |  | |    +-------+     ||
| |        ⇅       ⇅        | |      ⇅          | |  | |        ⇅         ||
| |  +-------------------+  | | +-------------+ | |  | | +--------------+ ||
| |  |     Shared #1     |  | | |  Shared #3  | | |  | | |  Shared #4   | ||
| |  +-------------------+  | | +-------------+ | |  | | +--------------+ ||
| |            ⇅         ⇑  | |       ⇅       ⇑ | |  | |        ⇅       ⇑ ||
| |    +--------------+  |  | |+------------+ | | |  | | +------------+ | ||
| |    | Discovery #1 |  |  | ||Discovery #2| | | |  | | |Discovery #3| | ||
| |    +--------------+  ⇓  | |+------------+ ⇓ | |  | | +------------+ ⇓ ||
| +-------------------------+ +-----------------+ |  | +------------------+|
+=================================================+  +=====================+
               ⇅                      ⇅                         ⇅
               ==================================================
               \              Local Area Network                \
                ==================================================
</pre><p>The most important components of the library:</p>
<ol type="1">
<li><p class="startli">Node.</p>
<p class="startli">This class is the main interface with the users. The <code>Node</code> class contains all the functions that allow users to advertise, subscribe and publish topics, as well as advertise and request services. This is the only class that a user should directly use.</p>
</li>
<li><p class="startli">NodeShared (shown as <code>Shared</code> in the diagram for space purposes).</p>
<p class="startli">A single instance of a <code>NodeShared</code> class is shared between all the <code>Node</code> objects running inside the same process. The <code>NodeShared</code> instance contains all the ZMQ sockets used for sending and receiving data for topic and service communication. The goal of this class is to share resources between a group of nodes.</p>
</li>
<li><p class="startli">Discovery.</p>
<p class="startli">A discovery layer is required in each process to learn about the location of topics and services. Our topics and services don't have any location information, they are just plain strings, so we need a way to learn where are they located (similar to a DNS service). <code>Discovery</code> uses a custom protocol and UDP multicast for communicating with other <code>Discovery</code> instances. These instances can be located on the same or different machines over the same LAN. Currently, it is not possible to discover a <code>Node</code> outside of the LAN. This feature will eventually be added to the library in the future.</p>
</li>
</ol>
<h2><a class="anchor" id="discovery-service"></a>
Discovery service</h2>
<p>Communication occurs between nodes via named data streams, called topics. Each node has a universally unique id (UUID) and may run on any machine in a local network. A mechanism, called discovery, is needed to help nodes find each other and the topics that they manage.</p>
<p>The Discovery class implements the protocol for distributed node discovery. The topics are plain strings (<code>/echo</code>, <code>/my_robot/camera</code>) and this layer learns about the meta information associated with each topic. The topic location, the unique identifier of the node providing a service or its process are some examples of the information that the discovery component learns for each topic. The main responsibility of the discovery is to keep an updated list of active topics ready to be queried by other entities.</p>
<p>In Gazebo Transport we use two discovery objects, each one operating on a different UDP port. One object is dedicated to topics and the other is dedicated to services.</p>
<h3><a class="anchor" id="api"></a>
API</h3>
<p>The first thing to do before using a discovery object is to create it. The <code>Discovery</code> class constructor requires a parameter for specifying the UDP port to be used by the discovery sockets and the UUID of the process in which the discovery is running. This UUID will be used when announcing a local topic.</p>
<p>Once a <code>Discovery</code> object is created it won't discover anything. You'll need to call the <code>Start()</code> function for enabling the discovery.</p>
<p>Besides discovering topics from the outside world, the discovery will announce the topics that are offered in the same process that the discovery is running. The <code>Advertise()</code> function will register a local topic and announce it over the network. The symmetric <code>Unadvertise()</code> will notify that a topic won't be offered anymore.</p>
<p><code>Discover()</code> is used to learn about a given topic as soon as possible. It's important to emphasize "as soon as possible" because discovery will eventually learn about all the topics, but this might take some time (depending on your configuration). If a client needs to know about a particular topic, <code>Discover()</code> will trigger a discovery request that will reduce the time needed to discover the information about a topic.</p>
<p>As you can imagine, exchanging messages over the network can be slow and we cannot block the users waiting for discovery information. The number of nodes on a network isn't always known, so it would be difficult and slow to block and return all the information to our users when available. The way we tackle the notification inside <code>Discovery</code> is through callbacks. A discovery user needs to register two callbacks: one for receiving notifications when new topics are available and another for notifying when a topic is no longer active. The functions <code>ConnectionsCb()</code> and <code>DisconnectionsCb()</code> allow the discovery user to set these two notification callbacks. For example, a user will invoke the <code>Discover()</code> call and, after some time, its <code>ConnectionCb</code> will be executed with the information about the requested topic. In the meantime, other callback invocations could be triggered because <code>Discovery</code> will pro-actively learn about all the available topics and generate notifications.</p>
<p>You can check the complete API details <a href="https://gazebosim.org/libs/transport">here</a>.</p>
<h3><a class="anchor" id="unannounce-a-local-topic"></a>
[Un]Announce a local topic</h3>
<p>This feature registers a new topic in the internal data structure that keeps all the discovery information. Local and remote topics are stored in the same way, the only difference is that the local topics will share the process UUID with the discovery service. We store what we call a <code>Publisher</code>, which contains the topic name and all the associated meta-data.</p>
<p>Each publisher advertises the topic with a specific scope as described <a href="nodestopics.html">here</a>. If the topic's scope is <code>PROCESS</code>, the discovery won't announce it over the network. Otherwise, it will send to the multicast group an <code>ADVERTISE</code> message with the following format: </p><pre class="fragment">HEADER
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            Version            |     Process UUID Length       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
\                          Process UUID                         \
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Message Type |             Flags             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre><p> The value of the <code>Message Type</code> field in the header is <code>[UN]ADVERTISE</code>. </p><pre class="fragment">[UN]ADVERTISE
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
\                            Header                             \
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
\                     Serialized Publisher                      \
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre><p> All discovery nodes will receive this request and should update its discovery information and notify its user via the notification callbacks if they didn't have previous information about the topic received. An <code>ADVERTISE</code> message should trigger the connection callback, while an <code>UNADVERTISE</code> message should fire the disconnection callback.</p>
<h3><a class="anchor" id="trigger-a-topic-discovery"></a>
Trigger a topic discovery</h3>
<p>A user can call <code>Discover()</code> for triggering the immediate discovery of a topic. Over the wire, this call will generate a <code>SUBSCRIBE</code> message with the following format: </p><pre class="fragment">SUBSCRIBE
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
\                            Header                             \
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Topic length          |             Topic             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
\                            Topic                              \
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre><p> The value of the <code>Message Type</code> field in the header is <code>SUBSCRIBE</code>.</p>
<p>All discovery instances listening on the same port where the <code>SUBSCRIBE</code> message was sent will receive the message. Each discovery instance with a local topic registered should answer with an <code>ADVERTISE</code> message. The answer is a multicast message that should also be received by all discovery instances.</p>
<h3><a class="anchor" id="topic-update"></a>
Topic update</h3>
<p>Each discovery instance should periodically send an <code>ADVERTISE</code> message per local topic announced over the multicast channel to notify that all information already announced is still valid. The frequency of sending these topic update messages can be changed with the function <code>SetHeartbeatInterval()</code>. By default, the topic update frequency is set to one second.</p>
<p>Alternatively, we could replace the send of all <code>ADVERTISE</code> messages with one <code>HEARTBEAT</code> message that contains the process UUID of the discovery instance. Upon reception, all other discovery instances should update all their entries associated with the received process UUID. Although this approach is more efficient and saves some messages sent over the network, it prevents a discovery instance from learning about topics available without explicitly asking for them. We think this is a good feature to have. For example, an introspection tool that shows all the topics available can take advantage of this feature without any prior knowledge.</p>
<p>It is the responsibility of each discovery instance to cancel any topic that hasn't been updated for a while. The function <code>SilenceInterval()</code> sets the maximum time that an entry should be stored in memory without hearing an <code>ADVERTISE</code> message. Every <code>ADVERTISE</code> message received should refresh the topic timestamp associated with it.</p>
<p>When a discovery instance terminates, it should notify through the discovery channel that all its topics need to be invalidated. This is performed by sending a <code>BYE</code> message with the following format: </p><pre class="fragment">BYE
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
\                            Header                             \
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre><p> The value of the <code>Message Type</code> field in the header is <code>BYE</code>.</p>
<p>When this message is received, a discovery instance should invalidate all entries associated with the process UUID contained in the header. Note that this is the expected behavior when a discovery instance gently terminates. In the case of an abrupt termination, the lack of topic updates will cause the same result, although it'll take a bit more time.</p>
<h3><a class="anchor" id="threading-model"></a>
Threading model</h3>
<p>A discovery instance will create an additional internal thread when the user calls <code>Start()</code>. This thread takes care of the topic update tasks. This involves the reception of other discovery messages and the update of the discovery information. Also, it's among its responsibilities to answer with an <code>ADVERTISE</code> message when a <code>SUBSCRIBE</code> message is received and there are local topics available.</p>
<p>The first time announcement of a local topic and the explicit discovery request of a topic happen on the user thread. So, in a regular scenario where the user doesn't share discovery among other threads, all the discovery operations will run in two threads, the user thread and the internal discovery thread spawned after calling <code>Start()</code>. All the functions in the discovery are thread safe.</p>
<h3><a class="anchor" id="multiple-network-interfaces"></a>
Multiple network interfaces</h3>
<p>The goal of the discovery service is to discover all topics available. It's not uncommon these days that a machine has multiple network interfaces for its wired and wireless connections, a virtual machine, or a localhost device, among others. By selecting one network interface and listening only on this one, we would miss the discovery messages that are sent by instances sitting on other subnets.</p>
<p>Our discovery service handles this problem in several steps. First, it learns about the network interfaces that are available locally. The <code>determineInterfaces()</code> function (contained in <code>NetUtils</code> file) returns a list of all the network interfaces found on the machine. When we know all the available network interfaces we create a container of sockets, one per local IP address. These sockets are used for sending discovery data over the network, flooding all the subnets and reaching other potential discovery instances.</p>
<p>We use one of the sockets contained in the vector for receiving data via the multicast channel. We have to join the multicast group for each local network interface but we can reuse the same socket. This will guarantee that our socket will receive the multicast traffic coming from any of our local network interfaces. This is the reason for having a single <code>bind()</code> function in our call even if we can receive data from multiple interfaces. Our receiving socket is the one we register in the <code>zmq::poll()</code> function for processing incoming discovery data.</p>
<p>When it's time to send outbound data, we iterate through the list of sockets and send the message over each one, flooding all the subnets with our discovery requests.</p>
<p>Note that the result of <code>determineInterfaces()</code> can be manually set by using the <code>GZ_IP</code> environment variable, as described <a href="envvars.html">here</a>. This will essentially ignore other network interfaces, isolating all discovery traffic through the specified interface. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
      </div>
    </main>
  </div>
</body>
