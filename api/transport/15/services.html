<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Transport">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Transport: Services</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Transport</h1>
        <h2>API Reference</h2>
        <div class="version">
        15.0.0~pre2
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Services</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Next Tutorial: <a class="el" href="python.html">Python Support</a> Previous Tutorial: <a class="el" href="messages.html">Messages</a></p>
<h2><a class="anchor" id="overview-2"></a>
Overview</h2>
<p>In this tutorial, we are going to create two nodes that are going to communicate via services. You can see a service as a function that is going to be executed in a different node. Services have two main components: a service provider and a service consumer. A service provider is the node that offers the service to the rest of the world. The service consumers are the nodes that request the function offered by the provider. Note that in Gazebo Transport the location of the service is hidden. The discovery layer of the library is in charge of discovering and keeping an updated list of services available.</p>
<p>In the next tutorial, one node will be the service provider that offers an <em>echo</em> service, whereas the other node will be the service consumer requesting an <em>echo</em> call.</p>
<div class="fragment"><div class="line">mkdir ~/gz_transport_tutorial</div>
<div class="line">cd ~/gz_transport_tutorial</div>
</div><!-- fragment --><h2><a class="anchor" id="responser"></a>
Responser</h2>
<p>Download the <a href="https://github.com/gazebosim/gz-transport/raw/main/example/responser.cc">responser.cc</a> file within the <code>gz_transport_tutorial</code> folder and open it with your favorite editor:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/msgs.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/transport.hh&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> srvEcho(<span class="keyword">const</span> gz::msgs::StringMsg &amp;_req,</div>
<div class="line">  gz::msgs::StringMsg &amp;_rep)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Set the response&#39;s content.</span></div>
<div class="line">  _rep.set_data(_req.data());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The response succeed.</span></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Let&#39;s print the list of our network interfaces.</span></div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;List of network interfaces in this machine:&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;netIface : <a class="code hl_namespace" href="namespacegz.html">gz</a>::transport::determineInterfaces())</div>
<div class="line">    <a class="code hl_namespace" href="namespacestd.html" title="STL namespace.">std</a>::cout &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; netIface &lt;&lt; <a class="code hl_namespace" href="namespacestd.html" title="STL namespace.">std</a>::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a transport node.</span></div>
<div class="line">  <a class="code hl_class" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">gz::transport::Node</a> node;</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> service = <span class="stringliteral">&quot;/echo&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Advertise a service call.</span></div>
<div class="line">  <span class="keywordflow">if</span> (!node.<a class="code hl_function" href="classgz_1_1transport_1_1Node.html#a48c80e1b3823d9071045da3adfe6f8d0" title="Advertise a new topic. If a topic is currently advertised, you cannot advertise it a second time (reg...">Advertise</a>(service, srvEcho))</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error advertising service [&quot;</span> &lt;&lt; service &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Zzzzzz.</span></div>
<div class="line">  <a class="code hl_function" href="namespacegz_1_1transport.html#a5ce095f75195272da1dee933c773a4f7" title="Block the current thread until a SIGINT or SIGTERM is received. Note that this function registers a s...">gz::transport::waitForShutdown</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="walkthrough-6"></a>
Walkthrough</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gz/msgs.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/transport.hh&gt;</span></div>
</div><!-- fragment --><p>The line <code>#include &lt;gz/transport.hh&gt;</code> contains the Gazebo Transport header for using the transport library.</p>
<p>The next line includes the generated Protobuf code that we are going to use for our messages. We are going to use <code>StringMsg</code> type Protobuf messages for our services.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> srvEcho(<span class="keyword">const</span> gz::msgs::StringMsg &amp;_req,</div>
<div class="line">  gz::msgs::StringMsg &amp;_rep)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Set the response&#39;s content.</span></div>
<div class="line">  _rep.set_data(_req.data());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The response succeed.</span></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>As a service provider, our node needs to register a function callback that will execute every time a new service request is received. The signature of the callback is always similar to the one shown in this example with the exception of the Protobuf messages types for the <code>_req</code> (request) and <code>_rep</code> (response). The request parameter contains the input parameters of the request. The response message contains any resulting data from the service call. The return value denotes if the overall service call was considered successful or not. In our example, as a simple <em>echo</em> service, we just fill the response with the same data contained in the request.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a transport node.</span></div>
<div class="line"><a class="code hl_class" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">gz::transport::Node</a> node;</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> service = <span class="stringliteral">&quot;/echo&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Advertise a service call.</span></div>
<div class="line"><span class="keywordflow">if</span> (!node.<a class="code hl_function" href="classgz_1_1transport_1_1Node.html#a48c80e1b3823d9071045da3adfe6f8d0" title="Advertise a new topic. If a topic is currently advertised, you cannot advertise it a second time (reg...">Advertise</a>(service, srvEcho))</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error advertising service [&quot;</span> &lt;&lt; service &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">  <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Zzzzzz.</span></div>
<div class="line"><a class="code hl_function" href="namespacegz_1_1transport.html#a5ce095f75195272da1dee933c773a4f7" title="Block the current thread until a SIGINT or SIGTERM is received. Note that this function registers a s...">gz::transport::waitForShutdown</a>();</div>
</div><!-- fragment --><p>We declare a <em>Node</em> that will offer all the transport functionality. In our case, we are interested in offering a service, so the first step is to announce our service name. Once a service name is advertised, we can accept service requests.</p>
<p>If you don't have any other tasks to do besides waiting for service requests, you can use the call <code>waitForShutdown()</code> that will block your current thread until you hit <em>CTRL-C</em>. Note that this function captures the <em>SIGINT</em> and <em>SIGTERM</em> signals.</p>
<h2><a class="anchor" id="synchronous-requester"></a>
Synchronous requester</h2>
<p>Download the <a href="https://github.com/gazebosim/gz-transport/raw/main/example/requester.cc">requester.cc</a> file within the <code>gz_transport_tutorial</code> folder and open it with your favorite editor:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/msgs.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/transport.hh&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Create a transport node.</span></div>
<div class="line">  <a class="code hl_class" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">gz::transport::Node</a> node;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Prepare the input parameters.</span></div>
<div class="line">  gz::msgs::StringMsg req;</div>
<div class="line">  req.set_data(<span class="stringliteral">&quot;HELLO&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  gz::msgs::StringMsg rep;</div>
<div class="line">  <span class="keywordtype">bool</span> result;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timeout = 5000;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Request the &quot;/echo&quot; service.</span></div>
<div class="line">  <span class="keywordtype">bool</span> executed = node.<a class="code hl_function" href="classgz_1_1transport_1_1Node.html#a027934cd5ed4802842fba02ea5cd6847" title="Request a new service using a non-blocking call. In this version the callback is a free function.">Request</a>(<span class="stringliteral">&quot;/echo&quot;</span>, req, timeout, rep, result);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (executed)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (result)</div>
<div class="line">      <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Response: [&quot;</span> &lt;&lt; rep.data() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Service call failed&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Service call timed out&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="walkthrough-7"></a>
Walkthrough</h3>
<div class="fragment"><div class="line"><span class="comment">// Create a transport node.</span></div>
<div class="line"><a class="code hl_class" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">gz::transport::Node</a> node;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare the input parameters.</span></div>
<div class="line">gz::msgs::StringMsg req;</div>
<div class="line">req.set_data(<span class="stringliteral">&quot;HELLO&quot;</span>);</div>
<div class="line"> </div>
<div class="line">gz::msgs::StringMsg rep;</div>
<div class="line"><span class="keywordtype">bool</span> result;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timeout = 5000;</div>
</div><!-- fragment --><p>We declare the <em>Node</em> that allows us to request a service. Next, we declare and fill the message used as an input parameter for our <em>echo</em> request. Then, we declare the Protobuf message that will contain the response and the variable that will tell us if the service request succeed or failed. In this example, we will use a synchronous request, meaning that our code will block until the response is received or a timeout expires. The value of the timeout is expressed in milliseconds.</p>
<div class="fragment"><div class="line"><span class="comment">// Request the &quot;/echo&quot; service.</span></div>
<div class="line"><span class="keywordtype">bool</span> executed = node.<a class="code hl_function" href="classgz_1_1transport_1_1Node.html#a027934cd5ed4802842fba02ea5cd6847" title="Request a new service using a non-blocking call. In this version the callback is a free function.">Request</a>(<span class="stringliteral">&quot;/echo&quot;</span>, req, timeout, rep, result);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (executed)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (result)</div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Response: [&quot;</span> &lt;&lt; rep.data() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Service call failed&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Service call timed out&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
</div><!-- fragment --><p>In this section of the code we use the method <code>Request()</code> for forwarding the service call to any service provider of the service <code>/echo</code>. Gazebo Transport will find a node, communicate the input data, capture the response and pass it to your output parameter. The return value will tell you if the request expired or the response was received. The <code>result</code> value will tell you if the service provider considered the operation valid.</p>
<p>Imagine for example that we are using a division service, where our input message contains the numerator and denominator. If there are no nodes offering this service, our request will timeout (return value <code>false</code>). On the other hand, if there's at least one node providing the service, the request will return <code>true</code> signaling that the request was received. However, if we set our denominator to <code>0</code> in the input message, <code>result</code> will be <code>false</code> reporting that something went wrong in the request. If the input parameters are valid, we'll receive a result value of <code>true</code> and we can use our response message.</p>
<h2><a class="anchor" id="asynchronous-requester"></a>
Asynchronous requester</h2>
<p>Download the <a href="https://github.com/gazebosim/gz-transport/raw/main/example/requester_async.cc">requester_async.cc</a> file within the <code>gz_transport_tutorial</code> folder and open it with your favorite editor:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/msgs.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/transport.hh&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> responseCb(<span class="keyword">const</span> gz::msgs::StringMsg &amp;_rep, <span class="keyword">const</span> <span class="keywordtype">bool</span> _result)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (_result)</div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Response: [&quot;</span> &lt;&lt; _rep.data() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Service call failed&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Create a transport node.</span></div>
<div class="line">  <a class="code hl_class" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">gz::transport::Node</a> node;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Prepare the input parameters.</span></div>
<div class="line">  gz::msgs::StringMsg req;</div>
<div class="line">  req.set_data(<span class="stringliteral">&quot;HELLO&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Press &lt;CTRL-C&gt; to exit&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Request the &quot;/echo&quot; service.</span></div>
<div class="line">  node.<a class="code hl_function" href="classgz_1_1transport_1_1Node.html#a027934cd5ed4802842fba02ea5cd6847" title="Request a new service using a non-blocking call. In this version the callback is a free function.">Request</a>(<span class="stringliteral">&quot;/echo&quot;</span>, req, responseCb);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Zzzzzz.</span></div>
<div class="line">  <a class="code hl_function" href="namespacegz_1_1transport.html#a5ce095f75195272da1dee933c773a4f7" title="Block the current thread until a SIGINT or SIGTERM is received. Note that this function registers a s...">gz::transport::waitForShutdown</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="walkthrough-8"></a>
Walkthrough</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> responseCb(<span class="keyword">const</span> gz::msgs::StringMsg &amp;_rep, <span class="keyword">const</span> <span class="keywordtype">bool</span> _result)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (_result)</div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Response: [&quot;</span> &lt;&lt; _rep.data() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Service call failed&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We need to register a function callback that will execute when we receive our service response. The signature of the callback is always similar to the one shown in this example with the only exception of the Protobuf message type used in the response. You should create a function callback with the appropriate Protobuf type depending on the response type of the service requested. In our case, we know that the service <code>/echo</code> will answer with a Protobuf <code>StringMsg</code> type.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a transport node.</span></div>
<div class="line"><a class="code hl_class" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">gz::transport::Node</a> node;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare the input parameters.</span></div>
<div class="line">gz::msgs::StringMsg req;</div>
<div class="line">req.set_data(<span class="stringliteral">&quot;HELLO&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Request the &quot;/echo&quot; service.</span></div>
<div class="line">node.<a class="code hl_function" href="classgz_1_1transport_1_1Node.html#a027934cd5ed4802842fba02ea5cd6847" title="Request a new service using a non-blocking call. In this version the callback is a free function.">Request</a>(<span class="stringliteral">&quot;/echo&quot;</span>, req, responseCb);</div>
</div><!-- fragment --><p>In this section of the code we declare a node and a Protobuf message that is filled with the input parameters for our request. Next, we just use the asynchronous variant of the <code>Request()</code> method that forwards a service call to any service provider of the service <code>/echo</code>. Gazebo Transport will find a node, communicate the data, capture the response and pass it to your callback, in addition of the service call result. Note that this variant of <code>Request()</code> is asynchronous, so your code will not block while your service request is handled.</p>
<h2><a class="anchor" id="oneway-responser"></a>
Oneway responser</h2>
<p>Not all the service requests require a response. In these cases we can use a oneway service to process service requests without sending back responses. Oneway services don't accept any output parameters nor the requests have to wait for the response.</p>
<p>Download the <a href="https://github.com/gazebosim/gz-transport/raw/main/example/responser_oneway.cc">responser_oneway.cc</a> file within the <code>gz_transport_tutorial</code> folder and open it with your favorite editor:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/transport.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/msgs.hh&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> srvOneway(<span class="keyword">const</span> gz::msgs::StringMsg &amp;_req)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Request received: [&quot;</span> &lt;&lt; _req.data() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Create a transport node.</span></div>
<div class="line">  <a class="code hl_class" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">gz::transport::Node</a> node;</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> service = <span class="stringliteral">&quot;/oneway&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Advertise a oneway service.</span></div>
<div class="line">  <span class="keywordflow">if</span> (!node.<a class="code hl_function" href="classgz_1_1transport_1_1Node.html#a48c80e1b3823d9071045da3adfe6f8d0" title="Advertise a new topic. If a topic is currently advertised, you cannot advertise it a second time (reg...">Advertise</a>(service, srvOneway))</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error advertising service [&quot;</span> &lt;&lt; service &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Zzzzzz.</span></div>
<div class="line">  <a class="code hl_function" href="namespacegz_1_1transport.html#a5ce095f75195272da1dee933c773a4f7" title="Block the current thread until a SIGINT or SIGTERM is received. Note that this function registers a s...">gz::transport::waitForShutdown</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="walkthrough-9"></a>
Walkthrough</h3>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> srvOneway(<span class="keyword">const</span> gz::msgs::StringMsg &amp;_req)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Request received: [&quot;</span> &lt;&lt; _req.data() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>As a oneway service provider, our node needs to advertise a service that doesn't send a response back. The signature of the callback contains only one parameter that is the input parameter, <code>_req</code> (request). We don't need <code>_rep</code> (response) or <code>_result</code> as there is no response expected. In our example, the value of the input parameter is printed on the screen.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a transport node.</span></div>
<div class="line"><a class="code hl_class" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">gz::transport::Node</a> node;</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> service = <span class="stringliteral">&quot;/oneway&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Advertise a oneway service.</span></div>
<div class="line"><span class="keywordflow">if</span> (!node.<a class="code hl_function" href="classgz_1_1transport_1_1Node.html#a48c80e1b3823d9071045da3adfe6f8d0" title="Advertise a new topic. If a topic is currently advertised, you cannot advertise it a second time (reg...">Advertise</a>(service, srvOneway))</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error advertising service [&quot;</span> &lt;&lt; service &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">  <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We declare a <em>Node</em> that will offer all the transport functionality. In our case, we are interested in offering a oneway service, so the first step is to announce our service name. Once a service name is advertised, we can accept service requests.</p>
<h2><a class="anchor" id="oneway-requester"></a>
Oneway requester</h2>
<p>This case is similar to the oneway service provider. This code can be used for requesting a service that does not need a response back. We don't need any output parameters in this case nor we have to wait for the response.</p>
<p>Download the <a href="https://github.com/gazebosim/gz-transport/raw/main/example/requester_oneway.cc">requester_oneway.cc</a> file within the <code>gz_transport_tutorial</code> folder and open it with your favorite editor:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/transport.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/msgs.hh&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Create a transport node.</span></div>
<div class="line">  <a class="code hl_class" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">gz::transport::Node</a> node;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Prepare the input parameters.</span></div>
<div class="line">  gz::msgs::StringMsg req;</div>
<div class="line">  req.set_data(<span class="stringliteral">&quot;HELLO&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Request the &quot;/oneway&quot; service.</span></div>
<div class="line">  <span class="keywordtype">bool</span> executed = node.<a class="code hl_function" href="classgz_1_1transport_1_1Node.html#a027934cd5ed4802842fba02ea5cd6847" title="Request a new service using a non-blocking call. In this version the callback is a free function.">Request</a>(<span class="stringliteral">&quot;/oneway&quot;</span>, req);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!executed)</div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Service call failed&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Press &lt;CTRL-C&gt; to exit&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Zzzzzz.</span></div>
<div class="line">  <a class="code hl_function" href="namespacegz_1_1transport.html#a5ce095f75195272da1dee933c773a4f7" title="Block the current thread until a SIGINT or SIGTERM is received. Note that this function registers a s...">gz::transport::waitForShutdown</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="walkthrough-10"></a>
Walkthrough</h3>
<div class="fragment"><div class="line"><span class="comment">// Create a transport node.</span></div>
<div class="line"><a class="code hl_class" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">gz::transport::Node</a> node;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare the input parameters.</span></div>
<div class="line">gz::msgs::StringMsg req;</div>
<div class="line">req.set_data(<span class="stringliteral">&quot;HELLO&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Request the &quot;/oneway&quot; service.</span></div>
<div class="line"><span class="keywordtype">bool</span> executed = node.<a class="code hl_function" href="classgz_1_1transport_1_1Node.html#a027934cd5ed4802842fba02ea5cd6847" title="Request a new service using a non-blocking call. In this version the callback is a free function.">Request</a>(<span class="stringliteral">&quot;/oneway&quot;</span>, req);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!executed)</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Service call failed&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
</div><!-- fragment --><p>First of all we declare a node and a Protobuf message that is filled with the input parameters for our <code>/oneway</code> service. Next, we just use the oneway variant of the <code>Request()</code> method that forwards a service call to any service provider of the service <code>/oneway</code>. Gazebo Transport will find a node and communicate the data without waiting for the response. The return value of <code>Request()</code> indicates if the request was successfully queued. Note that this variant of <code>Request()</code> is also asynchronous, so your code will not block while your service request is handled. In this example, we also call <code>waitForShutdown()</code> to minimize the risk of terminating the program before the request was already published.</p>
<h2><a class="anchor" id="service-without-input-parameter"></a>
Service without input parameter</h2>
<p>Sometimes we want to receive some result but don't have any input parameter to send.</p>
<p>Download the <a href="https://github.com/gazebosim/gz-transport/raw/main/example/responser_no_input.cc">responser_no_input.cc</a> file within the <code>gz_transport_tutorial</code> folder and open it with your favorite editor:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/msgs.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/transport.hh&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> srvQuote(gz::msgs::StringMsg &amp;_rep)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> awesomeQuote = <span class="stringliteral">&quot;This is it! This is the answer. It says here...&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;that a bolt of lightning is going to strike the clock tower at precisely &quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;10:04pm, next Saturday night! If...If we could somehow...harness this &quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;lightning...channel it...into the flux capacitor...it just might work. &quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;Next Saturday night, we&#39;re sending you back to the future!&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the response&#39;s content.</span></div>
<div class="line">  _rep.set_data(awesomeQuote);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The response succeed.</span></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Create a transport node.</span></div>
<div class="line">  <a class="code hl_class" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">gz::transport::Node</a> node;</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> service = <span class="stringliteral">&quot;/quote&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Advertise a service call.</span></div>
<div class="line">  <span class="keywordflow">if</span> (!node.<a class="code hl_function" href="classgz_1_1transport_1_1Node.html#a48c80e1b3823d9071045da3adfe6f8d0" title="Advertise a new topic. If a topic is currently advertised, you cannot advertise it a second time (reg...">Advertise</a>(service, srvQuote))</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error advertising service [&quot;</span> &lt;&lt; service &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Zzzzzz.</span></div>
<div class="line">  <a class="code hl_function" href="namespacegz_1_1transport.html#a5ce095f75195272da1dee933c773a4f7" title="Block the current thread until a SIGINT or SIGTERM is received. Note that this function registers a s...">gz::transport::waitForShutdown</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="walkthrough-11"></a>
Walkthrough</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> srvQuote(gz::msgs::StringMsg &amp;_rep)</div>
</div><!-- fragment --><p>Service doesn't receive anything. The signature of the callback contains the parameters <code>_rep</code> (response). In our example, we return the quote.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a transport node.</span></div>
<div class="line"><a class="code hl_class" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">gz::transport::Node</a> node;</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> service = <span class="stringliteral">&quot;/quote&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Advertise a service call.</span></div>
<div class="line"><span class="keywordflow">if</span> (!node.<a class="code hl_function" href="classgz_1_1transport_1_1Node.html#a48c80e1b3823d9071045da3adfe6f8d0" title="Advertise a new topic. If a topic is currently advertised, you cannot advertise it a second time (reg...">Advertise</a>(service, srvQuote))</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Error advertising service [&quot;</span> &lt;&lt; service &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">  <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Zzzzzz.</span></div>
<div class="line"><a class="code hl_function" href="namespacegz_1_1transport.html#a5ce095f75195272da1dee933c773a4f7" title="Block the current thread until a SIGINT or SIGTERM is received. Note that this function registers a s...">gz::transport::waitForShutdown</a>();</div>
</div><!-- fragment --><p>We declare a <em>Node</em> that will offer all the transport functionality. In our case, we are interested in offering service without input, so the first step is to announce the service name. Once a service name is advertised, we can accept service requests.</p>
<h2><a class="anchor" id="empty-requester-sync-and-async"></a>
Empty requester sync and async</h2>
<p>This case is similar to the service without input parameter. We don't send any request.</p>
<p>Download the <a href="https://github.com/gazebosim/gz-transport/raw/main/example/requester_no_input.cc">requester_no_input.cc</a> file within the <code>gz_transport_tutorial</code> folder and open it with your favorite editor:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/msgs.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/transport.hh&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Create a transport node.</span></div>
<div class="line">  <a class="code hl_class" href="classgz_1_1transport_1_1Node.html" title="A class that allows a client to communicate with other peers. There are two main communication modes:...">gz::transport::Node</a> node;</div>
<div class="line"> </div>
<div class="line">  gz::msgs::StringMsg rep;</div>
<div class="line">  <span class="keywordtype">bool</span> result;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timeout = 5000;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Request the &quot;/quote&quot; service.</span></div>
<div class="line">  <span class="keywordtype">bool</span> executed = node.<a class="code hl_function" href="classgz_1_1transport_1_1Node.html#a027934cd5ed4802842fba02ea5cd6847" title="Request a new service using a non-blocking call. In this version the callback is a free function.">Request</a>(<span class="stringliteral">&quot;/quote&quot;</span>, timeout, rep, result);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (executed)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (result)</div>
<div class="line">      <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Response: [&quot;</span> &lt;&lt; rep.data() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Service call failed&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Service call timed out&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="walkthrough-12"></a>
Walkthrough</h3>
<p>First of all we declare a node and a message that will contain the response from <code>/quote</code> service. Next, we use the variant without input parameter of the <code>Request()</code> method. The return value of <code>Request()</code> indicates whether the request timed out or reached the service provider and <code>result</code> shows if the service was successfully executed.</p>
<p>We also have the async version for service request without input. You should download <a href="https://github.com/gazebosim/gz-transport/raw/main/example/requester_async_no_input.cc">requester_async_no_input.cc</a> file within the <code>gz_transport_tutorial</code> folder.</p>
<h2><a class="anchor" id="building-the-code-1"></a>
Building the code</h2>
<p>Download the <a href="https://github.com/gazebosim/gz-transport/raw/main/example/CMakeLists.txt">CMakeLists.txt</a> file within the <code>gz_transport_tutorial</code> folder. Then, create a <code>msgs</code> directory and download <a href="https://github.com/gazebosim/gz-transport/raw/main/example/msgs/CMakeLists.txt">CMakeLists.txt</a> and <a href="https://github.com/gazebosim/gz-transport/raw/main/example/msgs/stringmsg.proto">stringmsg.proto</a> inside the <code>msgs</code> directory.</p>
<p>Once you have all your files, go ahead and create a <code>build/</code> folder within the <code>gz_transport_tutorial</code> directory.</p>
<div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
</div><!-- fragment --><p>Run <code>cmake</code> and build the code.</p>
<div class="fragment"><div class="line"># Linux and MacOS</div>
<div class="line">cmake ..</div>
<div class="line">make responser responser_oneway requester requester_async requester_oneway</div>
<div class="line">make responser_no_input requester_no_input requester_async_no_input</div>
<div class="line"> </div>
<div class="line"># Windows</div>
<div class="line">cmake --build . --config Release</div>
</div><!-- fragment --><h2><a class="anchor" id="running-the-examples-1"></a>
Running the examples</h2>
<p><b>NOTE:</b> It is essential to have a valid value of <code>GZ_PARTITION</code> environment variable and to have it set to the same value in all open terminals. As <code>GZ_PARTITION</code> is based on hostname and username, especially Windows and Mac users might have problems due to spaces in their username, which are not a valid character in <code>GZ_PARTITION</code>. gz-transport prints error <code>Invalid partition name</code> in such case. To resolve that, set <code>GZ_PARTITION</code> explicitly to a valid value: </p><div class="fragment"><div class="line"># Linux and Mac</div>
<div class="line">export GZ_PARTITION=test</div>
<div class="line"># Windows</div>
<div class="line">set GZ_PARTITION=test</div>
</div><!-- fragment --><p><b>NOTE:</b> On Windows, you can see firewall or antivirus prompts when running the examples. For them to work properly, you should allow all communication to the example programs.</p>
<p>Open three new terminals and from your <code>build/</code> directory run the executables.</p>
<p>From terminal 1:</p>
<div class="fragment"><div class="line"># Linux and MacOS</div>
<div class="line">./responser</div>
<div class="line"> </div>
<div class="line"># Windows</div>
<div class="line">.\Release\responser.exe</div>
</div><!-- fragment --><p>From terminal 2:</p>
<div class="fragment"><div class="line"># Linux and MacOS</div>
<div class="line">./requester</div>
<div class="line"> </div>
<div class="line"># Windows</div>
<div class="line">.\Release\requester.exe</div>
</div><!-- fragment --><p>From terminal 3:</p>
<div class="fragment"><div class="line"># Linux and MacOS</div>
<div class="line">./requester_async</div>
<div class="line"> </div>
<div class="line"># Windows</div>
<div class="line">.\Release\requester_async.exe</div>
</div><!-- fragment --><p>In your requester terminals, you should expect an output similar to this one, showing that your requesters have received their responses:</p>
<div class="fragment"><div class="line">$ ./requester</div>
<div class="line">Response: [HELLO]</div>
</div><!-- fragment --><div class="fragment"><div class="line">$ ./requester_async</div>
<div class="line">Press &lt;CTRL-C&gt; to exit</div>
<div class="line">Response: [HELLO]</div>
</div><!-- fragment --><p>For running the oneway examples, open two terminals and from your <code>build/</code> directory run the executables.</p>
<p>From terminal 1:</p>
<div class="fragment"><div class="line"># Linux and MacOS</div>
<div class="line">./responser_oneway</div>
<div class="line"> </div>
<div class="line"># Windows</div>
<div class="line">.\Release\responser_oneway.exe</div>
</div><!-- fragment --><p>From terminal 2:</p>
<div class="fragment"><div class="line"># Linux and MacOS</div>
<div class="line">./requester_oneway</div>
<div class="line"> </div>
<div class="line"># Windows</div>
<div class="line">.\Release\requester_oneway.exe</div>
</div><!-- fragment --><p>In your responser terminal, you should expect an output similar to this one, showing that your service provider has received a request:</p>
<div class="fragment"><div class="line">./responser_oneway</div>
<div class="line">Request received: [HELLO]</div>
</div><!-- fragment --><p>For running the examples without input, open three terminals and from your <code>build/</code> directory run the executables.</p>
<p>From terminal 1:</p>
<div class="fragment"><div class="line"># Linux and MacOS</div>
<div class="line">./responser_no_input</div>
<div class="line"> </div>
<div class="line"># Windows</div>
<div class="line">.\Release\responser_no_input.exe</div>
</div><!-- fragment --><p>From terminal 2:</p>
<div class="fragment"><div class="line"># Linux and MacOS</div>
<div class="line">./requester_no_input</div>
<div class="line"> </div>
<div class="line"># Windows</div>
<div class="line">.\Release\requester_no_input.exe</div>
</div><!-- fragment --><p>From terminal 3:</p>
<div class="fragment"><div class="line"># Linux and MacOS</div>
<div class="line">./requester_async_no_input</div>
<div class="line"> </div>
<div class="line"># Windows</div>
<div class="line">.\Release\requester_async_no_input.exe</div>
</div><!-- fragment --><p>In your requesters' terminals, you should expect an output similar to this one, showing that you have received a response:</p>
<div class="fragment"><div class="line">./requester_no_input</div>
<div class="line"> </div>
<div class="line">Press &lt;CTRL-C&gt; to exit</div>
<div class="line">Response: [This is it! This is the answer. It says here...that a bolt of</div>
<div class="line">lightning is going to strike the clock tower at precisely 10:04pm, next</div>
<div class="line">Saturday night! If...If we could somehow...harness this lightning...channel</div>
<div class="line">it...into the flux capacitor...it just might work. Next Saturday night,</div>
<div class="line">we&#39;re sending you back to the future!]</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
      </div>
    </main>
  </div>
</body>
