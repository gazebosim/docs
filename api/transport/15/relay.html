<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Transport">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Transport: Relay</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Transport</h1>
        <h2>API Reference</h2>
        <div class="version">
        15.0.0
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Relay</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Next Tutorial: <a class="el" href="logging.html">Logging</a> Previous Tutorial: <a class="el" href="security.html">Security</a></p>
<h2><a class="anchor" id="overview-5"></a>
Overview</h2>
<p><b>Note: This feature is only available when using the zeromq middleware backend.</b></p>
<p>In this tutorial, we are going to create two nodes that are not able to communicate with the default configuration of Gazebo Transport. This limitation arises when the nodes are separated by a router, typically when they are part of different local networks. Routers do not propagate UDP multicast traffic and this is the reason for this limitation. We'll create a scenario to simulate this configuration, and then we'll enable the relay capabilities of Gazebo Transport to make the communication possible.</p>
<div class="fragment"><div class="line">mkdir -p ~/gz_transport_tutorial/docker</div>
<div class="line">cd ~/gz_transport_tutorial/docker</div>
</div><!-- fragment --><h2><a class="anchor" id="setup"></a>
Setup</h2>
<p>We'll use Docker to configure the environment for this example. Feel free to install Docker following any of the existing guides available (<a href="https://docs.docker.com/get-docker/">here</a>'s one).</p>
<p>We're going to build a Docker image and run it inside your host computer. Download the Dockerfile: </p><div class="fragment"><div class="line">wget https://github.com/gazebosim/gz-transport/raw/main/docker/Dockerfile -O Dockerfile</div>
</div><!-- fragment --><p>Now, it's time to build the Docker image: </p><div class="fragment"><div class="line">docker build -t gz-transport-relay - &lt; Dockerfile</div>
</div><!-- fragment --><p>Run your Docker container: </p><div class="fragment"><div class="line">docker run -it --rm gz-transport-relay /bin/bash</div>
</div><!-- fragment --><p>Back on your host, make sure that you have Gazebo Tools and net-tools installed: </p><div class="fragment"><div class="line">sudo apt install gz-tools2 net-tools</div>
</div><!-- fragment --><p>Now, let's configure Gazebo Transport to block all multicast traffic going into your Docker instance. Run the command <code>ifconfig</code> to list your network interfaces: </p><div class="fragment"><div class="line">caguero@bb9:~/gz_transport_tutorial/docker$ ifconfig</div>
<div class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</div>
<div class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</div>
<div class="line">        inet6 fe80::42:73ff:fe1c:351e  prefixlen 64  scopeid 0x20&lt;link&gt;</div>
<div class="line">        ether 02:42:73:1c:35:1e  txqueuelen 0  (Ethernet)</div>
<div class="line">        RX packets 943154  bytes 72074740 (72.0 MB)</div>
<div class="line">        RX errors 0  dropped 0  overruns 0  frame 0</div>
<div class="line">        TX packets 1646253  bytes 2714146135 (2.7 GB)</div>
<div class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</div>
<div class="line"> </div>
<div class="line">eno1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</div>
<div class="line">        inet 172.23.1.7  netmask 255.255.252.0  broadcast 172.23.3.255</div>
<div class="line">        inet6 fe80::c115:c109:18df:d327  prefixlen 64  scopeid 0x20&lt;link&gt;</div>
<div class="line">        ether d8:cb:8a:34:c0:50  txqueuelen 1000  (Ethernet)</div>
<div class="line">        RX packets 21694702  bytes 12539677170 (12.5 GB)</div>
<div class="line">        RX errors 0  dropped 0  overruns 0  frame 0</div>
<div class="line">        TX packets 7206435  bytes 1107442513 (1.1 GB)</div>
<div class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</div>
<div class="line">        device interrupt 20  memory 0xfb400000-fb420000</div>
<div class="line"> </div>
<div class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</div>
<div class="line">        inet 127.0.0.1  netmask 255.0.0.0</div>
<div class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</div>
<div class="line">        loop  txqueuelen 1000  (Local Loopback)</div>
<div class="line">        RX packets 71920529  bytes 9057867879 (9.0 GB)</div>
<div class="line">        RX errors 0  dropped 0  overruns 0  frame 0</div>
<div class="line">        TX packets 71920529  bytes 9057867879 (9.0 GB)</div>
<div class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</div>
</div><!-- fragment --><p>We want to isolate Gazebo Transport to the network interface not connected to your Docker instance. Thus, try to identify the IP address of the network interface not associated with Docker or the loopback interface. In our case, the IP address is <code>172.23.1.7</code>.</p>
<h2><a class="anchor" id="launch-the-publisher"></a>
Launch the publisher</h2>
<p>Go back to the terminal inside the Docker container and run the publisher example: </p><div class="fragment"><div class="line">GZ_PARTITION=relay ./publisher</div>
</div><!-- fragment --><h2><a class="anchor" id="launch-the-subscriber"></a>
Launch the subscriber</h2>
<p>Open a terminal in your host and launch your subscriber, forcing Gazebo Transport to only bind to the IP address that we found in the previous step:</p>
<div class="fragment"><div class="line">GZ_IP=172.23.1.7 GZ_PARTITION=relay gz topic -e -t /foo</div>
</div><!-- fragment --><p>You shouldn't receive anything as the discovery messages are not reaching both nodes.</p>
<p>Now, setup your host to relay messages to the node running inside your Docker container. For that purpose, you'll need to know the IP address used in your Docker container. Run the <code>ifconfig</code> command inside your Docker instance: </p><div class="fragment"><div class="line">developer@b98e0f32f32f:~/gz-transport/example/build$ ifconfig</div>
<div class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</div>
<div class="line">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255</div>
<div class="line">        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)</div>
<div class="line">        RX packets 3255  bytes 809362 (809.3 KB)</div>
<div class="line">        RX errors 0  dropped 0  overruns 0  frame 0</div>
<div class="line">        TX packets 761  bytes 85342 (85.3 KB)</div>
<div class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</div>
<div class="line"> </div>
<div class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</div>
<div class="line">        inet 127.0.0.1  netmask 255.0.0.0</div>
<div class="line">        loop  txqueuelen 1000  (Local Loopback)</div>
<div class="line">        RX packets 0  bytes 0 (0.0 B)</div>
<div class="line">        RX errors 0  dropped 0  overruns 0  frame 0</div>
<div class="line">        TX packets 0  bytes 0 (0.0 B)</div>
<div class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</div>
</div><!-- fragment --><p>Go back to your terminal in the host and configure the environment variable <code>GZ_RELAY</code> with the IP address used inside the container.</p>
<div class="fragment"><div class="line">GZ_RELAY=172.17.0.3 GZ_IP=172.23.1.7 GZ_PARTITION=relay gz topic -e -t /foo</div>
</div><!-- fragment --><p>Now, you should receive the messages, as your node in the host is directly relaying the discovery messages inside your Docker instance via unicast.</p>
<h2><a class="anchor" id="known-limitations"></a>
Known limitations</h2>
<p>Keep in mind that the end points of all the nodes should be reachable both ways. The relay feature will overcome the UDP multicast limitation but remember that after the discovery phase the nodes will exchange data directly using a different set of end points. These end points should be reachable from any node, otherwise the communication will not work.</p>
<p>Example: Imagine that you're running a publisher in your home machine. Typically, you'll be using a private IP address behind your home router doing NAT. If you try to run a subscriber node inside a computer over the internet using a public IP, things will not work even using <code>GZ_RELAY</code>. The discovery protocol will reach the subscriber and back (thanks to the NAT), but things will stop at that point. The real data exchange will not be possible, as the subscriber will not be able to communicate with the publisher's endpoint using a private IP address. A solution to this problem is to create a VPN to create the abstraction that both machines are within the same local network. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
      </div>
    </main>
  </div>
</body>
