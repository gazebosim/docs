<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Physics">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Physics: Use a custom engine with Gazebo Physics</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Physics</h1>
        <h2>API Reference</h2>
        <div class="version">
        9.0.0
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Use a custom engine with Gazebo Physics</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="prerequisites-7"></a>
Prerequisites</h2>
<ul>
<li><a class="el" href="installation.html">Installation</a></li>
<li><a class="el" href="physicsplugin.html">Understand physics plugin</a></li>
<li><a class="el" href="physicsengine.html">Use different physics engines</a></li>
<li><a class="el" href="pluginloading.html">Load physics plugin</a></li>
<li><a class="el" href="createcustomfeature.html">Implement custom feature</a></li>
</ul>
<h2><a class="anchor" id="how-to-interface-with-physics-engine"></a>
How to interface with physics engine</h2>
<p>In the previous Implement custom feature tutorial, we walked through how to define and implement a custom feature using an already supported physics engine. This tutorial will explain step-by-step how to interface with any physics engine using Gazebo Physics. We will use <a href="https://github.com/gazebosim/gz-physics/tree/gz-physics9/tpe">TPE</a> as an example in this tutorial.</p>
<h3><a class="anchor" id="structure-of-a-physics-plugin"></a>
Structure of a physics plugin</h3>
<p>Depending on what physics engine you would like to use, the folder structure could be slightly different from what's shown below. Here's the plugin folder structure of TPE, within the Gazebo Physics library.</p>
<div class="fragment"><div class="line">gz-physics</div>
<div class="line">├── tpe</div>
<div class="line">│   ├── plugin                           Implementation of the plugin features interfacing the physics engines API</div>
<div class="line">│   │    ├── src</div>
<div class="line">│   │    |     ├── plugin.cc             Main file for the plugin declaration and plugin registering.</div>
<div class="line">│   │    |     ├── &lt;FEATURES&gt;.hh         The FeatureList header file.</div>
<div class="line">│   │    |     ├── &lt;FEATURES&gt;.cc         Implementation of the FeatureList using physics engine API</div>
<div class="line">│   │    |     └── &lt;FEATURES_TEST&gt;.cc    Tests</div>
<div class="line">│   │    └── CMakeLists.txt              CMake build script for the plugin features.</div>
<div class="line">│   └── CMakeLists.txt                   CMake build script for the plugin.</div>
<div class="line">└── CMakeList.txt                        CMake build script for Gazebo Physics library.</div>
</div><!-- fragment --><p>We link the external physics engine library in <code>CMakeLists.txt</code> of the plugin, assuming the physics engine library is already installed. In our case, <a href="https://github.com/gazebosim/gz-physics/tree/gz-physics9/tpe">TPE</a> is placed inside Gazebo Physics and hence there is a <code>lib</code> folder under <code>tpe</code>.</p>
<p>We declare and implement the <a class="el" href="structgz_1_1physics_1_1FeatureList.html">FeatureList</a> interfacing with the physics engine API inside <code>plugin/src</code> folder (please see Implement custom feature for the plugin feature requirements). Depending on design target, a <a class="el" href="structgz_1_1physics_1_1FeatureList.html">FeatureList</a> is generally a packing of related <a class="el" href="classgz_1_1physics_1_1Feature.html">Features</a>. For example in TPE's <a href="https://github.com/gazebosim/gz-physics/blob/gz-physics9/tpe/plugin/src/EntityManagementFeatures.hh">EntityManagementFeatures</a> , there are <a class="el" href="classgz_1_1physics_1_1GetEngineInfo.html">GetEngineInfo</a>, <a class="el" href="classgz_1_1physics_1_1GetWorldFromEngine.html">GetWorldFromEngine</a>, etc. features defined in the "FeatureList" structure for entity management purpose.</p>
<p>Conventionally, a <a class="el" href="structgz_1_1physics_1_1FeatureList.html">FeatureList</a> can be implemented as:</p><ul>
<li><code>&lt;FEATURES&gt;.hh</code> for the "FeatureList" declaration.</li>
<li><code>&lt;FEATURES&gt;.cc</code> for the "FeatureList" implementation corresponding to each of the <a class="el" href="classgz_1_1physics_1_1Feature.html">Features</a> member functions, using the physics engine API to realize the feature behavior. For a list of common pre-defined features in Gazebo Physics, please refer to <a class="el" href="physicsplugin.html">Understand physics plugin</a> tutorial.</li>
<li><code>&lt;FEATURES_TEST&gt;.cc</code> for unit tests of the "FeatureList".</li>
</ul>
<p>Next, we will use a simplified TPE plugin example to explain important components needed to interface with any physics engine. All code examples used below can be downloaded from <a href="https://github.com/gazebosim/gz-physics/tree/ign-physics2/examples">examples</a> under the <code>simple_plugin</code> folder:</p>
<div class="fragment"><div class="line">simple_plugin</div>
<div class="line">├── CMakeLists.txt</div>
<div class="line">├── plugin.cc</div>
<div class="line">├── EntityManagementFeatures.hh</div>
<div class="line">├── EntityManagementFeatures.cc</div>
<div class="line">└── EntityManagementFeatures_TEST.cc</div>
</div><!-- fragment --><h3><a class="anchor" id="plugincc"></a>
plugin.cc</h3>
<p>In this tutorial, we will show how to construct a simple simulation world using <a href="https://github.com/gazebosim/gz-physics/tree/gz-physics9/tpe">TPE</a> physics engine. For this purpose, we will implement the pre-defined <a class="el" href="classgz_1_1physics_1_1ConstructEmptyWorldFeature.html">ConstructEmptyWorldFeature</a> and include this feature into an empty <a class="el" href="structgz_1_1physics_1_1FeatureList.html">FeatureList</a> named <code>EntityManagementFeatureList</code> defined in <code>EntityManagementFeatures.hh</code>. We first include the <code>EntityManagementFeatureList</code> in <code>plugin.cc</code> main file and register the example TPE physics plugin as follow:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespaceRef" href="https://gazebosim.org/api/common/7/namespacegz.html">gz</a> {</div>
<div class="line"><span class="keyword">namespace </span>physics {</div>
<div class="line"><span class="keyword">namespace </span>simpleplugin {</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>SimplePluginFeatures : FeatureList&lt;</div>
<div class="line">    EntityManagementFeatureList</div>
<div class="line">  &gt; { };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">class </span>Plugin :</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> EntityManagementFeatures,</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> Implements3d&lt;SimplePluginFeatures&gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">using </span>Identity = gz::physics::Identity;</div>
<div class="line">    <span class="keyword">public</span>: Identity InitiateEngine(<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a> <span class="comment">/*_engineID*/</span>)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> this-&gt;GenerateIdentity(0);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_define" href="Register_8hh.html#ae8a956c3cc7caff24077244c505bdf1a" title="Add a plugin that can be used as physics engine.">GZ_PHYSICS_ADD_PLUGIN</a>(Plugin, FeaturePolicy3d, SimplePluginFeatures)</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --><p>Those are 3 things needed to be specified in <code>plugin.cc</code>:</p><ul>
<li>Define the conclusive <a class="el" href="structgz_1_1physics_1_1FeatureList.html">FeatureList</a> including all required "FeatureLists" and <code>Base</code> class. In TPE case, it is <code>TpePluginFeatures</code>.</li>
<li>Define the dimension of the simulation, ex. <a class="el" href="namespacegz_1_1physics.html#a2d96f4e9c1426d8a61da147434b61d66">Implements</a> class implementing <a class="el" href="structgz_1_1physics_1_1FeaturePolicy.html">FeaturePolicy</a> 2D or 3D and different scalar type.</li>
<li>Register the physics plugin using <code>GZ_PHYSICS_ADD_PLUGIN</code> macro (See Implement physics plugin for more detail).</li>
</ul>
<h3><a class="anchor" id="implement-features-with-physics-engines-api"></a>
Implement features with physics engine's API</h3>
<p>Now we would like to implement the <code>EntityManagementFeatures</code>. In the <code>simple_plugin</code> folder, we will create two files <code>EntityManagementFeatures.hh</code> and <code>EntityManagementFeatures.cc</code> to implement a single feature <a class="el" href="classgz_1_1physics_1_1ConstructEmptyWorldFeature.html">ConstructEmptyWorldFeature</a> in <code>EntityManagementFeatures</code> "FeatureList" using TPE API from <code>tpe/lib</code> in Gazebo Physics library.</p>
<p>Before we dive into the feature implementation, we need to understand how the features are defined.</p>
<p>The <a class="el" href="classgz_1_1physics_1_1ConstructEmptyWorldFeature.html">ConstructEmptyWorldFeature</a> is declared in a function template file <code><a class="el" href="ConstructEmpty_8hh.html">gz-physics/include/gz/physics/ConstructEmpty.hh</a></code>.</p>
<p>Gazebo Physics library uses function templates to specify features that accept generic types. The use of templates makes it easier to implement features using different physics engine APIs, without having to repeat the entire code for a function.</p>
<p>The <a class="el" href="classgz_1_1physics_1_1ConstructEmptyWorldFeature.html">ConstructEmptyWorldFeature</a> example here is implemented with TPE API, but a similar feature can also be implemented using DART API.</p>
<p>In this case, we are implementing a feature that is already defined by Gazebo Physics, thus we do not need to write our own template function, and can just include the template in our header file.</p>
<p>But first, let's include the basics:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Implements_8hh.html">gz/physics/Implements.hh</a>&gt;</span></div>
</div><!-- fragment --><p>Then, we include the specific feature template file and add it to the feature list:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ConstructEmpty_8hh.html">gz/physics/ConstructEmpty.hh</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespaceRef" href="https://gazebosim.org/api/common/7/namespacegz.html">gz</a> {</div>
<div class="line"><span class="keyword">namespace </span>physics {</div>
<div class="line"><span class="keyword">namespace </span>simpleplugin {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>EntityManagementFeatureList : FeatureList&lt;</div>
<div class="line">  ConstructEmptyWorldFeature</div>
<div class="line">&gt; { };</div>
<div class="line"> </div>
</div><!-- fragment --><p>We also need to declare the feature function in the header file, but since the function is already declared in the template file we just included, we need to override the generic declaration instead:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>EntityManagementFeatures :</div>
<div class="line">  <span class="keyword">public</span> <span class="keyword">virtual</span> Implements3d&lt;EntityManagementFeatureList&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>: Identity ConstructEmptyWorld(</div>
<div class="line">    <span class="keyword">const</span> Identity &amp;_engineID, <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>EntityManagementFeatures</code> "FeatureList" here inherits from:</p><ul>
<li>(optionally) Base class for foundation metadata definitions of Models, Joints, Links, and Shapes objects of TPE to provide easy access to <a href="https://github.com/gazebosim/gz-physics/tree/gz-physics9/tpe/lib">tpelib</a> structures in the TPE library.</li>
<li><a class="el" href="namespacegz_1_1physics.html#a6d38e59cc9ee7d1edeb9af2205aac83d">Implements3d</a> for implementing the custom feature with <a class="el" href="namespacegz_1_1physics.html#a7f245b484b6675dbb78f5b1aa68790b2">FeaturePolicy3d</a> ("FeaturePolicy" of 3 dimensions and scalar type <code>double</code>).</li>
</ul>
<p>Then we can go ahead with the implementation of <code>ConstructEmptyWorldFeature</code>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">Identity EntityManagementFeatures::ConstructEmptyWorld(</div>
<div class="line">  <span class="keyword">const</span> Identity &amp;, <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Generate dummy identity</span></div>
<div class="line">  <span class="keywordflow">return</span> this-&gt;GenerateIdentity(0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here we show the overriding of <code>ConstructEmptyWorld</code> member function of <a class="el" href="classgz_1_1physics_1_1ConstructEmptyWorldFeature.html">ConstructEmptyWorldFeature</a>, this is where we use the physics engine API to implement this member function. We simply instantiate World object, set the world name and call AddWorld function which was defined in <a href="https://github.com/gazebosim/gz-physics/blob/gz-physics9/tpe/plugin/src/Base.hh">Base.hh</a>.</p>
<p>Simple unit tests are good practice for sanity checks. While we won't go into detail, here is an example to test our new <a class="el" href="classgz_1_1physics_1_1ConstructEmptyWorldFeature.html">ConstructEmptyWorldFeature</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TestFeatureList : <a class="code hl_struct" href="structgz_1_1physics_1_1FeatureList.html" title="Use a FeatureList to aggregate a list of Features.">gz::physics::FeatureList</a>&lt;</div>
<div class="line">  gz::physics::simpleplugin::EntityManagementFeatureList</div>
<div class="line">&gt; { };</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Load the custom plugin</span></div>
<div class="line">  <a class="code hl_classRef" href="https://gazebosim.org/api/plugin/4/classgz_1_1plugin_1_1Loader.html">gz::plugin::Loader</a> loader;</div>
<div class="line">  loader.<a class="code hl_functionRef" href="https://gazebosim.org/api/plugin/4/classgz_1_1plugin_1_1Loader.html#a8613e17bda0674f6e4fa4efaeb9caf32">LoadLib</a>(simple_plugin_LIB);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> simplePlugin =</div>
<div class="line">    loader.<a class="code hl_functionRef" href="https://gazebosim.org/api/plugin/4/classgz_1_1plugin_1_1Loader.html#a38af38708f58ad09a98603ed08fdb33c">Instantiate</a>(<span class="stringliteral">&quot;gz::physics::simpleplugin::Plugin&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get the engine pointer</span></div>
<div class="line">  <span class="keyword">auto</span> engine =</div>
<div class="line">      <a class="code hl_function" href="structgz_1_1physics_1_1RequestEngine.html#aa04799d42bf6171a8e5cb7e83c631aaa" title="Get an Engine from the given physics plugin.">gz::physics::RequestEngine3d&lt;TestFeatureList&gt;::From</a>(simplePlugin);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> == engine)</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Something went wrong, the engine is null&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> world = engine-&gt;ConstructEmptyWorld(<span class="stringliteral">&quot;empty world&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> == world)</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cerr</a> &lt;&lt; <span class="stringliteral">&quot;Failed to create empty world&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;Created empty world!&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>To get a more comprehensive view of how <code>EntityManagementFeatures</code> are constructed in TPE and Dartsim, feel free to take a look here:</p><ul>
<li>Dartsim: <a href="https://github.com/gazebosim/gz-physics/blob/gz-physics9/dartsim/src/EntityManagementFeatures.hh">EntityManagementFeatures.hh</a> and <a href="https://github.com/gazebosim/gz-physics/blob/gz-physics9/dartsim/src/EntityManagementFeatures.cc">EntityManagementFeatures.cc</a></li>
<li>TPE: <a href="https://github.com/gazebosim/gz-physics/blob/gz-physics9/tpe/plugin/src/EntityManagementFeatures.hh">EntityManagementFeatures.hh</a> and <a href="https://github.com/gazebosim/gz-physics/blob/gz-physics9/tpe/plugin/src/EntityManagementFeatures.cc">EntityManagementFeatures.cc</a></li>
</ul>
<h2><a class="anchor" id="compile-and-run-the-example"></a>
Compile and run the example</h2>
<p>Clone the source code, create a build directory and use <code>cmake</code> to compile the code:</p>
<div class="fragment"><div class="line">git clone https://github.com/gazebosim/gz-physics</div>
<div class="line">cd gz-physics/examples/simple_plugin</div>
<div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake ..</div>
<div class="line"># Linux</div>
<div class="line">make</div>
<div class="line"># Windows</div>
<div class="line">cmake --build . --target PluginTest --config Release</div>
</div><!-- fragment --><p>Run the test to verify the new physis plugin:</p>
<div class="fragment"><div class="line"># Linux</div>
<div class="line">./PluginTest</div>
<div class="line"> </div>
<div class="line"># Windows</div>
<div class="line">.\Release\PluginTest.exe</div>
</div><!-- fragment --><p>You'll see:</p>
<div class="fragment"><div class="line">$ ./PluginTest</div>
<div class="line">Created empty world!</div>
</div><!-- fragment --><p>Once you implement more features, you could try passing <code>SimplePlugin</code> as the physics engine to Gazebo Sim following <a class="el" href="physicsengine.html">Use different physics engines</a> tutorial, e.g. setting </p><pre class="fragment"># Linux
export GZ_SIM_PHYSICS_ENGINE_PATH=$GZ_SIM_PHYSICS_ENGINE_PATH:$(pwd)/build
# Windows
set GZ_SIM_PHYSICS_ENGINE_PATH=&lt;PATH_TO_THE_EXAMPLE_DIR&gt;\build\Release
</pre><p> And run Gazebo sim with </p><pre class="fragment">gz sim -v4 -s --physics-engine SimplePlugin
</pre><p> However, with the poor one feature we have implemented in this tutorial, you will only see an error, because Gazebo Sim needs much more features: </p><pre class="fragment">[error] [Physics.cc:854] No physics plugins implementing required interface found in library
[D:\programming\gz9-ws\gz-ws\src\gz-physics\examples\simple_plugin\build\Release\SimplePlugin.dll].
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
      </div>
    </main>
  </div>
</body>
