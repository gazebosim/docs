<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Rendering">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Rendering: BaseCamera&lt; T &gt; Class Template Reference</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Rendering</h1>
        <h2>API Reference</h2>
        <div class="version">
        9.0.0
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.8 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>gz</b></li><li class="navelem"><a class="el" href="namespacegz_1_1rendering.html">rendering</a></li><li class="navelem"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html">BaseCamera</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classgz_1_1rendering_1_1BaseCamera-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">BaseCamera&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="BaseCamera_8hh_source.html">BaseCamera.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab4e6d729ee4a4b156adad7e9c9e729c8" id="r_ab4e6d729ee4a4b156adad7e9c9e729c8"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#ab4e6d729ee4a4b156adad7e9c9e729c8">~BaseCamera</a> ()</td></tr>
<tr class="separator:ab4e6d729ee4a4b156adad7e9c9e729c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebbac9e838781b4640c1e130d072820" id="r_a0ebbac9e838781b4640c1e130d072820"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a0ebbac9e838781b4640c1e130d072820">AddRenderPass</a> (const <a class="el" href="namespacegz_1_1rendering.html#ab078521fc0f74a5a382055db45c0f654">RenderPassPtr</a> &amp;_pass) override</td></tr>
<tr class="memdesc:a0ebbac9e838781b4640c1e130d072820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a render pass to the camera.  <br /></td></tr>
<tr class="separator:a0ebbac9e838781b4640c1e130d072820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109e8eee67f1772565b1b773ee2e9688" id="r_a109e8eee67f1772565b1b773ee2e9688"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a109e8eee67f1772565b1b773ee2e9688">AntiAliasing</a> () const override</td></tr>
<tr class="memdesc:a109e8eee67f1772565b1b773ee2e9688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the level of anti-aliasing used during rendering.  <br /></td></tr>
<tr class="separator:a109e8eee67f1772565b1b773ee2e9688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1255808f1dc32d4f31fd06814cbd0593" id="r_a1255808f1dc32d4f31fd06814cbd0593"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a1255808f1dc32d4f31fd06814cbd0593">AspectRatio</a> () const override</td></tr>
<tr class="memdesc:a1255808f1dc32d4f31fd06814cbd0593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the camera's aspect ratio.  <br /></td></tr>
<tr class="separator:a1255808f1dc32d4f31fd06814cbd0593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402b22114f496f3badf07897c1bf6ff3" id="r_a402b22114f496f3badf07897c1bf6ff3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a402b22114f496f3badf07897c1bf6ff3">Capture</a> (<a class="el" href="classgz_1_1rendering_1_1Image.html">Image</a> &amp;_image) override</td></tr>
<tr class="memdesc:a402b22114f496f3badf07897c1bf6ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a new frame and writes the results to the given image. This is a convenience function for single-camera scenes. It wraps the pre-render, render, post-render, and get-image calls into a single function. This should NOT be used in applications with multiple cameras or multiple consumers of a single camera's images.  <br /></td></tr>
<tr class="separator:a402b22114f496f3badf07897c1bf6ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba15e50318eb987ada33c0a1989eabb3" id="r_aba15e50318eb987ada33c0a1989eabb3"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/common/6/namespacegz_1_1common.html#a34ef659755e21515b805c0120eb9187b">common::ConnectionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#aba15e50318eb987ada33c0a1989eabb3">ConnectNewImageFrame</a> (<a class="el" href="classgz_1_1rendering_1_1Camera.html#aa3161319199b5f9f5f4b2058dcb487cf">Camera::NewFrameListener</a> _listener) override</td></tr>
<tr class="memdesc:aba15e50318eb987ada33c0a1989eabb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes a new listener to this camera's new frame event.  <br /></td></tr>
<tr class="separator:aba15e50318eb987ada33c0a1989eabb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b9b63514c27c8e4fd4333e8483719f" id="r_a17b9b63514c27c8e4fd4333e8483719f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a17b9b63514c27c8e4fd4333e8483719f">Copy</a> (<a class="el" href="classgz_1_1rendering_1_1Image.html">Image</a> &amp;_image) const override</td></tr>
<tr class="memdesc:a17b9b63514c27c8e4fd4333e8483719f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the last rendered image to the given image buffer. This function can be called multiple times after PostRender has been called, without rendering the scene again. Calling this function before a single image has been rendered will have undefined behavior.  <br /></td></tr>
<tr class="separator:a17b9b63514c27c8e4fd4333e8483719f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fe1c6999acf09b6d1af438cd5a7ba9" id="r_ae1fe1c6999acf09b6d1af438cd5a7ba9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgz_1_1rendering_1_1Image.html">Image</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#ae1fe1c6999acf09b6d1af438cd5a7ba9">CreateImage</a> () const override</td></tr>
<tr class="memdesc:ae1fe1c6999acf09b6d1af438cd5a7ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Created an empty image buffer for capturing images. The resulting image will have sufficient memory allocated for subsequent calls to this camera's Capture function. However, any changes to this cameras properties may invalidate the condition.  <br /></td></tr>
<tr class="separator:ae1fe1c6999acf09b6d1af438cd5a7ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbea568ef2df6575ae3c5602b2862bc1" id="r_adbea568ef2df6575ae3c5602b2862bc1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ac06da5e129043c70d45b66d453b2e092">RenderWindowPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#adbea568ef2df6575ae3c5602b2862bc1">CreateRenderWindow</a> () override</td></tr>
<tr class="memdesc:adbea568ef2df6575ae3c5602b2862bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a render window.  <br /></td></tr>
<tr class="separator:adbea568ef2df6575ae3c5602b2862bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8b46e1f44be9b09aa8af96a5bb8efd" id="r_a1a8b46e1f44be9b09aa8af96a5bb8efd"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a1a8b46e1f44be9b09aa8af96a5bb8efd">FarClipPlane</a> () const override</td></tr>
<tr class="memdesc:a1a8b46e1f44be9b09aa8af96a5bb8efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the camera's far clipping plane distance.  <br /></td></tr>
<tr class="separator:a1a8b46e1f44be9b09aa8af96a5bb8efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f349188c849be10e5beaa52d7bc8342" id="r_a3f349188c849be10e5beaa52d7bc8342"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a3f349188c849be10e5beaa52d7bc8342">FollowOffset</a> () const override</td></tr>
<tr class="memdesc:a3f349188c849be10e5beaa52d7bc8342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the follow offset vector in the frame specified at the time the follow target is set.  <br /></td></tr>
<tr class="separator:a3f349188c849be10e5beaa52d7bc8342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce5852924bb998faed58c5a02ee343d" id="r_a2ce5852924bb998faed58c5a02ee343d"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a2ce5852924bb998faed58c5a02ee343d">FollowPGain</a> () const override</td></tr>
<tr class="memdesc:a2ce5852924bb998faed58c5a02ee343d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the camera follow movement P gain.  <br /></td></tr>
<tr class="separator:a2ce5852924bb998faed58c5a02ee343d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129f9a734d9cca80d7348fac5450b9ef" id="r_a129f9a734d9cca80d7348fac5450b9ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a129f9a734d9cca80d7348fac5450b9ef">FollowTarget</a> () const override</td></tr>
<tr class="memdesc:a129f9a734d9cca80d7348fac5450b9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target node being followed.  <br /></td></tr>
<tr class="separator:a129f9a734d9cca80d7348fac5450b9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c1805eaf8a9b547b0a58b680f5470d" id="r_a08c1805eaf8a9b547b0a58b680f5470d"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Angle.html">math::Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a08c1805eaf8a9b547b0a58b680f5470d">HFOV</a> () const override</td></tr>
<tr class="memdesc:a08c1805eaf8a9b547b0a58b680f5470d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the camera's horizontal field-of-view.  <br /></td></tr>
<tr class="separator:a08c1805eaf8a9b547b0a58b680f5470d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f79e57fffb74326ce603ab3e83c1f17" id="r_a3f79e57fffb74326ce603ab3e83c1f17"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a60883d4958a60b91661e97027a85072a">PixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a3f79e57fffb74326ce603ab3e83c1f17">ImageFormat</a> () const override</td></tr>
<tr class="memdesc:a3f79e57fffb74326ce603ab3e83c1f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image pixel format. If the image pixel format has not been set with a valid value, PF_UNKNOWN will be returned.  <br /></td></tr>
<tr class="separator:a3f79e57fffb74326ce603ab3e83c1f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09f6f353e640905a29e60ab02bd068a" id="r_ae09f6f353e640905a29e60ab02bd068a"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#ae09f6f353e640905a29e60ab02bd068a">ImageHeight</a> () const override</td></tr>
<tr class="memdesc:ae09f6f353e640905a29e60ab02bd068a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image height in pixels.  <br /></td></tr>
<tr class="separator:ae09f6f353e640905a29e60ab02bd068a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6199a9e74f9a3c8081649ad6969fdd" id="r_add6199a9e74f9a3c8081649ad6969fdd"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#add6199a9e74f9a3c8081649ad6969fdd">ImageMemorySize</a> () const override</td></tr>
<tr class="memdesc:add6199a9e74f9a3c8081649ad6969fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total image memory size in bytes.  <br /></td></tr>
<tr class="separator:add6199a9e74f9a3c8081649ad6969fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d273c9c48bdfb72b60483c52d312c11" id="r_a0d273c9c48bdfb72b60483c52d312c11"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a0d273c9c48bdfb72b60483c52d312c11">ImageWidth</a> () const override</td></tr>
<tr class="memdesc:a0d273c9c48bdfb72b60483c52d312c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image width in pixels.  <br /></td></tr>
<tr class="separator:a0d273c9c48bdfb72b60483c52d312c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc83c9c632e4f69fcde38be3f19a532" id="r_a5cc83c9c632e4f69fcde38be3f19a532"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a5cc83c9c632e4f69fcde38be3f19a532">NearClipPlane</a> () const override</td></tr>
<tr class="memdesc:a5cc83c9c632e4f69fcde38be3f19a532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the camera's near clipping plane distance.  <br /></td></tr>
<tr class="separator:a5cc83c9c632e4f69fcde38be3f19a532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c7af6b36e2b91213c6f3afaeceb879" id="r_ad4c7af6b36e2b91213c6f3afaeceb879"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#ad4c7af6b36e2b91213c6f3afaeceb879">PostRender</a> () override</td></tr>
<tr class="memdesc:ad4c7af6b36e2b91213c6f3afaeceb879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preforms any necessary final rendering work. Once rendering is complete the camera will alert any listeners of the new frame event. This function should only be called after a call to Render has successfully been executed.  <br /></td></tr>
<tr class="separator:ad4c7af6b36e2b91213c6f3afaeceb879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa744c860a54d7fbd18ee0ff5e44cd1" id="r_a0fa744c860a54d7fbd18ee0ff5e44cd1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a0fa744c860a54d7fbd18ee0ff5e44cd1">PrepareForExternalSampling</a> () override</td></tr>
<tr class="memdesc:a0fa744c860a54d7fbd18ee0ff5e44cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right now this is Vulkan-only. This function needs to be called after rendering, and before handling the texture pointer (i.e. by calling <a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a9fc55ab4c05c3d5a303533db96fdd6c2" title="Get the Metal texture id associated with the render texture used by this camera. A valid Id is obtain...">RenderTextureMetalId()</a>) so that external APIs (e.g. Qt) can sample the texture.  <br /></td></tr>
<tr class="separator:a0fa744c860a54d7fbd18ee0ff5e44cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a062fe0fd3c5f4d771563834e4be9c6" id="r_a2a062fe0fd3c5f4d771563834e4be9c6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a2a062fe0fd3c5f4d771563834e4be9c6">PreRender</a> () override</td></tr>
<tr class="memdesc:a2a062fe0fd3c5f4d771563834e4be9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare this object and any of its children for rendering. This should be called for each object in a scene just before rendering, which can be achieved by a single call to <a class="el" href="classgz_1_1rendering_1_1Scene.html#adffb56e0e545fefebf96b36f295396e9" title="Prepare scene for rendering. The scene will flushing any scene changes by traversing scene-graph,...">Scene::PreRender</a>.  <br /></td></tr>
<tr class="separator:a2a062fe0fd3c5f4d771563834e4be9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640d527387b05edae7c3118773c1904b" id="r_a640d527387b05edae7c3118773c1904b"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#aa83d444bd6cbecb112158663c2e0c213">math::Vector2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a640d527387b05edae7c3118773c1904b">Project</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;_pt) const override</td></tr>
<tr class="memdesc:a640d527387b05edae7c3118773c1904b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project point in 3d world space to 2d screen space.  <br /></td></tr>
<tr class="separator:a640d527387b05edae7c3118773c1904b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af820fa11e3bcc8255a6e2aa127a1c8e0" id="r_af820fa11e3bcc8255a6e2aa127a1c8e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#afe7ea008ee9e656fb34621264a42e04a">math::Matrix4d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#af820fa11e3bcc8255a6e2aa127a1c8e0">ProjectionMatrix</a> () const override</td></tr>
<tr class="memdesc:af820fa11e3bcc8255a6e2aa127a1c8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the projection matrix for this camera.  <br /></td></tr>
<tr class="separator:af820fa11e3bcc8255a6e2aa127a1c8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d40fdf2f3d13d1dc78755512d2883d" id="r_a42d40fdf2f3d13d1dc78755512d2883d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a07f284387dda2cd2d77f2b7a027f501f">CameraProjectionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a42d40fdf2f3d13d1dc78755512d2883d">ProjectionType</a> () const override</td></tr>
<tr class="memdesc:a42d40fdf2f3d13d1dc78755512d2883d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the projection type for this camera.  <br /></td></tr>
<tr class="separator:a42d40fdf2f3d13d1dc78755512d2883d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf794d6828c5096b06b32a47f78145e" id="r_a9bf794d6828c5096b06b32a47f78145e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a9bf794d6828c5096b06b32a47f78145e">RemoveAllRenderPasses</a> () override</td></tr>
<tr class="memdesc:a9bf794d6828c5096b06b32a47f78145e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all render passes from the camera.  <br /></td></tr>
<tr class="separator:a9bf794d6828c5096b06b32a47f78145e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c970396c0167521d5ac5c298448214" id="r_a01c970396c0167521d5ac5c298448214"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a01c970396c0167521d5ac5c298448214">RemoveRenderPass</a> (const <a class="el" href="namespacegz_1_1rendering.html#ab078521fc0f74a5a382055db45c0f654">RenderPassPtr</a> &amp;_pass) override</td></tr>
<tr class="memdesc:a01c970396c0167521d5ac5c298448214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a render pass from the camera.  <br /></td></tr>
<tr class="separator:a01c970396c0167521d5ac5c298448214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8964f08b05c37cb9e2384d7ab823394f" id="r_a8964f08b05c37cb9e2384d7ab823394f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ab078521fc0f74a5a382055db45c0f654">RenderPassPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a8964f08b05c37cb9e2384d7ab823394f">RenderPassByIndex</a> (unsigned int _index) const override</td></tr>
<tr class="memdesc:a8964f08b05c37cb9e2384d7ab823394f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a render passes by index.  <br /></td></tr>
<tr class="separator:a8964f08b05c37cb9e2384d7ab823394f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d637fb2326106c54a11097f40e1e7c5" id="r_a0d637fb2326106c54a11097f40e1e7c5"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a0d637fb2326106c54a11097f40e1e7c5">RenderPassCount</a> () const override</td></tr>
<tr class="memdesc:a0d637fb2326106c54a11097f40e1e7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of render passes applied to the camera.  <br /></td></tr>
<tr class="separator:a0d637fb2326106c54a11097f40e1e7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aad33d75ef7aebe750b8f811a96afc" id="r_a50aad33d75ef7aebe750b8f811a96afc"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a50aad33d75ef7aebe750b8f811a96afc">RenderTextureGLId</a> () const override</td></tr>
<tr class="memdesc:a50aad33d75ef7aebe750b8f811a96afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the OpenGL texture id associated with the render texture used by this camera. A valid id is returned only if the underlying render engine is OpenGL based.  <br /></td></tr>
<tr class="separator:a50aad33d75ef7aebe750b8f811a96afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc55ab4c05c3d5a303533db96fdd6c2" id="r_a9fc55ab4c05c3d5a303533db96fdd6c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a9fc55ab4c05c3d5a303533db96fdd6c2">RenderTextureMetalId</a> (void *_textureIdPtr) const override</td></tr>
<tr class="memdesc:a9fc55ab4c05c3d5a303533db96fdd6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Metal texture id associated with the render texture used by this camera. A valid Id is obtained only if the underlying render engine is Metal based. The pointer set by this function must be released to an id&lt;MTLTexture&gt; using CFBridgingRelease.  <br /></td></tr>
<tr class="separator:a9fc55ab4c05c3d5a303533db96fdd6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ed42232bb67b9d68819919242835ac" id="r_a65ed42232bb67b9d68819919242835ac"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a65ed42232bb67b9d68819919242835ac">SaveFrame</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) override</td></tr>
<tr class="memdesc:a65ed42232bb67b9d68819919242835ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the previously rendered frame to a file. This function can be called multiple times after PostRender has been called, without rendering the scene again. Calling this function before a single image has been rendered will have undefined behavior.  <br /></td></tr>
<tr class="separator:a65ed42232bb67b9d68819919242835ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b30d93eb6528f40812176b4a8034bef" id="r_a5b30d93eb6528f40812176b4a8034bef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a5b30d93eb6528f40812176b4a8034bef">SetAntiAliasing</a> (const unsigned int _aa) override</td></tr>
<tr class="memdesc:a5b30d93eb6528f40812176b4a8034bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the level of anti-aliasing used during rendering. If a value of 0 is given, no anti-aliasing will be performed. Higher values can significantly slow-down rendering times, depending on the underlying render engine.  <br /></td></tr>
<tr class="separator:a5b30d93eb6528f40812176b4a8034bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9714b680f706268287b316b41d1ec4" id="r_a2f9714b680f706268287b316b41d1ec4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a2f9714b680f706268287b316b41d1ec4">SetAspectRatio</a> (const double _ratio) override</td></tr>
<tr class="memdesc:a2f9714b680f706268287b316b41d1ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the camera's aspect ratio. This value determines the cameras vertical field-of-view. It is often the.  <br /></td></tr>
<tr class="separator:a2f9714b680f706268287b316b41d1ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeac6ea05aa4060c49a00c1157956635" id="r_aaeac6ea05aa4060c49a00c1157956635"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#aaeac6ea05aa4060c49a00c1157956635">SetFarClipPlane</a> (const double _far) override</td></tr>
<tr class="memdesc:aaeac6ea05aa4060c49a00c1157956635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the camera's far clipping plane distance.  <br /></td></tr>
<tr class="separator:aaeac6ea05aa4060c49a00c1157956635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac699cc5bdc08e75cff0a9d89dedf3c47" id="r_ac699cc5bdc08e75cff0a9d89dedf3c47"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#ac699cc5bdc08e75cff0a9d89dedf3c47">SetFollowOffset</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;_offset) override</td></tr>
<tr class="memdesc:ac699cc5bdc08e75cff0a9d89dedf3c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set offset of camera from target node being followed. The offset will be in the frame that is specified at the time the follow target is set.  <br /></td></tr>
<tr class="separator:ac699cc5bdc08e75cff0a9d89dedf3c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc44aed499a5063783744390ef719caa" id="r_afc44aed499a5063783744390ef719caa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#afc44aed499a5063783744390ef719caa">SetFollowPGain</a> (const double _pGain) override</td></tr>
<tr class="memdesc:afc44aed499a5063783744390ef719caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set follow P Gain. Determines how fast the camera moves to follow the target node. Valid range: [0-1].  <br /></td></tr>
<tr class="separator:afc44aed499a5063783744390ef719caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2917e6270b03621204bde0f91190731" id="r_ab2917e6270b03621204bde0f91190731"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#ab2917e6270b03621204bde0f91190731">SetFollowTarget</a> (const <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> &amp;_target, const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;_Offset, const bool _worldFrame) override</td></tr>
<tr class="memdesc:ab2917e6270b03621204bde0f91190731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a node for camera to follow. The camera will automatically update its position to keep itself at the specified offset distance from the target being followed. If null is specified, camera follow is disabled. In contrast to SetTrackTarget, the camera does not change its orientation when following is enabled.  <br /></td></tr>
<tr class="separator:ab2917e6270b03621204bde0f91190731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072290bcd172af7b38d81579b43ff140" id="r_a072290bcd172af7b38d81579b43ff140"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a072290bcd172af7b38d81579b43ff140">SetHFOV</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Angle.html">math::Angle</a> &amp;_hfov) override</td></tr>
<tr class="memdesc:a072290bcd172af7b38d81579b43ff140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the camera's horizontal field-of-view.  <br /></td></tr>
<tr class="separator:a072290bcd172af7b38d81579b43ff140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fa339b568fe38499f912d562dcc924" id="r_a62fa339b568fe38499f912d562dcc924"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a62fa339b568fe38499f912d562dcc924">SetImageFormat</a> (<a class="el" href="namespacegz_1_1rendering.html#a60883d4958a60b91661e97027a85072a">PixelFormat</a> _format, bool _reinterpretable=false) override</td></tr>
<tr class="memdesc:a62fa339b568fe38499f912d562dcc924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the image pixel format.  <br /></td></tr>
<tr class="separator:a62fa339b568fe38499f912d562dcc924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e88e59e12c03d871106936fad69f291" id="r_a3e88e59e12c03d871106936fad69f291"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a3e88e59e12c03d871106936fad69f291">SetImageHeight</a> (const unsigned int _height) override</td></tr>
<tr class="memdesc:a3e88e59e12c03d871106936fad69f291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the image height in pixels.  <br /></td></tr>
<tr class="separator:a3e88e59e12c03d871106936fad69f291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0555cfcd77cd43b1459cf6d82ee21941" id="r_a0555cfcd77cd43b1459cf6d82ee21941"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a0555cfcd77cd43b1459cf6d82ee21941">SetImageWidth</a> (const unsigned int _width) override</td></tr>
<tr class="memdesc:a0555cfcd77cd43b1459cf6d82ee21941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the image width in pixels.  <br /></td></tr>
<tr class="separator:a0555cfcd77cd43b1459cf6d82ee21941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc6d45527fa868179e2e2053e7084cb" id="r_a3bc6d45527fa868179e2e2053e7084cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a3bc6d45527fa868179e2e2053e7084cb">SetMaterial</a> (const <a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a> &amp;_material) override</td></tr>
<tr class="memdesc:a3bc6d45527fa868179e2e2053e7084cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a material that the camera should see on all objects.  <br /></td></tr>
<tr class="separator:a3bc6d45527fa868179e2e2053e7084cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2716be2aba22d745afba9106d7d6a1f5" id="r_a2716be2aba22d745afba9106d7d6a1f5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a2716be2aba22d745afba9106d7d6a1f5">SetNearClipPlane</a> (const double _near) override</td></tr>
<tr class="memdesc:a2716be2aba22d745afba9106d7d6a1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the camera's near clipping plane distance.  <br /></td></tr>
<tr class="separator:a2716be2aba22d745afba9106d7d6a1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630025fda8ecf2b8ec7cfc5102005456" id="r_a630025fda8ecf2b8ec7cfc5102005456"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a630025fda8ecf2b8ec7cfc5102005456">SetProjectionMatrix</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#afe7ea008ee9e656fb34621264a42e04a">math::Matrix4d</a> &amp;_matrix) override</td></tr>
<tr class="memdesc:a630025fda8ecf2b8ec7cfc5102005456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the projection matrix for this camera. This overrides the standard projection matrix computed based on camera parameters.  <br /></td></tr>
<tr class="separator:a630025fda8ecf2b8ec7cfc5102005456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135a3efaa036a791d02c537654f700bb" id="r_a135a3efaa036a791d02c537654f700bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a135a3efaa036a791d02c537654f700bb">SetProjectionType</a> (<a class="el" href="namespacegz_1_1rendering.html#a07f284387dda2cd2d77f2b7a027f501f">CameraProjectionType</a> _type) override</td></tr>
<tr class="memdesc:a135a3efaa036a791d02c537654f700bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the projection type for this camera This changes the projection matrix of the camera based on the camera projection type. A custom projection matrix can be specified via <code>SetProjectionMatrix</code> to override the provided one. To disable the custom projection matrix, just call this function again with the desired projection type.  <br /></td></tr>
<tr class="separator:a135a3efaa036a791d02c537654f700bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9474fedc282aeddffab66424417716" id="r_aea9474fedc282aeddffab66424417716"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#aea9474fedc282aeddffab66424417716">SetShadowsDirty</a> () override</td></tr>
<tr class="separator:aea9474fedc282aeddffab66424417716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa8c2386ef1add93cd2c488db362d92" id="r_a9fa8c2386ef1add93cd2c488db362d92"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a9fa8c2386ef1add93cd2c488db362d92">SetTrackOffset</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;_offset) override</td></tr>
<tr class="memdesc:a9fa8c2386ef1add93cd2c488db362d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set track offset. <a class="el" href="classgz_1_1rendering_1_1Camera.html" title="Posable camera used for rendering the scene graph.">Camera</a> will track a point that's at an offset from the target node. The offset will be in the frame that is specified at the time the track target is set.  <br /></td></tr>
<tr class="separator:a9fa8c2386ef1add93cd2c488db362d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241de3dad08c4eaa8fbb357c044fee44" id="r_a241de3dad08c4eaa8fbb357c044fee44"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a241de3dad08c4eaa8fbb357c044fee44">SetTrackPGain</a> (const double _pGain) override</td></tr>
<tr class="memdesc:a241de3dad08c4eaa8fbb357c044fee44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set track P Gain. Determines how fast the camera rotates to look at the target node. Valid range: [0-1].  <br /></td></tr>
<tr class="separator:a241de3dad08c4eaa8fbb357c044fee44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140450b987baaf723f86025690037a55" id="r_a140450b987baaf723f86025690037a55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a140450b987baaf723f86025690037a55">SetTrackTarget</a> (const <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> &amp;_target, const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;_offset, const bool _worldFrame) override</td></tr>
<tr class="memdesc:a140450b987baaf723f86025690037a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a node for camera to track. The camera will automatically change its orientation to face the target being tracked. If null is specified, tracking is disabled. In contrast to SetFollowTarget the camera does not change its position when tracking is enabled.  <br /></td></tr>
<tr class="separator:a140450b987baaf723f86025690037a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542223a05104234fabcaeb5c61adce44" id="r_a542223a05104234fabcaeb5c61adce44"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a542223a05104234fabcaeb5c61adce44">TrackOffset</a> () const override</td></tr>
<tr class="memdesc:a542223a05104234fabcaeb5c61adce44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the track offset vector in the frame specified at the time the track target is set.  <br /></td></tr>
<tr class="separator:a542223a05104234fabcaeb5c61adce44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92b7cc8f3403b6fe75e519d107245c2" id="r_ae92b7cc8f3403b6fe75e519d107245c2"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#ae92b7cc8f3403b6fe75e519d107245c2">TrackPGain</a> () const override</td></tr>
<tr class="memdesc:ae92b7cc8f3403b6fe75e519d107245c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the camera track rotation P gain.  <br /></td></tr>
<tr class="separator:ae92b7cc8f3403b6fe75e519d107245c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c84f6f76fcd4781d78207e3160345e" id="r_a22c84f6f76fcd4781d78207e3160345e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a22c84f6f76fcd4781d78207e3160345e">TrackTarget</a> () const override</td></tr>
<tr class="memdesc:a22c84f6f76fcd4781d78207e3160345e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target node being tracked.  <br /></td></tr>
<tr class="separator:a22c84f6f76fcd4781d78207e3160345e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdddf2ff6454efa496f5a32b737dd10" id="r_aafdddf2ff6454efa496f5a32b737dd10"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#aafdddf2ff6454efa496f5a32b737dd10">Update</a> () override</td></tr>
<tr class="memdesc:aafdddf2ff6454efa496f5a32b737dd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a new frame. This is a convenience function for single-camera scenes. It wraps the pre-render, render, and post-render into a single function. This should NOT be used in applications with multiple cameras or multiple consumers of a single camera's images.  <br /></td></tr>
<tr class="separator:aafdddf2ff6454efa496f5a32b737dd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be7d5a13bf8d8601ffd1941e6098bb9" id="r_a8be7d5a13bf8d8601ffd1941e6098bb9"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#afe7ea008ee9e656fb34621264a42e04a">math::Matrix4d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a8be7d5a13bf8d8601ffd1941e6098bb9">ViewMatrix</a> () const override</td></tr>
<tr class="memdesc:a8be7d5a13bf8d8601ffd1941e6098bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the view matrix for this camera.  <br /></td></tr>
<tr class="separator:a8be7d5a13bf8d8601ffd1941e6098bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce7f083e994273d642990924be50194" id="r_acce7f083e994273d642990924be50194"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#acce7f083e994273d642990924be50194">VisualAt</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#aa83d444bd6cbecb112158663c2e0c213">gz::math::Vector2i</a> &amp;_mousePos) override</td></tr>
<tr class="memdesc:acce7f083e994273d642990924be50194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the visual for a given mouse position param[in] _mousePos mouse position.  <br /></td></tr>
<tr class="separator:acce7f083e994273d642990924be50194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgz_1_1rendering_1_1Camera"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgz_1_1rendering_1_1Camera')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgz_1_1rendering_1_1Camera.html">Camera</a></td></tr>
<tr class="memitem:a8fca188017e03e451bc90f29ea39b79e inherit pub_methods_classgz_1_1rendering_1_1Camera" id="r_a8fca188017e03e451bc90f29ea39b79e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Camera.html#a8fca188017e03e451bc90f29ea39b79e">~Camera</a> ()</td></tr>
<tr class="memdesc:a8fca188017e03e451bc90f29ea39b79e inherit pub_methods_classgz_1_1rendering_1_1Camera"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a8fca188017e03e451bc90f29ea39b79e inherit pub_methods_classgz_1_1rendering_1_1Camera"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47dde92cc4cd811c8db7d851e00510c inherit pub_methods_classgz_1_1rendering_1_1Camera" id="r_ae47dde92cc4cd811c8db7d851e00510c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Camera.html#ae47dde92cc4cd811c8db7d851e00510c">Render</a> ()=0</td></tr>
<tr class="memdesc:ae47dde92cc4cd811c8db7d851e00510c inherit pub_methods_classgz_1_1rendering_1_1Camera"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the current scene using this camera. This function assumes <a class="el" href="classgz_1_1rendering_1_1Object.html#adffb56e0e545fefebf96b36f295396e9" title="Prepare this object and any of its children for rendering. This should be called for each object in a...">PreRender()</a> has already been called on the parent <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>, allowing the camera and the scene itself to prepare for rendering.  <br /></td></tr>
<tr class="separator:ae47dde92cc4cd811c8db7d851e00510c inherit pub_methods_classgz_1_1rendering_1_1Camera"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgz_1_1rendering_1_1Sensor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgz_1_1rendering_1_1Sensor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgz_1_1rendering_1_1Sensor.html">Sensor</a></td></tr>
<tr class="memitem:a4554bb2bc7e88656ce88b99f3308dfe7 inherit pub_methods_classgz_1_1rendering_1_1Sensor" id="r_a4554bb2bc7e88656ce88b99f3308dfe7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Sensor.html#a4554bb2bc7e88656ce88b99f3308dfe7">~Sensor</a> ()</td></tr>
<tr class="memdesc:a4554bb2bc7e88656ce88b99f3308dfe7 inherit pub_methods_classgz_1_1rendering_1_1Sensor"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgz_1_1rendering_1_1Sensor.html" title="Represents a scene sensor. The most obvious example is a camera, but it can be anything that generate...">Sensor</a>.  <br /></td></tr>
<tr class="separator:a4554bb2bc7e88656ce88b99f3308dfe7 inherit pub_methods_classgz_1_1rendering_1_1Sensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa176abb1efda030a293ff1db032ff865 inherit pub_methods_classgz_1_1rendering_1_1Sensor" id="r_aa176abb1efda030a293ff1db032ff865"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Sensor.html#aa176abb1efda030a293ff1db032ff865">SetVisibilityMask</a> (uint32_t _mask)=0</td></tr>
<tr class="memdesc:aa176abb1efda030a293ff1db032ff865 inherit pub_methods_classgz_1_1rendering_1_1Sensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set visibility mask.  <br /></td></tr>
<tr class="separator:aa176abb1efda030a293ff1db032ff865 inherit pub_methods_classgz_1_1rendering_1_1Sensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915ffc8cede400a92265d51ebc02830a inherit pub_methods_classgz_1_1rendering_1_1Sensor" id="r_a915ffc8cede400a92265d51ebc02830a"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Sensor.html#a915ffc8cede400a92265d51ebc02830a">VisibilityMask</a> () const =0</td></tr>
<tr class="memdesc:a915ffc8cede400a92265d51ebc02830a inherit pub_methods_classgz_1_1rendering_1_1Sensor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get visibility mask.  <br /></td></tr>
<tr class="separator:a915ffc8cede400a92265d51ebc02830a inherit pub_methods_classgz_1_1rendering_1_1Sensor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgz_1_1rendering_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgz_1_1rendering_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgz_1_1rendering_1_1Node.html">Node</a></td></tr>
<tr class="memitem:aaaefc7b696b15da7a556d7911735a277 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_aaaefc7b696b15da7a556d7911735a277"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#aaaefc7b696b15da7a556d7911735a277">~Node</a> ()</td></tr>
<tr class="memdesc:aaaefc7b696b15da7a556d7911735a277 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:aaaefc7b696b15da7a556d7911735a277 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d02f3cc5ab358c8fdea34d27d9ba10 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a57d02f3cc5ab358c8fdea34d27d9ba10"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a57d02f3cc5ab358c8fdea34d27d9ba10">AddChild</a> (<a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> _child)=0</td></tr>
<tr class="memdesc:a57d02f3cc5ab358c8fdea34d27d9ba10 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given node to this node. If the given node is already a child, no work will be done.  <br /></td></tr>
<tr class="separator:a57d02f3cc5ab358c8fdea34d27d9ba10 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871102e88c8d8ca41d656c2c9b3ec139 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a871102e88c8d8ca41d656c2c9b3ec139"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a871102e88c8d8ca41d656c2c9b3ec139">ChildById</a> (unsigned int _id) const =0</td></tr>
<tr class="memdesc:a871102e88c8d8ca41d656c2c9b3ec139 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node with given ID. If no child exists with given ID, NULL will be returned.  <br /></td></tr>
<tr class="separator:a871102e88c8d8ca41d656c2c9b3ec139 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ae079ec82a8d9959ecbd5e0ab1db86 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_ad6ae079ec82a8d9959ecbd5e0ab1db86"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#ad6ae079ec82a8d9959ecbd5e0ab1db86">ChildByIndex</a> (unsigned int _index) const =0</td></tr>
<tr class="memdesc:ad6ae079ec82a8d9959ecbd5e0ab1db86 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node at given index. If no child exists at given index, NULL will be returned.  <br /></td></tr>
<tr class="separator:ad6ae079ec82a8d9959ecbd5e0ab1db86 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bc7157905a6db3b17d8cc961d53e71 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a53bc7157905a6db3b17d8cc961d53e71"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a53bc7157905a6db3b17d8cc961d53e71">ChildByName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const =0</td></tr>
<tr class="memdesc:a53bc7157905a6db3b17d8cc961d53e71 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node with given name. If no child exists with given name, NULL will be returned.  <br /></td></tr>
<tr class="separator:a53bc7157905a6db3b17d8cc961d53e71 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefcdcad811da27e8507d591f3fbb3e2 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_acefcdcad811da27e8507d591f3fbb3e2"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#acefcdcad811da27e8507d591f3fbb3e2">ChildCount</a> () const =0</td></tr>
<tr class="memdesc:acefcdcad811da27e8507d591f3fbb3e2 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of child nodes.  <br /></td></tr>
<tr class="separator:acefcdcad811da27e8507d591f3fbb3e2 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad525b0217bf522bfb4d2c8b3b52597a5 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_ad525b0217bf522bfb4d2c8b3b52597a5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#ad525b0217bf522bfb4d2c8b3b52597a5">HasChild</a> (<a class="el" href="namespacegz_1_1rendering.html#a50d64ba521131daafe5877c35eddfd14">ConstNodePtr</a> _child) const =0</td></tr>
<tr class="memdesc:ad525b0217bf522bfb4d2c8b3b52597a5 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if given node is an attached child.  <br /></td></tr>
<tr class="separator:ad525b0217bf522bfb4d2c8b3b52597a5 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4666f0f92cc43e5498c5eec8b9651914 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a4666f0f92cc43e5498c5eec8b9651914"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a4666f0f92cc43e5498c5eec8b9651914">HasChildId</a> (unsigned int _id) const =0</td></tr>
<tr class="memdesc:a4666f0f92cc43e5498c5eec8b9651914 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if node with given ID is an attached child.  <br /></td></tr>
<tr class="separator:a4666f0f92cc43e5498c5eec8b9651914 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e6c3cf2aafdfb5c7550d8284cf9ab8 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_ae9e6c3cf2aafdfb5c7550d8284cf9ab8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#ae9e6c3cf2aafdfb5c7550d8284cf9ab8">HasChildName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const =0</td></tr>
<tr class="memdesc:ae9e6c3cf2aafdfb5c7550d8284cf9ab8 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if node with given name is an attached child.  <br /></td></tr>
<tr class="separator:ae9e6c3cf2aafdfb5c7550d8284cf9ab8 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678e6abd59399644e7ea9d662e3be598 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a678e6abd59399644e7ea9d662e3be598"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a678e6abd59399644e7ea9d662e3be598">HasParent</a> () const =0</td></tr>
<tr class="memdesc:a678e6abd59399644e7ea9d662e3be598 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this <a class="el" href="classgz_1_1rendering_1_1Node.html" title="Represents a single posable node in the scene graph.">Node</a> is attached to another <a class="el" href="classgz_1_1rendering_1_1Node.html" title="Represents a single posable node in the scene graph.">Node</a>.  <br /></td></tr>
<tr class="separator:a678e6abd59399644e7ea9d662e3be598 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2539dacb38fe4e8e310c7dd27fec88 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a9f2539dacb38fe4e8e310c7dd27fec88"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a9f2539dacb38fe4e8e310c7dd27fec88">HasUserData</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_key) const =0</td></tr>
<tr class="memdesc:a9f2539dacb38fe4e8e310c7dd27fec88 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if node has custom data.  <br /></td></tr>
<tr class="separator:a9f2539dacb38fe4e8e310c7dd27fec88 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83787b7fb4b3ab18b82d5eda2684b6b2 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a83787b7fb4b3ab18b82d5eda2684b6b2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a83787b7fb4b3ab18b82d5eda2684b6b2">InheritScale</a> () const =0</td></tr>
<tr class="memdesc:a83787b7fb4b3ab18b82d5eda2684b6b2 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if this node inherits scale from this parent.  <br /></td></tr>
<tr class="separator:a83787b7fb4b3ab18b82d5eda2684b6b2 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabbe7adf07240ec6e706342e5d12d57 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_aaabbe7adf07240ec6e706342e5d12d57"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a507d73d4a494a03691fb87691dd07215">math::Pose3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#aaabbe7adf07240ec6e706342e5d12d57">InitialLocalPose</a> () const =0</td></tr>
<tr class="memdesc:aaabbe7adf07240ec6e706342e5d12d57 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the initial local pose.  <br /></td></tr>
<tr class="separator:aaabbe7adf07240ec6e706342e5d12d57 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8672c8b8aa2dbd6aa2c637a029053bf inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_af8672c8b8aa2dbd6aa2c637a029053bf"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a507d73d4a494a03691fb87691dd07215">math::Pose3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#af8672c8b8aa2dbd6aa2c637a029053bf">LocalPose</a> () const =0</td></tr>
<tr class="memdesc:af8672c8b8aa2dbd6aa2c637a029053bf inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local pose.  <br /></td></tr>
<tr class="separator:af8672c8b8aa2dbd6aa2c637a029053bf inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1daf57ce7664d598dfb447b33b02c29 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_ac1daf57ce7664d598dfb447b33b02c29"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#ac1daf57ce7664d598dfb447b33b02c29">LocalPosition</a> () const =0</td></tr>
<tr class="memdesc:ac1daf57ce7664d598dfb447b33b02c29 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local position.  <br /></td></tr>
<tr class="separator:ac1daf57ce7664d598dfb447b33b02c29 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b1f62c39f0a34ef1978957366d8cb3 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a79b1f62c39f0a34ef1978957366d8cb3"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a0d2bd45f1215359f8e7c0d7ab53c4acb">math::Quaterniond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a79b1f62c39f0a34ef1978957366d8cb3">LocalRotation</a> () const =0</td></tr>
<tr class="memdesc:a79b1f62c39f0a34ef1978957366d8cb3 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local rotation.  <br /></td></tr>
<tr class="separator:a79b1f62c39f0a34ef1978957366d8cb3 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210d11cb425d22c9f58de78738452552 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a210d11cb425d22c9f58de78738452552"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a210d11cb425d22c9f58de78738452552">LocalScale</a> () const =0</td></tr>
<tr class="memdesc:a210d11cb425d22c9f58de78738452552 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local scale.  <br /></td></tr>
<tr class="separator:a210d11cb425d22c9f58de78738452552 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580a7cabf8f0368b1263632cb623ae50 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a580a7cabf8f0368b1263632cb623ae50"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a580a7cabf8f0368b1263632cb623ae50">Origin</a> () const =0</td></tr>
<tr class="memdesc:a580a7cabf8f0368b1263632cb623ae50 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get position of origin.  <br /></td></tr>
<tr class="separator:a580a7cabf8f0368b1263632cb623ae50 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854ac3a4105aac09ba22499797942014 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a854ac3a4105aac09ba22499797942014"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a854ac3a4105aac09ba22499797942014">Parent</a> () const =0</td></tr>
<tr class="memdesc:a854ac3a4105aac09ba22499797942014 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent <a class="el" href="classgz_1_1rendering_1_1Node.html" title="Represents a single posable node in the scene graph.">Node</a>.  <br /></td></tr>
<tr class="separator:a854ac3a4105aac09ba22499797942014 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d68af6aeecd39e62702fdcd11d182e inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_ac3d68af6aeecd39e62702fdcd11d182e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#ac3d68af6aeecd39e62702fdcd11d182e">RemoveChild</a> (<a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> _child)=0</td></tr>
<tr class="memdesc:ac3d68af6aeecd39e62702fdcd11d182e inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove (detach) the given node from this node. If the given node is not a child of this node, no work will be done.  <br /></td></tr>
<tr class="separator:ac3d68af6aeecd39e62702fdcd11d182e inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af567fd4974b51afe9bdf6794c7d25f99 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_af567fd4974b51afe9bdf6794c7d25f99"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#af567fd4974b51afe9bdf6794c7d25f99">RemoveChildById</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:af567fd4974b51afe9bdf6794c7d25f99 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove (detach) the node with the given ID from this node. If the specified node is not a child of this node, no work will be done.  <br /></td></tr>
<tr class="separator:af567fd4974b51afe9bdf6794c7d25f99 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29675be41eeeeefbd26caa3d429e6db0 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a29675be41eeeeefbd26caa3d429e6db0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a29675be41eeeeefbd26caa3d429e6db0">RemoveChildByIndex</a> (unsigned int _index)=0</td></tr>
<tr class="memdesc:a29675be41eeeeefbd26caa3d429e6db0 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove (detach) the node at the given index from this node. If the specified node is not a child of this node, no work will be done.  <br /></td></tr>
<tr class="separator:a29675be41eeeeefbd26caa3d429e6db0 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333e4fee47f4b166e25d5b0ba9597216 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a333e4fee47f4b166e25d5b0ba9597216"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a333e4fee47f4b166e25d5b0ba9597216">RemoveChildByName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a333e4fee47f4b166e25d5b0ba9597216 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove (detach) the node with the given name from this node. If the specified node is not a child of this node, no work will be done.  <br /></td></tr>
<tr class="separator:a333e4fee47f4b166e25d5b0ba9597216 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b4e5600c1b4da2e444f071ca38b19c inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_ae6b4e5600c1b4da2e444f071ca38b19c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#ae6b4e5600c1b4da2e444f071ca38b19c">RemoveChildren</a> ()=0</td></tr>
<tr class="memdesc:ae6b4e5600c1b4da2e444f071ca38b19c inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all child nodes from this node This detaches all the child nodes but does not destroy them.  <br /></td></tr>
<tr class="separator:ae6b4e5600c1b4da2e444f071ca38b19c inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5090c35413cf7de0900aee61624dd36 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_af5090c35413cf7de0900aee61624dd36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#af5090c35413cf7de0900aee61624dd36">RemoveParent</a> ()=0</td></tr>
<tr class="memdesc:af5090c35413cf7de0900aee61624dd36 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach this <a class="el" href="classgz_1_1rendering_1_1Node.html" title="Represents a single posable node in the scene graph.">Node</a> from its parent. If this <a class="el" href="classgz_1_1rendering_1_1Node.html" title="Represents a single posable node in the scene graph.">Node</a> does not have a parent, no work will be done.  <br /></td></tr>
<tr class="separator:af5090c35413cf7de0900aee61624dd36 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b75c5cdb64cc38d6b982d7bdfe7a570 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a3b75c5cdb64cc38d6b982d7bdfe7a570"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a3b75c5cdb64cc38d6b982d7bdfe7a570">Scale</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;_scale)=0</td></tr>
<tr class="memdesc:a3b75c5cdb64cc38d6b982d7bdfe7a570 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the current scale by the given scalars.  <br /></td></tr>
<tr class="separator:a3b75c5cdb64cc38d6b982d7bdfe7a570 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0954da05e042dcc9c738c220b3788e13 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a0954da05e042dcc9c738c220b3788e13"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a0954da05e042dcc9c738c220b3788e13">Scale</a> (double _scale)=0</td></tr>
<tr class="memdesc:a0954da05e042dcc9c738c220b3788e13 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the current scale by the given scalar. The given scalar will be assigned to the x, y, and z coordinates.  <br /></td></tr>
<tr class="separator:a0954da05e042dcc9c738c220b3788e13 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76ae40562065586e383f3f4636e4270 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_ac76ae40562065586e383f3f4636e4270"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#ac76ae40562065586e383f3f4636e4270">Scale</a> (double _x, double _y, double _z)=0</td></tr>
<tr class="memdesc:ac76ae40562065586e383f3f4636e4270 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the current scale by the given scalars.  <br /></td></tr>
<tr class="separator:ac76ae40562065586e383f3f4636e4270 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a37ef9eda88e8716bfae694f12fdede inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a3a37ef9eda88e8716bfae694f12fdede"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a3a37ef9eda88e8716bfae694f12fdede">SetInheritScale</a> (bool _inherit)=0</td></tr>
<tr class="memdesc:a3a37ef9eda88e8716bfae694f12fdede inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify if this node inherits scale from its parent.  <br /></td></tr>
<tr class="separator:a3a37ef9eda88e8716bfae694f12fdede inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e74f89218d972b36c6b8ade64ed06d3 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a5e74f89218d972b36c6b8ade64ed06d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a5e74f89218d972b36c6b8ade64ed06d3">SetLocalPose</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a507d73d4a494a03691fb87691dd07215">math::Pose3d</a> &amp;_pose)=0</td></tr>
<tr class="memdesc:a5e74f89218d972b36c6b8ade64ed06d3 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the local pose.  <br /></td></tr>
<tr class="separator:a5e74f89218d972b36c6b8ade64ed06d3 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7574b6acab8da9075813c71579acd9f inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_ab7574b6acab8da9075813c71579acd9f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#ab7574b6acab8da9075813c71579acd9f">SetLocalPosition</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;_position)=0</td></tr>
<tr class="memdesc:ab7574b6acab8da9075813c71579acd9f inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the local position.  <br /></td></tr>
<tr class="separator:ab7574b6acab8da9075813c71579acd9f inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7d3cfa00557a6325c037159c553cad inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a5d7d3cfa00557a6325c037159c553cad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a5d7d3cfa00557a6325c037159c553cad">SetLocalPosition</a> (double _x, double _y, double _z)=0</td></tr>
<tr class="memdesc:a5d7d3cfa00557a6325c037159c553cad inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the local position.  <br /></td></tr>
<tr class="separator:a5d7d3cfa00557a6325c037159c553cad inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50d80f802e1a7deefdb518a16ca0a34 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_ac50d80f802e1a7deefdb518a16ca0a34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#ac50d80f802e1a7deefdb518a16ca0a34">SetLocalRotation</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a0d2bd45f1215359f8e7c0d7ab53c4acb">math::Quaterniond</a> &amp;_rotation)=0</td></tr>
<tr class="memdesc:ac50d80f802e1a7deefdb518a16ca0a34 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the local rotation.  <br /></td></tr>
<tr class="separator:ac50d80f802e1a7deefdb518a16ca0a34 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd53b6f909bb275a2e87528b6fffcc9 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a7cd53b6f909bb275a2e87528b6fffcc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a7cd53b6f909bb275a2e87528b6fffcc9">SetLocalRotation</a> (double _r, double _p, double _y)=0</td></tr>
<tr class="memdesc:a7cd53b6f909bb275a2e87528b6fffcc9 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the local rotation.  <br /></td></tr>
<tr class="separator:a7cd53b6f909bb275a2e87528b6fffcc9 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2373354f3e335162ef40defe521fe709 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a2373354f3e335162ef40defe521fe709"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a2373354f3e335162ef40defe521fe709">SetLocalRotation</a> (double _w, double _x, double _y, double _z)=0</td></tr>
<tr class="memdesc:a2373354f3e335162ef40defe521fe709 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the local rotation.  <br /></td></tr>
<tr class="separator:a2373354f3e335162ef40defe521fe709 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901ea761fbc245a2cfae6bab8eaecd25 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a901ea761fbc245a2cfae6bab8eaecd25"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a901ea761fbc245a2cfae6bab8eaecd25">SetLocalScale</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;_scale)=0</td></tr>
<tr class="memdesc:a901ea761fbc245a2cfae6bab8eaecd25 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the local scale.  <br /></td></tr>
<tr class="separator:a901ea761fbc245a2cfae6bab8eaecd25 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cfea247397d35986d6f99ffb10f038 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a96cfea247397d35986d6f99ffb10f038"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a96cfea247397d35986d6f99ffb10f038">SetLocalScale</a> (double _scale)=0</td></tr>
<tr class="memdesc:a96cfea247397d35986d6f99ffb10f038 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the local scale. The given scale will be assigned to the x, y, and z coordinates.  <br /></td></tr>
<tr class="separator:a96cfea247397d35986d6f99ffb10f038 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f12b619bfe81c8e341ebd0db9bf8923 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a2f12b619bfe81c8e341ebd0db9bf8923"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a2f12b619bfe81c8e341ebd0db9bf8923">SetLocalScale</a> (double _x, double _y, double _z)=0</td></tr>
<tr class="memdesc:a2f12b619bfe81c8e341ebd0db9bf8923 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the local scale.  <br /></td></tr>
<tr class="separator:a2f12b619bfe81c8e341ebd0db9bf8923 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d794375242389c41a3d1c709e7be21 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a73d794375242389c41a3d1c709e7be21"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a73d794375242389c41a3d1c709e7be21">SetOrigin</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;_origin)=0</td></tr>
<tr class="memdesc:a73d794375242389c41a3d1c709e7be21 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position of origin. The position should be relative to the original origin of the geometry.  <br /></td></tr>
<tr class="separator:a73d794375242389c41a3d1c709e7be21 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21092809b07502b3e96a6c08d52554c4 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a21092809b07502b3e96a6c08d52554c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a21092809b07502b3e96a6c08d52554c4">SetOrigin</a> (double _x, double _y, double _z)=0</td></tr>
<tr class="memdesc:a21092809b07502b3e96a6c08d52554c4 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position of origin. The position should be relative to the original origin of the geometry.  <br /></td></tr>
<tr class="separator:a21092809b07502b3e96a6c08d52554c4 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8733df07110f67ddfaf3427dd48ce5f9 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a8733df07110f67ddfaf3427dd48ce5f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a8733df07110f67ddfaf3427dd48ce5f9">SetUserData</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_key, <a class="el" href="namespacegz_1_1rendering.html#a7d2ef54f60c0f073a8aab8f9568bfc4e">Variant</a> _value)=0</td></tr>
<tr class="memdesc:a8733df07110f67ddfaf3427dd48ce5f9 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgz_1_1rendering_1_1Store.html" title="Multi-access storage structure of template class T. Template class T is expected to have functions Ge...">Store</a> any custom data associated with this node.  <br /></td></tr>
<tr class="separator:a8733df07110f67ddfaf3427dd48ce5f9 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa09afc6b73818ba48c187dc1a1d01e inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a6fa09afc6b73818ba48c187dc1a1d01e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a6fa09afc6b73818ba48c187dc1a1d01e">SetWorldPose</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a507d73d4a494a03691fb87691dd07215">math::Pose3d</a> &amp;_pose)=0</td></tr>
<tr class="memdesc:a6fa09afc6b73818ba48c187dc1a1d01e inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the world pose.  <br /></td></tr>
<tr class="separator:a6fa09afc6b73818ba48c187dc1a1d01e inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1417d1160c1e0b4bdef7df5bf2fbfeef inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a1417d1160c1e0b4bdef7df5bf2fbfeef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a1417d1160c1e0b4bdef7df5bf2fbfeef">SetWorldPosition</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;_position)=0</td></tr>
<tr class="memdesc:a1417d1160c1e0b4bdef7df5bf2fbfeef inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the world position.  <br /></td></tr>
<tr class="separator:a1417d1160c1e0b4bdef7df5bf2fbfeef inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bc2aba0e67a7129cce81239aa54f79 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a29bc2aba0e67a7129cce81239aa54f79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a29bc2aba0e67a7129cce81239aa54f79">SetWorldPosition</a> (double _x, double _y, double _z)=0</td></tr>
<tr class="memdesc:a29bc2aba0e67a7129cce81239aa54f79 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the world position.  <br /></td></tr>
<tr class="separator:a29bc2aba0e67a7129cce81239aa54f79 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5956bc5cd11bf313362f1422c0af18f4 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a5956bc5cd11bf313362f1422c0af18f4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a5956bc5cd11bf313362f1422c0af18f4">SetWorldRotation</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a0d2bd45f1215359f8e7c0d7ab53c4acb">math::Quaterniond</a> &amp;_rotation)=0</td></tr>
<tr class="memdesc:a5956bc5cd11bf313362f1422c0af18f4 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the world rotation.  <br /></td></tr>
<tr class="separator:a5956bc5cd11bf313362f1422c0af18f4 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201061e5d5068f320046a3c9fdf99f52 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a201061e5d5068f320046a3c9fdf99f52"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a201061e5d5068f320046a3c9fdf99f52">SetWorldRotation</a> (double _r, double _p, double _y)=0</td></tr>
<tr class="memdesc:a201061e5d5068f320046a3c9fdf99f52 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the world rotation.  <br /></td></tr>
<tr class="separator:a201061e5d5068f320046a3c9fdf99f52 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a670a1734b78a95e82316b55d697995 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a4a670a1734b78a95e82316b55d697995"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a4a670a1734b78a95e82316b55d697995">SetWorldRotation</a> (double _w, double _x, double _y, double _z)=0</td></tr>
<tr class="memdesc:a4a670a1734b78a95e82316b55d697995 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the world rotation.  <br /></td></tr>
<tr class="separator:a4a670a1734b78a95e82316b55d697995 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50de2ec06c13ef2db3f02d0d65a23f31 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a50de2ec06c13ef2db3f02d0d65a23f31"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a50de2ec06c13ef2db3f02d0d65a23f31">SetWorldScale</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;_scale)=0</td></tr>
<tr class="memdesc:a50de2ec06c13ef2db3f02d0d65a23f31 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the world scale.  <br /></td></tr>
<tr class="separator:a50de2ec06c13ef2db3f02d0d65a23f31 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77c8cb7b56b7e45c8dc4391ebd8b24c inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_aa77c8cb7b56b7e45c8dc4391ebd8b24c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#aa77c8cb7b56b7e45c8dc4391ebd8b24c">SetWorldScale</a> (double _scale)=0</td></tr>
<tr class="memdesc:aa77c8cb7b56b7e45c8dc4391ebd8b24c inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the world scale. The given scale will be assigned to the x, y, and z coordinates.  <br /></td></tr>
<tr class="separator:aa77c8cb7b56b7e45c8dc4391ebd8b24c inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655bb42fbe65e12ab900b2f381a6c5d4 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a655bb42fbe65e12ab900b2f381a6c5d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a655bb42fbe65e12ab900b2f381a6c5d4">SetWorldScale</a> (double _x, double _y, double _z)=0</td></tr>
<tr class="memdesc:a655bb42fbe65e12ab900b2f381a6c5d4 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the world scale.  <br /></td></tr>
<tr class="separator:a655bb42fbe65e12ab900b2f381a6c5d4 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff920b7ce5593a0cd7b086e039879651 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_aff920b7ce5593a0cd7b086e039879651"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a7d2ef54f60c0f073a8aab8f9568bfc4e">Variant</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#aff920b7ce5593a0cd7b086e039879651">UserData</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_key) const =0</td></tr>
<tr class="memdesc:aff920b7ce5593a0cd7b086e039879651 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get custom data stored in this node.  <br /></td></tr>
<tr class="separator:aff920b7ce5593a0cd7b086e039879651 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf74beec53d15594d8db805ad30d9a8 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_afdf74beec53d15594d8db805ad30d9a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a507d73d4a494a03691fb87691dd07215">math::Pose3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#afdf74beec53d15594d8db805ad30d9a8">WorldPose</a> () const =0</td></tr>
<tr class="memdesc:afdf74beec53d15594d8db805ad30d9a8 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the world pose.  <br /></td></tr>
<tr class="separator:afdf74beec53d15594d8db805ad30d9a8 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf8de5f0b46ccc8f53ee82c4ff0c503 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_aadf8de5f0b46ccc8f53ee82c4ff0c503"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#aadf8de5f0b46ccc8f53ee82c4ff0c503">WorldPosition</a> () const =0</td></tr>
<tr class="memdesc:aadf8de5f0b46ccc8f53ee82c4ff0c503 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the world position.  <br /></td></tr>
<tr class="separator:aadf8de5f0b46ccc8f53ee82c4ff0c503 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd110cb66fa2433256f3acaaa4f740f inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_addd110cb66fa2433256f3acaaa4f740f"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a0d2bd45f1215359f8e7c0d7ab53c4acb">math::Quaterniond</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#addd110cb66fa2433256f3acaaa4f740f">WorldRotation</a> () const =0</td></tr>
<tr class="memdesc:addd110cb66fa2433256f3acaaa4f740f inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the world rotation.  <br /></td></tr>
<tr class="separator:addd110cb66fa2433256f3acaaa4f740f inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf6fe81250f5070e287fddb381de180 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_accf6fe81250f5070e287fddb381de180"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#accf6fe81250f5070e287fddb381de180">WorldScale</a> () const =0</td></tr>
<tr class="memdesc:accf6fe81250f5070e287fddb381de180 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the world scale.  <br /></td></tr>
<tr class="separator:accf6fe81250f5070e287fddb381de180 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3d4b3fa8b112bf436153d96141d640 inherit pub_methods_classgz_1_1rendering_1_1Node" id="r_a8b3d4b3fa8b112bf436153d96141d640"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a507d73d4a494a03691fb87691dd07215">math::Pose3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Node.html#a8b3d4b3fa8b112bf436153d96141d640">WorldToLocal</a> (const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a507d73d4a494a03691fb87691dd07215">math::Pose3d</a> &amp;_pose) const =0</td></tr>
<tr class="memdesc:a8b3d4b3fa8b112bf436153d96141d640 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert given world pose to local pose.  <br /></td></tr>
<tr class="separator:a8b3d4b3fa8b112bf436153d96141d640 inherit pub_methods_classgz_1_1rendering_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgz_1_1rendering_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgz_1_1rendering_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgz_1_1rendering_1_1Object.html">Object</a></td></tr>
<tr class="memitem:ab5cc4f9ba1ea5c2f25bc4b1f0dac5dc5 inherit pub_methods_classgz_1_1rendering_1_1Object" id="r_ab5cc4f9ba1ea5c2f25bc4b1f0dac5dc5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Object.html#ab5cc4f9ba1ea5c2f25bc4b1f0dac5dc5">~Object</a> ()</td></tr>
<tr class="memdesc:ab5cc4f9ba1ea5c2f25bc4b1f0dac5dc5 inherit pub_methods_classgz_1_1rendering_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:ab5cc4f9ba1ea5c2f25bc4b1f0dac5dc5 inherit pub_methods_classgz_1_1rendering_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84693792fa8cba90b312c0b1caf53716 inherit pub_methods_classgz_1_1rendering_1_1Object" id="r_a84693792fa8cba90b312c0b1caf53716"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Object.html#a84693792fa8cba90b312c0b1caf53716">Destroy</a> ()=0</td></tr>
<tr class="memdesc:a84693792fa8cba90b312c0b1caf53716 inherit pub_methods_classgz_1_1rendering_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy any resources associated with this object. Invoking any other functions after destroying an object will result in undefined behavior.  <br /></td></tr>
<tr class="separator:a84693792fa8cba90b312c0b1caf53716 inherit pub_methods_classgz_1_1rendering_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af440fd9edb16553775262ac2c5fcd315 inherit pub_methods_classgz_1_1rendering_1_1Object" id="r_af440fd9edb16553775262ac2c5fcd315"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Object.html#af440fd9edb16553775262ac2c5fcd315">Id</a> () const =0</td></tr>
<tr class="memdesc:af440fd9edb16553775262ac2c5fcd315 inherit pub_methods_classgz_1_1rendering_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the object ID. This ID will be unique across all objects inside a given scene, but necessarily true for objects across different scenes.  <br /></td></tr>
<tr class="separator:af440fd9edb16553775262ac2c5fcd315 inherit pub_methods_classgz_1_1rendering_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ee001ce76c53aebb215a9f51653ab3 inherit pub_methods_classgz_1_1rendering_1_1Object" id="r_a70ee001ce76c53aebb215a9f51653ab3"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Object.html#a70ee001ce76c53aebb215a9f51653ab3">Name</a> () const =0</td></tr>
<tr class="memdesc:a70ee001ce76c53aebb215a9f51653ab3 inherit pub_methods_classgz_1_1rendering_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the object name. This name will be unique across all objects inside a given scene, but necessarily true for objects across different scenes.  <br /></td></tr>
<tr class="separator:a70ee001ce76c53aebb215a9f51653ab3 inherit pub_methods_classgz_1_1rendering_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7483c1d44b5981eacd31fe5ac8332e10 inherit pub_methods_classgz_1_1rendering_1_1Object" id="r_a7483c1d44b5981eacd31fe5ac8332e10"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a2567b6287d355cf0ba85de15e7ee8cf0">ScenePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Object.html#a7483c1d44b5981eacd31fe5ac8332e10">Scene</a> () const =0</td></tr>
<tr class="memdesc:a7483c1d44b5981eacd31fe5ac8332e10 inherit pub_methods_classgz_1_1rendering_1_1Object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a> that created this object.  <br /></td></tr>
<tr class="separator:a7483c1d44b5981eacd31fe5ac8332e10 inherit pub_methods_classgz_1_1rendering_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9c3239350774430bcd752ddaf64609ff" id="r_a9c3239350774430bcd752ddaf64609ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a9c3239350774430bcd752ddaf64609ff">BaseCamera</a> ()</td></tr>
<tr class="separator:a9c3239350774430bcd752ddaf64609ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb1005ac97d1d483ca2c4e326bf96bc" id="r_aadb1005ac97d1d483ca2c4e326bf96bc"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#aadb1005ac97d1d483ca2c4e326bf96bc">CreateImageBuffer</a> () const</td></tr>
<tr class="separator:aadb1005ac97d1d483ca2c4e326bf96bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48213ee05bac040fd467a59a5d34003" id="r_ab48213ee05bac040fd467a59a5d34003"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#ab48213ee05bac040fd467a59a5d34003">Load</a> () override</td></tr>
<tr class="separator:ab48213ee05bac040fd467a59a5d34003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a683a9a4243b5c4229a859204b39e2b" id="r_a8a683a9a4243b5c4229a859204b39e2b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ab1aee4fc130215a7223fcd7bd709e8fb">RenderTargetPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a8a683a9a4243b5c4229a859204b39e2b">RenderTarget</a> () const =0</td></tr>
<tr class="separator:a8a683a9a4243b5c4229a859204b39e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372de693ad40b3f42839c8ec6ac845f4" id="r_a372de693ad40b3f42839c8ec6ac845f4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a372de693ad40b3f42839c8ec6ac845f4">Reset</a> ()</td></tr>
<tr class="separator:a372de693ad40b3f42839c8ec6ac845f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a12014c8d719a0f35240288e9d4de3186" id="r_a12014c8d719a0f35240288e9d4de3186"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a12014c8d719a0f35240288e9d4de3186">antiAliasing</a> = 0u</td></tr>
<tr class="memdesc:a12014c8d719a0f35240288e9d4de3186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anti-aliasing.  <br /></td></tr>
<tr class="separator:a12014c8d719a0f35240288e9d4de3186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11926af9280d70fd96e47b07c90cf0ed" id="r_a11926af9280d70fd96e47b07c90cf0ed"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a11926af9280d70fd96e47b07c90cf0ed">aspect</a> = 1.3333333</td></tr>
<tr class="memdesc:a11926af9280d70fd96e47b07c90cf0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aspect ratio.  <br /></td></tr>
<tr class="separator:a11926af9280d70fd96e47b07c90cf0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea313f8008d3098e559c391e862715d" id="r_a2ea313f8008d3098e559c391e862715d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a2ea313f8008d3098e559c391e862715d">farClip</a> = 1000.0</td></tr>
<tr class="memdesc:a2ea313f8008d3098e559c391e862715d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Far clipping plane distance.  <br /></td></tr>
<tr class="separator:a2ea313f8008d3098e559c391e862715d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa5ce4b27490ef3cb76c5f4de52bea2" id="r_a3aa5ce4b27490ef3cb76c5f4de52bea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a3aa5ce4b27490ef3cb76c5f4de52bea2">followNode</a></td></tr>
<tr class="memdesc:a3aa5ce4b27490ef3cb76c5f4de52bea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target node to follow.  <br /></td></tr>
<tr class="separator:a3aa5ce4b27490ef3cb76c5f4de52bea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac55b67805d416a519d69a740b5b8099" id="r_aac55b67805d416a519d69a740b5b8099"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#aac55b67805d416a519d69a740b5b8099">followOffset</a></td></tr>
<tr class="memdesc:aac55b67805d416a519d69a740b5b8099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset distance between camera and target node being followed.  <br /></td></tr>
<tr class="separator:aac55b67805d416a519d69a740b5b8099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84242208ed583431c2732f1c7a675c05" id="r_a84242208ed583431c2732f1c7a675c05"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a84242208ed583431c2732f1c7a675c05">followPGain</a> = 1.0</td></tr>
<tr class="memdesc:a84242208ed583431c2732f1c7a675c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">P gain for follow mode. Determines how fast the camera moves to follow the target node. Valid range: [0-1].  <br /></td></tr>
<tr class="separator:a84242208ed583431c2732f1c7a675c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53b9c1dd232b7371177b234dddad72b" id="r_ac53b9c1dd232b7371177b234dddad72b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#ac53b9c1dd232b7371177b234dddad72b">followWorldFrame</a> = false</td></tr>
<tr class="memdesc:ac53b9c1dd232b7371177b234dddad72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Follow target in world frame.  <br /></td></tr>
<tr class="separator:ac53b9c1dd232b7371177b234dddad72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739154d13ff6ba3b279f53961e83735b" id="r_a739154d13ff6ba3b279f53961e83735b"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Angle.html">math::Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a739154d13ff6ba3b279f53961e83735b">hfov</a></td></tr>
<tr class="memdesc:a739154d13ff6ba3b279f53961e83735b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontal camera field of view.  <br /></td></tr>
<tr class="separator:a739154d13ff6ba3b279f53961e83735b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27e8673b86c6bc0175c65dc774f970c" id="r_af27e8673b86c6bc0175c65dc774f970c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1rendering.html#a04be7d792dc3459f903c3c360de0bef9">ImagePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#af27e8673b86c6bc0175c65dc774f970c">imageBuffer</a></td></tr>
<tr class="separator:af27e8673b86c6bc0175c65dc774f970c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac794dd46a5e3d003899228120870fc9f" id="r_ac794dd46a5e3d003899228120870fc9f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#ac794dd46a5e3d003899228120870fc9f">nearClip</a> = 0.01</td></tr>
<tr class="memdesc:ac794dd46a5e3d003899228120870fc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Near clipping plane distance.  <br /></td></tr>
<tr class="separator:ac794dd46a5e3d003899228120870fc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d6bf301fa6e7d7ac30e2b0f25f9112" id="r_a40d6bf301fa6e7d7ac30e2b0f25f9112"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://gazebosim.org/api/common/6/classgz_1_1common_1_1EventT.html">common::EventT</a>&lt; void(const void *, unsigned int, unsigned int, unsigned int, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a40d6bf301fa6e7d7ac30e2b0f25f9112">newFrameEvent</a></td></tr>
<tr class="separator:a40d6bf301fa6e7d7ac30e2b0f25f9112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e404e759ecb2d6bdbb6c13860414679" id="r_a1e404e759ecb2d6bdbb6c13860414679"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#afe7ea008ee9e656fb34621264a42e04a">math::Matrix4d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a1e404e759ecb2d6bdbb6c13860414679">projectionMatrix</a></td></tr>
<tr class="memdesc:a1e404e759ecb2d6bdbb6c13860414679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom projection matrix.  <br /></td></tr>
<tr class="separator:a1e404e759ecb2d6bdbb6c13860414679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb258d5d212df8ac3db0173600475dd8" id="r_afb258d5d212df8ac3db0173600475dd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1rendering.html#a07f284387dda2cd2d77f2b7a027f501f">CameraProjectionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#afb258d5d212df8ac3db0173600475dd8">projectionType</a> = <a class="el" href="namespacegz_1_1rendering.html#a07f284387dda2cd2d77f2b7a027f501fa33a438a24012e33e488b38a4a1794864">CPT_PERSPECTIVE</a></td></tr>
<tr class="memdesc:afb258d5d212df8ac3db0173600475dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgz_1_1rendering_1_1Camera.html" title="Posable camera used for rendering the scene graph.">Camera</a> projection type.  <br /></td></tr>
<tr class="separator:afb258d5d212df8ac3db0173600475dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6bda239c5675d1e84c5b9a34a51457" id="r_a0e6bda239c5675d1e84c5b9a34a51457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a0e6bda239c5675d1e84c5b9a34a51457">trackNode</a></td></tr>
<tr class="memdesc:a0e6bda239c5675d1e84c5b9a34a51457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target node to track if camera tracking is on.  <br /></td></tr>
<tr class="separator:a0e6bda239c5675d1e84c5b9a34a51457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3ba25d12f56c1fdb01d58c384576fd" id="r_acb3ba25d12f56c1fdb01d58c384576fd"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#acb3ba25d12f56c1fdb01d58c384576fd">trackOffset</a></td></tr>
<tr class="memdesc:acb3ba25d12f56c1fdb01d58c384576fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set camera to track a point offset in target node's local or world frame depending on trackWorldFrame.  <br /></td></tr>
<tr class="separator:acb3ba25d12f56c1fdb01d58c384576fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1051d1593f812a4fa3991bd5c2d95d" id="r_aad1051d1593f812a4fa3991bd5c2d95d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#aad1051d1593f812a4fa3991bd5c2d95d">trackPGain</a> = 1.0</td></tr>
<tr class="memdesc:aad1051d1593f812a4fa3991bd5c2d95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">P gain for tracking. Determines how fast the camera rotates to look at the target node. Valid range: [0-1].  <br /></td></tr>
<tr class="separator:aad1051d1593f812a4fa3991bd5c2d95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5416d1099a0f51312b7acd2da25f73" id="r_a9a5416d1099a0f51312b7acd2da25f73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a9a5416d1099a0f51312b7acd2da25f73">trackWorldFrame</a> = false</td></tr>
<tr class="memdesc:a9a5416d1099a0f51312b7acd2da25f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track point relative to target in world frame.  <br /></td></tr>
<tr class="separator:a9a5416d1099a0f51312b7acd2da25f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classgz_1_1rendering_1_1Camera"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classgz_1_1rendering_1_1Camera')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classgz_1_1rendering_1_1Camera.html">Camera</a></td></tr>
<tr class="memitem:aa3161319199b5f9f5f4b2058dcb487cf inherit pub_types_classgz_1_1rendering_1_1Camera" id="r_aa3161319199b5f9f5f4b2058dcb487cf"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; void(const void *, unsigned int, unsigned int, unsigned int, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Camera.html#aa3161319199b5f9f5f4b2058dcb487cf">NewFrameListener</a></td></tr>
<tr class="memdesc:aa3161319199b5f9f5f4b2058dcb487cf inherit pub_types_classgz_1_1rendering_1_1Camera"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for new frame render event listeners.  <br /></td></tr>
<tr class="separator:aa3161319199b5f9f5f4b2058dcb487cf inherit pub_types_classgz_1_1rendering_1_1Camera"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9c3239350774430bcd752ddaf64609ff" name="a9c3239350774430bcd752ddaf64609ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3239350774430bcd752ddaf64609ff">&#9670;&#160;</a></span>BaseCamera()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html">BaseCamera</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4e6d729ee4a4b156adad7e9c9e729c8" name="ab4e6d729ee4a4b156adad7e9c9e729c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e6d729ee4a4b156adad7e9c9e729c8">&#9670;&#160;</a></span>~BaseCamera()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classgz_1_1rendering_1_1BaseCamera.html">BaseCamera</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0ebbac9e838781b4640c1e130d072820" name="a0ebbac9e838781b4640c1e130d072820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebbac9e838781b4640c1e130d072820">&#9670;&#160;</a></span>AddRenderPass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddRenderPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1rendering.html#ab078521fc0f74a5a382055db45c0f654">RenderPassPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>_pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a render pass to the camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pass</td><td>New render pass to add </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a3dc7e9c26a8c567dae0ad48f54ce9a59">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreWideAngleCamera.html#a0ebbac9e838781b4640c1e130d072820">OgreWideAngleCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2DepthCamera.html#a0ebbac9e838781b4640c1e130d072820">Ogre2DepthCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2WideAngleCamera.html#a0ebbac9e838781b4640c1e130d072820">Ogre2WideAngleCamera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html#a3dc7e9c26a8c567dae0ad48f54ce9a59">RenderTarget::AddRenderPass()</a>.</p>

</div>
</div>
<a id="a109e8eee67f1772565b1b773ee2e9688" name="a109e8eee67f1772565b1b773ee2e9688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109e8eee67f1772565b1b773ee2e9688">&#9670;&#160;</a></span>AntiAliasing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int AntiAliasing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the level of anti-aliasing used during rendering. </p>
<dl class="section return"><dt>Returns</dt><dd>The level of anti-aliasing used during rendering </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#ae13f9c0b5b5807ef77903850477f2d97">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#a03216fe31b86256e89d37a79a683d874">OgreCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#a03216fe31b86256e89d37a79a683d874">Ogre2Camera</a>.</p>

</div>
</div>
<a id="a1255808f1dc32d4f31fd06814cbd0593" name="a1255808f1dc32d4f31fd06814cbd0593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1255808f1dc32d4f31fd06814cbd0593">&#9670;&#160;</a></span>AspectRatio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double AspectRatio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the camera's aspect ratio. </p>
<dl class="section remark"><dt>Remarks</dt><dd>If <a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a2f9714b680f706268287b316b41d1ec4" title="Set the camera&#39;s aspect ratio. This value determines the cameras vertical field-of-view....">SetAspectRatio()</a> gets called with an input &lt;= 0 this function returns the Aspect Ratio autocalculated based on the camera's dimensions. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The camera's aspect ratio. This value is always in range (0; inf) unless the dimensions are invalid (e.g. 0 width or height, NaN resolution, etc) </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#af39b834118a401f30efcb394d338c3a8">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#a555284d5ac9adb753f5e27cb4d644f06">OgreCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#a555284d5ac9adb753f5e27cb4d644f06">Ogre2Camera</a>.</p>

</div>
</div>
<a id="a402b22114f496f3badf07897c1bf6ff3" name="a402b22114f496f3badf07897c1bf6ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402b22114f496f3badf07897c1bf6ff3">&#9670;&#160;</a></span>Capture()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Capture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgz_1_1rendering_1_1Image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>_image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a new frame and writes the results to the given image. This is a convenience function for single-camera scenes. It wraps the pre-render, render, post-render, and get-image calls into a single function. This should NOT be used in applications with multiple cameras or multiple consumers of a single camera's images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_image</td><td>Output image buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a722b50a5de7593020b2ba35cabbe113f">Camera</a>.</p>

</div>
</div>
<a id="aba15e50318eb987ada33c0a1989eabb3" name="aba15e50318eb987ada33c0a1989eabb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba15e50318eb987ada33c0a1989eabb3">&#9670;&#160;</a></span>ConnectNewImageFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gazebosim.org/api/common/6/namespacegz_1_1common.html#a34ef659755e21515b805c0120eb9187b">common::ConnectionPtr</a> ConnectNewImageFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgz_1_1rendering_1_1Camera.html#aa3161319199b5f9f5f4b2058dcb487cf">Camera::NewFrameListener</a>&#160;</td>
          <td class="paramname"><em>_listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribes a new listener to this camera's new frame event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_listener</td><td>New camera listener callback </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#acdff5960c39c7a591f27245329ad37bb">Camera</a>.</p>

</div>
</div>
<a id="a17b9b63514c27c8e4fd4333e8483719f" name="a17b9b63514c27c8e4fd4333e8483719f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b9b63514c27c8e4fd4333e8483719f">&#9670;&#160;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgz_1_1rendering_1_1Image.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>_image</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the last rendered image to the given image buffer. This function can be called multiple times after PostRender has been called, without rendering the scene again. Calling this function before a single image has been rendered will have undefined behavior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_image</td><td>Output image buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#ac2c0db89ad2896ca461e6ae88db387c9">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreWideAngleCamera.html#a17b9b63514c27c8e4fd4333e8483719f">OgreWideAngleCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2WideAngleCamera.html#a17b9b63514c27c8e4fd4333e8483719f">Ogre2WideAngleCamera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html#ac2c0db89ad2896ca461e6ae88db387c9">RenderTarget::Copy()</a>.</p>

</div>
</div>
<a id="ae1fe1c6999acf09b6d1af438cd5a7ba9" name="ae1fe1c6999acf09b6d1af438cd5a7ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fe1c6999acf09b6d1af438cd5a7ba9">&#9670;&#160;</a></span>CreateImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1rendering_1_1Image.html">Image</a> CreateImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Created an empty image buffer for capturing images. The resulting image will have sufficient memory allocated for subsequent calls to this camera's Capture function. However, any changes to this cameras properties may invalidate the condition. </p>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated <a class="el" href="classgz_1_1rendering_1_1Image.html" title="Encapsulates a raw image buffer and relevant properties.">Image</a> for storing this cameras images </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a9ca742cb4bcad4bc374f837aa8516ecb">Camera</a>.</p>

</div>
</div>
<a id="aadb1005ac97d1d483ca2c4e326bf96bc" name="aadb1005ac97d1d483ca2c4e326bf96bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb1005ac97d1d483ca2c4e326bf96bc">&#9670;&#160;</a></span>CreateImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * CreateImageBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbea568ef2df6575ae3c5602b2862bc1" name="adbea568ef2df6575ae3c5602b2862bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbea568ef2df6575ae3c5602b2862bc1">&#9670;&#160;</a></span>CreateRenderWindow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1rendering.html#ac06da5e129043c70d45b66d453b2e092">RenderWindowPtr</a> CreateRenderWindow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a render window. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the render window. </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a2a68cb11799ca99655190e4f5a665a47">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#a3d8414bb24d949a98ab3fe4c324c42b8">OgreCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#a3d8414bb24d949a98ab3fe4c324c42b8">Ogre2Camera</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl()</a>, <a class="el" href="classgz_1_1rendering_1_1Scene.html#ab75ed7ecb68e56334408a2b94e95b85d">Scene::Engine()</a>, <a class="elRef" href="https://gazebosim.org/api/common/6/Console_8hh.html#acf18c83e7419e002351f1eeceb6c2cf4">gzerr</a>, and <a class="el" href="classgz_1_1rendering_1_1RenderEngine.html#a70ee001ce76c53aebb215a9f51653ab3">RenderEngine::Name()</a>.</p>

</div>
</div>
<a id="a1a8b46e1f44be9b09aa8af96a5bb8efd" name="a1a8b46e1f44be9b09aa8af96a5bb8efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8b46e1f44be9b09aa8af96a5bb8efd">&#9670;&#160;</a></span>FarClipPlane()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double FarClipPlane </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the camera's far clipping plane distance. </p>
<dl class="section return"><dt>Returns</dt><dd>Far clipping plane distance </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a147c8a4a423087305bf9078d3d25fe5d">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreDepthCamera.html#a1a8b46e1f44be9b09aa8af96a5bb8efd">OgreDepthCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2DepthCamera.html#a1a8b46e1f44be9b09aa8af96a5bb8efd">Ogre2DepthCamera</a>.</p>

</div>
</div>
<a id="a3f349188c849be10e5beaa52d7bc8342" name="a3f349188c849be10e5beaa52d7bc8342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f349188c849be10e5beaa52d7bc8342">&#9670;&#160;</a></span>FollowOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> FollowOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the follow offset vector in the frame specified at the time the follow target is set. </p>
<dl class="section return"><dt>Returns</dt><dd>Offset of camera from target. </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a77e592cf3107418c2bb664d68d7fca89">Camera</a>.</p>

</div>
</div>
<a id="a2ce5852924bb998faed58c5a02ee343d" name="a2ce5852924bb998faed58c5a02ee343d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce5852924bb998faed58c5a02ee343d">&#9670;&#160;</a></span>FollowPGain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double FollowPGain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the camera follow movement P gain. </p>
<dl class="section return"><dt>Returns</dt><dd>P gain for camera following </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a6aae55a02b0fa2e4163d36200a38d5ba">Camera</a>.</p>

</div>
</div>
<a id="a129f9a734d9cca80d7348fac5450b9ef" name="a129f9a734d9cca80d7348fac5450b9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129f9a734d9cca80d7348fac5450b9ef">&#9670;&#160;</a></span>FollowTarget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> FollowTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the target node being followed. </p>
<dl class="section return"><dt>Returns</dt><dd>Target node being tracked. </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#ae61720acb36e9a193823f235d7d2cfd9">Camera</a>.</p>

</div>
</div>
<a id="a08c1805eaf8a9b547b0a58b680f5470d" name="a08c1805eaf8a9b547b0a58b680f5470d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c1805eaf8a9b547b0a58b680f5470d">&#9670;&#160;</a></span>HFOV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Angle.html">math::Angle</a> HFOV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the camera's horizontal field-of-view. </p>
<dl class="section return"><dt>Returns</dt><dd>Angle containing the camera's horizontal field-of-view </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a1472dbc26d6d9a367a59cac5344ee7ac">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#a4e940486b4c4515165649530e851e0a3">OgreCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#a4e940486b4c4515165649530e851e0a3">Ogre2Camera</a>.</p>

</div>
</div>
<a id="a3f79e57fffb74326ce603ab3e83c1f17" name="a3f79e57fffb74326ce603ab3e83c1f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f79e57fffb74326ce603ab3e83c1f17">&#9670;&#160;</a></span>ImageFormat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1rendering.html#a60883d4958a60b91661e97027a85072a">PixelFormat</a> ImageFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the image pixel format. If the image pixel format has not been set with a valid value, PF_UNKNOWN will be returned. </p>
<dl class="section return"><dt>Returns</dt><dd>The image pixel format </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a18c8905e32c8271c53eb511c6bca0ea4">Camera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html#af62a13e7baaca765e26600b1a9aa594a">RenderTarget::Format()</a>.</p>

</div>
</div>
<a id="ae09f6f353e640905a29e60ab02bd068a" name="ae09f6f353e640905a29e60ab02bd068a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09f6f353e640905a29e60ab02bd068a">&#9670;&#160;</a></span>ImageHeight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ImageHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the image height in pixels. </p>
<dl class="section return"><dt>Returns</dt><dd>The image height in pixels </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#af7efc842f6c43f1687ce76ea63ecd29b">Camera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html#aad592b314fa03fe204d3b2bbdd097db6">RenderTarget::Height()</a>.</p>

</div>
</div>
<a id="add6199a9e74f9a3c8081649ad6969fdd" name="add6199a9e74f9a3c8081649ad6969fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6199a9e74f9a3c8081649ad6969fdd">&#9670;&#160;</a></span>ImageMemorySize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ImageMemorySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total image memory size in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>The image memory size in bytes </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#ac9eea817c91494265c47a07e63bd6a0d">Camera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1PixelUtil.html#a765e2618372637300346aabe5ae0ea1a">PixelUtil::MemorySize()</a>.</p>

</div>
</div>
<a id="a0d273c9c48bdfb72b60483c52d312c11" name="a0d273c9c48bdfb72b60483c52d312c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d273c9c48bdfb72b60483c52d312c11">&#9670;&#160;</a></span>ImageWidth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ImageWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the image width in pixels. </p>
<dl class="section return"><dt>Returns</dt><dd>The image width in pixels </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a015112b25d5abb9c3ca8f6fa579c1d5e">Camera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html#aeea37c491658649b3aa909fa96ce2c75">RenderTarget::Width()</a>.</p>

</div>
</div>
<a id="ab48213ee05bac040fd467a59a5d34003" name="ab48213ee05bac040fd467a59a5d34003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48213ee05bac040fd467a59a5d34003">&#9670;&#160;</a></span>Load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Load </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cc83c9c632e4f69fcde38be3f19a532" name="a5cc83c9c632e4f69fcde38be3f19a532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc83c9c632e4f69fcde38be3f19a532">&#9670;&#160;</a></span>NearClipPlane()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double NearClipPlane </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the camera's near clipping plane distance. </p>
<dl class="section return"><dt>Returns</dt><dd>Near clipping plane distance </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a10282c0ef9fc02889712704f3120263f">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreDepthCamera.html#a5cc83c9c632e4f69fcde38be3f19a532">OgreDepthCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2DepthCamera.html#a5cc83c9c632e4f69fcde38be3f19a532">Ogre2DepthCamera</a>.</p>

</div>
</div>
<a id="ad4c7af6b36e2b91213c6f3afaeceb879" name="ad4c7af6b36e2b91213c6f3afaeceb879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c7af6b36e2b91213c6f3afaeceb879">&#9670;&#160;</a></span>PostRender()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PostRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preforms any necessary final rendering work. Once rendering is complete the camera will alert any listeners of the new frame event. This function should only be called after a call to Render has successfully been executed. </p>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#aee73a4d9fd3bca2a941038e4a5a3879d">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreDepthCamera.html#a6e5e77e1b8398bffc2d36a2ab1338b05">OgreDepthCamera</a>, <a class="el" href="classgz_1_1rendering_1_1OgreGpuRays.html#a6e5e77e1b8398bffc2d36a2ab1338b05">OgreGpuRays</a>, <a class="el" href="classgz_1_1rendering_1_1OgreThermalCamera.html#a6e5e77e1b8398bffc2d36a2ab1338b05">OgreThermalCamera</a>, <a class="el" href="classgz_1_1rendering_1_1OgreWideAngleCamera.html#a6e5e77e1b8398bffc2d36a2ab1338b05">OgreWideAngleCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2BoundingBoxCamera.html#a6e5e77e1b8398bffc2d36a2ab1338b05">Ogre2BoundingBoxCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2DepthCamera.html#a6e5e77e1b8398bffc2d36a2ab1338b05">Ogre2DepthCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2GpuRays.html#a6e5e77e1b8398bffc2d36a2ab1338b05">Ogre2GpuRays</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2SegmentationCamera.html#a6e5e77e1b8398bffc2d36a2ab1338b05">Ogre2SegmentationCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2ThermalCamera.html#a6e5e77e1b8398bffc2d36a2ab1338b05">Ogre2ThermalCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2WideAngleCamera.html#a6e5e77e1b8398bffc2d36a2ab1338b05">Ogre2WideAngleCamera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1Object.html#aee73a4d9fd3bca2a941038e4a5a3879d">Object::PostRender()</a>.</p>

</div>
</div>
<a id="a0fa744c860a54d7fbd18ee0ff5e44cd1" name="a0fa744c860a54d7fbd18ee0ff5e44cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa744c860a54d7fbd18ee0ff5e44cd1">&#9670;&#160;</a></span>PrepareForExternalSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PrepareForExternalSampling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right now this is Vulkan-only. This function needs to be called after rendering, and before handling the texture pointer (i.e. by calling <a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a9fc55ab4c05c3d5a303533db96fdd6c2" title="Get the Metal texture id associated with the render texture used by this camera. A valid Id is obtain...">RenderTextureMetalId()</a>) so that external APIs (e.g. Qt) can sample the texture. </p>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a202c48e1d6e13c9b06c711a0f7c160d4">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#a54def2aae9c0d1765f2155f19aba08cc">Ogre2Camera</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl()</a>, and <a class="elRef" href="https://gazebosim.org/api/common/6/Console_8hh.html#acf18c83e7419e002351f1eeceb6c2cf4">gzerr</a>.</p>

</div>
</div>
<a id="a2a062fe0fd3c5f4d771563834e4be9c6" name="a2a062fe0fd3c5f4d771563834e4be9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a062fe0fd3c5f4d771563834e4be9c6">&#9670;&#160;</a></span>PreRender()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PreRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare this object and any of its children for rendering. This should be called for each object in a scene just before rendering, which can be achieved by a single call to <a class="el" href="classgz_1_1rendering_1_1Scene.html#adffb56e0e545fefebf96b36f295396e9" title="Prepare scene for rendering. The scene will flushing any scene changes by traversing scene-graph,...">Scene::PreRender</a>. </p>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Object.html#adffb56e0e545fefebf96b36f295396e9">Object</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreDepthCamera.html#a5328dbcc9da499b4c61a412746672f39">OgreDepthCamera</a>, <a class="el" href="classgz_1_1rendering_1_1OgreGpuRays.html#a5328dbcc9da499b4c61a412746672f39">OgreGpuRays</a>, <a class="el" href="classgz_1_1rendering_1_1OgreThermalCamera.html#a5328dbcc9da499b4c61a412746672f39">OgreThermalCamera</a>, <a class="el" href="classgz_1_1rendering_1_1OgreWideAngleCamera.html#a5328dbcc9da499b4c61a412746672f39">OgreWideAngleCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2BoundingBoxCamera.html#a5328dbcc9da499b4c61a412746672f39">Ogre2BoundingBoxCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2DepthCamera.html#a5328dbcc9da499b4c61a412746672f39">Ogre2DepthCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2GpuRays.html#a5328dbcc9da499b4c61a412746672f39">Ogre2GpuRays</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2SegmentationCamera.html#a5328dbcc9da499b4c61a412746672f39">Ogre2SegmentationCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2ThermalCamera.html#a5328dbcc9da499b4c61a412746672f39">Ogre2ThermalCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2WideAngleCamera.html#a5328dbcc9da499b4c61a412746672f39">Ogre2WideAngleCamera</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast.html">std::dynamic_pointer_cast()</a>, <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a6480827e411f4a8c72137e6b285f9e05">gz::math::equal()</a>, <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Quaternion.html#a82f762f7f66c5c70b571fd3ea5cb63fe">Quaternion&lt; typename T &gt;::Identity</a>, <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Matrix4.html#a17be31d0fe3947aad86b18271ab40191">Matrix4&lt; typename T &gt;::LookAt()</a>, <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Pose3.html#ac487fd30878108daf61304b85243177c">Pose3&lt; typename T &gt;::Pos()</a>, <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html#a19023ed55bc58a3618e641dec808c213">RenderTarget::PreRender()</a>, <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Pose3.html#a21cf48c5b64a583734e9af7b886c3c75">Pose3&lt; typename T &gt;::Rot()</a>, and <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Quaternion.html#aaf888a69c1167128ca5734c4c08a28e3">Quaternion&lt; typename T &gt;::Slerp()</a>.</p>

</div>
</div>
<a id="a640d527387b05edae7c3118773c1904b" name="a640d527387b05edae7c3118773c1904b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640d527387b05edae7c3118773c1904b">&#9670;&#160;</a></span>Project()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#aa83d444bd6cbecb112158663c2e0c213">math::Vector2i</a> Project </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>_pt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project point in 3d world space to 2d screen space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pt</td><td>Point in 3d world space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Point in 2d screen space </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a6a0f1851d6fa71e67fd9e00c1e178216">Camera</a>.</p>

<p class="reference">References <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector2.html#adf0759dc95ad2409e26a04c456059b96">Vector2&lt; typename T &gt;::X()</a>, <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector3.html#adf0759dc95ad2409e26a04c456059b96">Vector3&lt; typename T &gt;::X()</a>, <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector2.html#a11ab7878747c03b64c70de6acf55f839">Vector2&lt; typename T &gt;::Y()</a>, <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector3.html#a11ab7878747c03b64c70de6acf55f839">Vector3&lt; typename T &gt;::Y()</a>, and <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector3.html#a46624762afa9ad876ce4e71bc07e9fd0">Vector3&lt; typename T &gt;::Z()</a>.</p>

</div>
</div>
<a id="af820fa11e3bcc8255a6e2aa127a1c8e0" name="af820fa11e3bcc8255a6e2aa127a1c8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af820fa11e3bcc8255a6e2aa127a1c8e0">&#9670;&#160;</a></span>ProjectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#afe7ea008ee9e656fb34621264a42e04a">math::Matrix4d</a> ProjectionMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the projection matrix for this camera. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgz_1_1rendering_1_1Camera.html" title="Posable camera used for rendering the scene graph.">Camera</a> projection matrix </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#ad3c843e108e9ada2fc38761b8f7a02d2">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#af927219a459a98bf0cf9cb0417245d8c">OgreCamera</a>, <a class="el" href="classgz_1_1rendering_1_1OgreDepthCamera.html#af927219a459a98bf0cf9cb0417245d8c">OgreDepthCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2BoundingBoxCamera.html#af927219a459a98bf0cf9cb0417245d8c">Ogre2BoundingBoxCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#af927219a459a98bf0cf9cb0417245d8c">Ogre2Camera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2DepthCamera.html#af927219a459a98bf0cf9cb0417245d8c">Ogre2DepthCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2SegmentationCamera.html#af927219a459a98bf0cf9cb0417245d8c">Ogre2SegmentationCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2ThermalCamera.html#af927219a459a98bf0cf9cb0417245d8c">Ogre2ThermalCamera</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/math/atan.html">std::atan()</a>, <a class="el" href="namespacegz_1_1rendering.html#a07f284387dda2cd2d77f2b7a027f501fa85f303a7317c24f19b366b27c0998846">gz::rendering::CPT_ORTHOGRAPHIC</a>, <a class="el" href="namespacegz_1_1rendering.html#a07f284387dda2cd2d77f2b7a027f501fa33a438a24012e33e488b38a4a1794864">gz::rendering::CPT_PERSPECTIVE</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl()</a>, <a class="elRef" href="https://gazebosim.org/api/common/6/Console_8hh.html#acf18c83e7419e002351f1eeceb6c2cf4">gzerr</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/math/tan.html">std::tan()</a>.</p>

</div>
</div>
<a id="a42d40fdf2f3d13d1dc78755512d2883d" name="a42d40fdf2f3d13d1dc78755512d2883d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d40fdf2f3d13d1dc78755512d2883d">&#9670;&#160;</a></span>ProjectionType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1rendering.html#a07f284387dda2cd2d77f2b7a027f501f">CameraProjectionType</a> ProjectionType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the projection type for this camera. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgz_1_1rendering_1_1Camera.html" title="Posable camera used for rendering the scene graph.">Camera</a> projection type </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#af7c60fc0c599340c1753bebbfe39800c">Camera</a>.</p>

</div>
</div>
<a id="a9bf794d6828c5096b06b32a47f78145e" name="a9bf794d6828c5096b06b32a47f78145e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf794d6828c5096b06b32a47f78145e">&#9670;&#160;</a></span>RemoveAllRenderPasses()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RemoveAllRenderPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all render passes from the camera. </p>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a4efc4b40472c22d504baf7b2c206d75f">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreWideAngleCamera.html#a9bf794d6828c5096b06b32a47f78145e">OgreWideAngleCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2WideAngleCamera.html#a9bf794d6828c5096b06b32a47f78145e">Ogre2WideAngleCamera</a>.</p>

</div>
</div>
<a id="a01c970396c0167521d5ac5c298448214" name="a01c970396c0167521d5ac5c298448214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c970396c0167521d5ac5c298448214">&#9670;&#160;</a></span>RemoveRenderPass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RemoveRenderPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1rendering.html#ab078521fc0f74a5a382055db45c0f654">RenderPassPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>_pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a render pass from the camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pass</td><td>render pass to remove </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a2e348e9500b0b9cf9605fd3209474915">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreWideAngleCamera.html#a01c970396c0167521d5ac5c298448214">OgreWideAngleCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2WideAngleCamera.html#a01c970396c0167521d5ac5c298448214">Ogre2WideAngleCamera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html#a2e348e9500b0b9cf9605fd3209474915">RenderTarget::RemoveRenderPass()</a>.</p>

</div>
</div>
<a id="a8964f08b05c37cb9e2384d7ab823394f" name="a8964f08b05c37cb9e2384d7ab823394f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8964f08b05c37cb9e2384d7ab823394f">&#9670;&#160;</a></span>RenderPassByIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1rendering.html#ab078521fc0f74a5a382055db45c0f654">RenderPassPtr</a> RenderPassByIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a render passes by index. </p>
<dl class="section return"><dt>Returns</dt><dd>Render pass at the specified index </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a355e236f8e92fc46d9a28305d2523332">Camera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html#a355e236f8e92fc46d9a28305d2523332">RenderTarget::RenderPassByIndex()</a>.</p>

</div>
</div>
<a id="a0d637fb2326106c54a11097f40e1e7c5" name="a0d637fb2326106c54a11097f40e1e7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d637fb2326106c54a11097f40e1e7c5">&#9670;&#160;</a></span>RenderPassCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int RenderPassCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of render passes applied to the camera. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of render passes applied </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a645d4aad810809e65c972d7353118eca">Camera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html#a645d4aad810809e65c972d7353118eca">RenderTarget::RenderPassCount()</a>.</p>

</div>
</div>
<a id="a8a683a9a4243b5c4229a859204b39e2b" name="a8a683a9a4243b5c4229a859204b39e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a683a9a4243b5c4229a859204b39e2b">&#9670;&#160;</a></span>RenderTarget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ab1aee4fc130215a7223fcd7bd709e8fb">RenderTargetPtr</a> <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html">RenderTarget</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#a222e33a401ff1a9ba681f831b60e3a0e">OgreCamera</a>, <a class="el" href="classgz_1_1rendering_1_1OgreDepthCamera.html#a222e33a401ff1a9ba681f831b60e3a0e">OgreDepthCamera</a>, <a class="el" href="classgz_1_1rendering_1_1OgreGpuRays.html#a222e33a401ff1a9ba681f831b60e3a0e">OgreGpuRays</a>, <a class="el" href="classgz_1_1rendering_1_1OgreThermalCamera.html#a222e33a401ff1a9ba681f831b60e3a0e">OgreThermalCamera</a>, <a class="el" href="classgz_1_1rendering_1_1OgreWideAngleCamera.html#a222e33a401ff1a9ba681f831b60e3a0e">OgreWideAngleCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2BoundingBoxCamera.html#a222e33a401ff1a9ba681f831b60e3a0e">Ogre2BoundingBoxCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#a222e33a401ff1a9ba681f831b60e3a0e">Ogre2Camera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2DepthCamera.html#a222e33a401ff1a9ba681f831b60e3a0e">Ogre2DepthCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2GpuRays.html#a222e33a401ff1a9ba681f831b60e3a0e">Ogre2GpuRays</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2SegmentationCamera.html#a222e33a401ff1a9ba681f831b60e3a0e">Ogre2SegmentationCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2ThermalCamera.html#a222e33a401ff1a9ba681f831b60e3a0e">Ogre2ThermalCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2WideAngleCamera.html#a222e33a401ff1a9ba681f831b60e3a0e">Ogre2WideAngleCamera</a>, <a class="el" href="classgz_1_1rendering_1_1BaseGpuRays.html#a607d902672d214d85ed4a574ebce8ce2">BaseGpuRays&lt; T &gt;</a>, <a class="el" href="classgz_1_1rendering_1_1BaseGpuRays.html#a607d902672d214d85ed4a574ebce8ce2">BaseGpuRays&lt; Ogre2Sensor &gt;</a>, and <a class="el" href="classgz_1_1rendering_1_1BaseGpuRays.html#a607d902672d214d85ed4a574ebce8ce2">BaseGpuRays&lt; OgreSensor &gt;</a>.</p>

</div>
</div>
<a id="a50aad33d75ef7aebe750b8f811a96afc" name="a50aad33d75ef7aebe750b8f811a96afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50aad33d75ef7aebe750b8f811a96afc">&#9670;&#160;</a></span>RenderTextureGLId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int RenderTextureGLId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the OpenGL texture id associated with the render texture used by this camera. A valid id is returned only if the underlying render engine is OpenGL based. </p>
<dl class="section return"><dt>Returns</dt><dd>Texture Id of type GLuint. </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a8cfad6b18bb26e1a9ea6f400efdbc22f">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#aa32a861799872a862037c88e33b23b9b">OgreCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#aa32a861799872a862037c88e33b23b9b">Ogre2Camera</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl()</a>, and <a class="elRef" href="https://gazebosim.org/api/common/6/Console_8hh.html#acf18c83e7419e002351f1eeceb6c2cf4">gzerr</a>.</p>

</div>
</div>
<a id="a9fc55ab4c05c3d5a303533db96fdd6c2" name="a9fc55ab4c05c3d5a303533db96fdd6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc55ab4c05c3d5a303533db96fdd6c2">&#9670;&#160;</a></span>RenderTextureMetalId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RenderTextureMetalId </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_textureIdPtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Metal texture id associated with the render texture used by this camera. A valid Id is obtained only if the underlying render engine is Metal based. The pointer set by this function must be released to an id&lt;MTLTexture&gt; using CFBridgingRelease. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_textureIdPtr</td><td>the address of a void* pointer. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a1a31834536300647551f6994c2e1d6cd">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#ac6471787c1c5cc6c90f79f71a073a4f1">Ogre2Camera</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl()</a>, and <a class="elRef" href="https://gazebosim.org/api/common/6/Console_8hh.html#acf18c83e7419e002351f1eeceb6c2cf4">gzerr</a>.</p>

</div>
</div>
<a id="a372de693ad40b3f42839c8ec6ac845f4" name="a372de693ad40b3f42839c8ec6ac845f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372de693ad40b3f42839c8ec6ac845f4">&#9670;&#160;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespacegz_1_1rendering.html#a60883d4958a60b91661e97027a85072aa63fe43ea67a397bab7ddb34d401593eb">gz::rendering::PF_R8G8B8</a>, and <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Angle.html#a6aa0e49b37d4504631dffa16cf7c210f">Angle::SetDegree()</a>.</p>

</div>
</div>
<a id="a65ed42232bb67b9d68819919242835ac" name="a65ed42232bb67b9d68819919242835ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ed42232bb67b9d68819919242835ac">&#9670;&#160;</a></span>SaveFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SaveFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the previously rendered frame to a file. This function can be called multiple times after PostRender has been called, without rendering the scene again. Calling this function before a single image has been rendered will have undefined behavior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the output file </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a47679df4013984bbfe7a98b468d844e3">Camera</a>.</p>

</div>
</div>
<a id="a5b30d93eb6528f40812176b4a8034bef" name="a5b30d93eb6528f40812176b4a8034bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b30d93eb6528f40812176b4a8034bef">&#9670;&#160;</a></span>SetAntiAliasing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetAntiAliasing </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_aa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the level of anti-aliasing used during rendering. If a value of 0 is given, no anti-aliasing will be performed. Higher values can significantly slow-down rendering times, depending on the underlying render engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_aa</td><td>Level of anti-aliasing used during rendering </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#ab157f1f3e2249f54a4d5786cb8ff576b">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#ae0ee64e8ef6a2237fd46fc4924c37adb">OgreCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#ae0ee64e8ef6a2237fd46fc4924c37adb">Ogre2Camera</a>.</p>

</div>
</div>
<a id="a2f9714b680f706268287b316b41d1ec4" name="a2f9714b680f706268287b316b41d1ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9714b680f706268287b316b41d1ec4">&#9670;&#160;</a></span>SetAspectRatio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetAspectRatio </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>_ratio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the camera's aspect ratio. This value determines the cameras vertical field-of-view. It is often the. </p>
<div class="fragment"><div class="line"> image_height /</div>
<div class="line">image_width </div>
</div><!-- fragment --><p> but this is not necessarily true.</p>
<p>Setting a value &lt;= 0.0 indicates the aspect ratio will be automatically calculated based on width &amp; height.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_ratio</td><td>The camera's aspect ratio </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#adc6fc0b99e5c81f89408f0a69693f155">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#ab458dbf5792a590f3b82c8a9b7d6fbca">OgreCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#ab458dbf5792a590f3b82c8a9b7d6fbca">Ogre2Camera</a>.</p>

</div>
</div>
<a id="aaeac6ea05aa4060c49a00c1157956635" name="aaeac6ea05aa4060c49a00c1157956635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeac6ea05aa4060c49a00c1157956635">&#9670;&#160;</a></span>SetFarClipPlane()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetFarClipPlane </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>_far</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the camera's far clipping plane distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_far</td><td>Far clipping plane distance </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a836de880dc9b7a7b1af916877080bfb5">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#a5f7e00e8f11771e0df7457382721a8da">OgreCamera</a>, <a class="el" href="classgz_1_1rendering_1_1OgreDepthCamera.html#a5f7e00e8f11771e0df7457382721a8da">OgreDepthCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#a5f7e00e8f11771e0df7457382721a8da">Ogre2Camera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2DepthCamera.html#a5f7e00e8f11771e0df7457382721a8da">Ogre2DepthCamera</a>.</p>

</div>
</div>
<a id="ac699cc5bdc08e75cff0a9d89dedf3c47" name="ac699cc5bdc08e75cff0a9d89dedf3c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac699cc5bdc08e75cff0a9d89dedf3c47">&#9670;&#160;</a></span>SetFollowOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetFollowOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set offset of camera from target node being followed. The offset will be in the frame that is specified at the time the follow target is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_offset</td><td>Offset distance from target node. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a2c039e42aff60a8af8a0a9a259440c60">Camera</a>.</p>

</div>
</div>
<a id="afc44aed499a5063783744390ef719caa" name="afc44aed499a5063783744390ef719caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc44aed499a5063783744390ef719caa">&#9670;&#160;</a></span>SetFollowPGain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetFollowPGain </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>_pGain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set follow P Gain. Determines how fast the camera moves to follow the target node. Valid range: [0-1]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pGain</td><td>P gain for camera following </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#add61795d96a31dd14e079cd6949ec1ba">Camera</a>.</p>

<p class="reference">References <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a588718ce51b32e8a0dc46d8424291c9b">gz::math::clamp()</a>.</p>

</div>
</div>
<a id="ab2917e6270b03621204bde0f91190731" name="ab2917e6270b03621204bde0f91190731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2917e6270b03621204bde0f91190731">&#9670;&#160;</a></span>SetFollowTarget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetFollowTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>_worldFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a node for camera to follow. The camera will automatically update its position to keep itself at the specified offset distance from the target being followed. If null is specified, camera follow is disabled. In contrast to SetTrackTarget, the camera does not change its orientation when following is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_target</td><td>Target node to follow </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_offset</td><td>Tether the camera at an offset distance from the target node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldFrame</td><td>True to follow the target node at a distance that's fixed in world frame. Default is false which means the camera follows at fixed distance in target node's local frame. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#ae5dac859964f1c47eba4d46d6d3ef9f9">Camera</a>.</p>

</div>
</div>
<a id="a072290bcd172af7b38d81579b43ff140" name="a072290bcd172af7b38d81579b43ff140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072290bcd172af7b38d81579b43ff140">&#9670;&#160;</a></span>SetHFOV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetHFOV </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Angle.html">math::Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>_hfov</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the camera's horizontal field-of-view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_hfov</td><td>Desired horizontal field-of-view </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a6006ab82914cfea1380c8cf1801c8506">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#acde9df0cd42ea893994e9f8f61f59b2b">OgreCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#acde9df0cd42ea893994e9f8f61f59b2b">Ogre2Camera</a>.</p>

</div>
</div>
<a id="a62fa339b568fe38499f912d562dcc924" name="a62fa339b568fe38499f912d562dcc924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62fa339b568fe38499f912d562dcc924">&#9670;&#160;</a></span>SetImageFormat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetImageFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#a60883d4958a60b91661e97027a85072a">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_reinterpretable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the image pixel format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_format</td><td>New image pixel format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_reinterpretable</td><td>See <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html#aeebf99b8c16cd963ab906d43af02a31a" title="Set the render target image format.">RenderTarget::SetFormat</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a06a81e8ee61486e27db9fd957b7862f3">Camera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html#aeebf99b8c16cd963ab906d43af02a31a">RenderTarget::SetFormat()</a>.</p>

</div>
</div>
<a id="a3e88e59e12c03d871106936fad69f291" name="a3e88e59e12c03d871106936fad69f291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e88e59e12c03d871106936fad69f291">&#9670;&#160;</a></span>SetImageHeight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetImageHeight </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_height</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the image height in pixels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_height</td><td>New image height in pixels </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a9931c967c61f1795bf3e8b4a9cb1f036">Camera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html#a3e09a7c2fa69e7cc96388ec90fb3cb0c">RenderTarget::SetHeight()</a>.</p>

</div>
</div>
<a id="a0555cfcd77cd43b1459cf6d82ee21941" name="a0555cfcd77cd43b1459cf6d82ee21941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0555cfcd77cd43b1459cf6d82ee21941">&#9670;&#160;</a></span>SetImageWidth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetImageWidth </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the image width in pixels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_width</td><td>New image width in pixels </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#ac4b866028cc4e794189dc32c61985022">Camera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1RenderTarget.html#afc716be5833c7973edffd975d6f893c6">RenderTarget::SetWidth()</a>.</p>

</div>
</div>
<a id="a3bc6d45527fa868179e2e2053e7084cb" name="a3bc6d45527fa868179e2e2053e7084cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc6d45527fa868179e2e2053e7084cb">&#9670;&#160;</a></span>SetMaterial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>_material</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a material that the camera should see on all objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_material</td><td>a material instance </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a6e44f0ec4fb40d949e2ad5ec50e692c3">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#ab0e592ae3ef8264bf3cf0502f91ccb24">OgreCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#ab0e592ae3ef8264bf3cf0502f91ccb24">Ogre2Camera</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl()</a>, and <a class="elRef" href="https://gazebosim.org/api/common/6/Console_8hh.html#acf18c83e7419e002351f1eeceb6c2cf4">gzerr</a>.</p>

</div>
</div>
<a id="a2716be2aba22d745afba9106d7d6a1f5" name="a2716be2aba22d745afba9106d7d6a1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2716be2aba22d745afba9106d7d6a1f5">&#9670;&#160;</a></span>SetNearClipPlane()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetNearClipPlane </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>_near</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the camera's near clipping plane distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_near</td><td>Near clipping plane distance </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a9ba66f9dd5f4e055b8648bfe088dce60">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#ae1773c40bc14940eae6c351c40e51187">OgreCamera</a>, <a class="el" href="classgz_1_1rendering_1_1OgreDepthCamera.html#ae1773c40bc14940eae6c351c40e51187">OgreDepthCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#ae1773c40bc14940eae6c351c40e51187">Ogre2Camera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2DepthCamera.html#ae1773c40bc14940eae6c351c40e51187">Ogre2DepthCamera</a>.</p>

</div>
</div>
<a id="a630025fda8ecf2b8ec7cfc5102005456" name="a630025fda8ecf2b8ec7cfc5102005456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630025fda8ecf2b8ec7cfc5102005456">&#9670;&#160;</a></span>SetProjectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetProjectionMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#afe7ea008ee9e656fb34621264a42e04a">math::Matrix4d</a> &amp;&#160;</td>
          <td class="paramname"><em>_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the projection matrix for this camera. This overrides the standard projection matrix computed based on camera parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_matrix</td><td><a class="el" href="classgz_1_1rendering_1_1Camera.html" title="Posable camera used for rendering the scene graph.">Camera</a> projection matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#ab24ecbf1e3abc3c15dbff24927545503">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#add04d9ad388704200a9530bdf688cf23">OgreCamera</a>, <a class="el" href="classgz_1_1rendering_1_1OgreDepthCamera.html#add04d9ad388704200a9530bdf688cf23">OgreDepthCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2BoundingBoxCamera.html#add04d9ad388704200a9530bdf688cf23">Ogre2BoundingBoxCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#add04d9ad388704200a9530bdf688cf23">Ogre2Camera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2DepthCamera.html#add04d9ad388704200a9530bdf688cf23">Ogre2DepthCamera</a>, <a class="el" href="classgz_1_1rendering_1_1Ogre2SegmentationCamera.html#add04d9ad388704200a9530bdf688cf23">Ogre2SegmentationCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2ThermalCamera.html#add04d9ad388704200a9530bdf688cf23">Ogre2ThermalCamera</a>.</p>

</div>
</div>
<a id="a135a3efaa036a791d02c537654f700bb" name="a135a3efaa036a791d02c537654f700bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135a3efaa036a791d02c537654f700bb">&#9670;&#160;</a></span>SetProjectionType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetProjectionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#a07f284387dda2cd2d77f2b7a027f501f">CameraProjectionType</a>&#160;</td>
          <td class="paramname"><em>_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the projection type for this camera This changes the projection matrix of the camera based on the camera projection type. A custom projection matrix can be specified via <code>SetProjectionMatrix</code> to override the provided one. To disable the custom projection matrix, just call this function again with the desired projection type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_type</td><td><a class="el" href="classgz_1_1rendering_1_1Camera.html" title="Posable camera used for rendering the scene graph.">Camera</a> projection type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#a630025fda8ecf2b8ec7cfc5102005456" title="Set the projection matrix for this camera. This overrides the standard projection matrix computed bas...">SetProjectionMatrix</a> </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#aafc20c4f9bafcdc6dce5c19359b8a2b5">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#abab177fc1b0ae7db6361218c276eaa46">OgreCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#abab177fc1b0ae7db6361218c276eaa46">Ogre2Camera</a>.</p>

</div>
</div>
<a id="aea9474fedc282aeddffab66424417716" name="aea9474fedc282aeddffab66424417716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9474fedc282aeddffab66424417716">&#9670;&#160;</a></span>SetShadowsDirty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetShadowsDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a6d6b493b5ee97c5f8a6c9d0b50d562c1">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#aea9474fedc282aeddffab66424417716">Ogre2Camera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2DepthCamera.html#aea9474fedc282aeddffab66424417716">Ogre2DepthCamera</a>.</p>

</div>
</div>
<a id="a9fa8c2386ef1add93cd2c488db362d92" name="a9fa8c2386ef1add93cd2c488db362d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa8c2386ef1add93cd2c488db362d92">&#9670;&#160;</a></span>SetTrackOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetTrackOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set track offset. <a class="el" href="classgz_1_1rendering_1_1Camera.html" title="Posable camera used for rendering the scene graph.">Camera</a> will track a point that's at an offset from the target node. The offset will be in the frame that is specified at the time the track target is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_offset</td><td>Point offset to track </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#ab47a460750b82715608a619d227f0c14">Camera</a>.</p>

</div>
</div>
<a id="a241de3dad08c4eaa8fbb357c044fee44" name="a241de3dad08c4eaa8fbb357c044fee44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241de3dad08c4eaa8fbb357c044fee44">&#9670;&#160;</a></span>SetTrackPGain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetTrackPGain </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>_pGain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set track P Gain. Determines how fast the camera rotates to look at the target node. Valid range: [0-1]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pGain</td><td>P gain for camera tracking </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a38a1a18a8cb28c39c838e8a3b736f332">Camera</a>.</p>

<p class="reference">References <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a588718ce51b32e8a0dc46d8424291c9b">gz::math::clamp()</a>.</p>

</div>
</div>
<a id="a140450b987baaf723f86025690037a55" name="a140450b987baaf723f86025690037a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140450b987baaf723f86025690037a55">&#9670;&#160;</a></span>SetTrackTarget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetTrackTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> &amp;&#160;</td>
          <td class="paramname"><em>_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>_worldFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a node for camera to track. The camera will automatically change its orientation to face the target being tracked. If null is specified, tracking is disabled. In contrast to SetFollowTarget the camera does not change its position when tracking is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_target</td><td>Target node to track </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_offset</td><td>Track a point that is at an offset relative to target. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldFrame</td><td>If true, the offset point to track will be treated in world frame and its position relative to the target node remains fixed regardless of the target node's rotation. Default is false, which means the camera tracks the point in target node's local frame. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a492d6ad21711d6050ccda1a96676f8fe">Camera</a>.</p>

</div>
</div>
<a id="a542223a05104234fabcaeb5c61adce44" name="a542223a05104234fabcaeb5c61adce44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542223a05104234fabcaeb5c61adce44">&#9670;&#160;</a></span>TrackOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> TrackOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the track offset vector in the frame specified at the time the track target is set. </p>
<dl class="section return"><dt>Returns</dt><dd>Point offset from target. </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a872c086cb0fd73d882b92898ad1f437d">Camera</a>.</p>

</div>
</div>
<a id="ae92b7cc8f3403b6fe75e519d107245c2" name="ae92b7cc8f3403b6fe75e519d107245c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92b7cc8f3403b6fe75e519d107245c2">&#9670;&#160;</a></span>TrackPGain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double TrackPGain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the camera track rotation P gain. </p>
<dl class="section return"><dt>Returns</dt><dd>P gain for camera tracking </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a80ddf22b34244b60c4a79db98f8947f9">Camera</a>.</p>

</div>
</div>
<a id="a22c84f6f76fcd4781d78207e3160345e" name="a22c84f6f76fcd4781d78207e3160345e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c84f6f76fcd4781d78207e3160345e">&#9670;&#160;</a></span>TrackTarget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> TrackTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the target node being tracked. </p>
<dl class="section return"><dt>Returns</dt><dd>Target node being tracked. </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#aa5d89183bfd1463c3d1c4511b073c3a8">Camera</a>.</p>

</div>
</div>
<a id="aafdddf2ff6454efa496f5a32b737dd10" name="aafdddf2ff6454efa496f5a32b737dd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdddf2ff6454efa496f5a32b737dd10">&#9670;&#160;</a></span>Update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a new frame. This is a convenience function for single-camera scenes. It wraps the pre-render, render, and post-render into a single function. This should NOT be used in applications with multiple cameras or multiple consumers of a single camera's images. </p>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a3095b4c60155b1cd356b96cf25c49110">Camera</a>.</p>

<p class="reference">References <a class="el" href="classgz_1_1rendering_1_1Scene.html#aee73a4d9fd3bca2a941038e4a5a3879d">Scene::PostRender()</a>, and <a class="el" href="classgz_1_1rendering_1_1Scene.html#adffb56e0e545fefebf96b36f295396e9">Scene::PreRender()</a>.</p>

</div>
</div>
<a id="a8be7d5a13bf8d8601ffd1941e6098bb9" name="a8be7d5a13bf8d8601ffd1941e6098bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be7d5a13bf8d8601ffd1941e6098bb9">&#9670;&#160;</a></span>ViewMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#afe7ea008ee9e656fb34621264a42e04a">math::Matrix4d</a> ViewMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the view matrix for this camera. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgz_1_1rendering_1_1Camera.html" title="Posable camera used for rendering the scene graph.">Camera</a> view matrix </dd></dl>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#a50d285f6e4e826c7eb08d75be86f52e8">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#a91e2e01250cace3838469ef044db4d9f">OgreCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#a91e2e01250cace3838469ef044db4d9f">Ogre2Camera</a>.</p>

<p class="reference">References <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Matrix4.html#a07cc5773aa22d84c5587144c001f0793">Matrix4&lt; typename T &gt;::SetTranslation()</a>, and <a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Matrix3.html#a109318636af36bc89e9853f19e4369e2">Matrix3&lt; typename T &gt;::Transpose()</a>.</p>

</div>
</div>
<a id="acce7f083e994273d642990924be50194" name="acce7f083e994273d642990924be50194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce7f083e994273d642990924be50194">&#9670;&#160;</a></span>VisualAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a> VisualAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#aa83d444bd6cbecb112158663c2e0c213">gz::math::Vector2i</a> &amp;&#160;</td>
          <td class="paramname"><em>_mousePos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the visual for a given mouse position param[in] _mousePos mouse position. </p>

<p>Implements <a class="el" href="classgz_1_1rendering_1_1Camera.html#afd3aca11c03a7504c4c51625534a90cc">Camera</a>.</p>

<p>Reimplemented in <a class="el" href="classgz_1_1rendering_1_1OgreCamera.html#a146901ff98c4589b15c9420372952a02">OgreCamera</a>, and <a class="el" href="classgz_1_1rendering_1_1Ogre2Camera.html#a146901ff98c4589b15c9420372952a02">Ogre2Camera</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl()</a>, and <a class="elRef" href="https://gazebosim.org/api/common/6/Console_8hh.html#acf18c83e7419e002351f1eeceb6c2cf4">gzerr</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a12014c8d719a0f35240288e9d4de3186" name="a12014c8d719a0f35240288e9d4de3186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12014c8d719a0f35240288e9d4de3186">&#9670;&#160;</a></span>antiAliasing</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int antiAliasing = 0u</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Anti-aliasing. </p>

</div>
</div>
<a id="a11926af9280d70fd96e47b07c90cf0ed" name="a11926af9280d70fd96e47b07c90cf0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11926af9280d70fd96e47b07c90cf0ed">&#9670;&#160;</a></span>aspect</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double aspect = 1.3333333</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aspect ratio. </p>

</div>
</div>
<a id="a2ea313f8008d3098e559c391e862715d" name="a2ea313f8008d3098e559c391e862715d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea313f8008d3098e559c391e862715d">&#9670;&#160;</a></span>farClip</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double farClip = 1000.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Far clipping plane distance. </p>

</div>
</div>
<a id="a3aa5ce4b27490ef3cb76c5f4de52bea2" name="a3aa5ce4b27490ef3cb76c5f4de52bea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa5ce4b27490ef3cb76c5f4de52bea2">&#9670;&#160;</a></span>followNode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> followNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Target node to follow. </p>

</div>
</div>
<a id="aac55b67805d416a519d69a740b5b8099" name="aac55b67805d416a519d69a740b5b8099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac55b67805d416a519d69a740b5b8099">&#9670;&#160;</a></span>followOffset</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> followOffset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offset distance between camera and target node being followed. </p>

</div>
</div>
<a id="a84242208ed583431c2732f1c7a675c05" name="a84242208ed583431c2732f1c7a675c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84242208ed583431c2732f1c7a675c05">&#9670;&#160;</a></span>followPGain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double followPGain = 1.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>P gain for follow mode. Determines how fast the camera moves to follow the target node. Valid range: [0-1]. </p>

</div>
</div>
<a id="ac53b9c1dd232b7371177b234dddad72b" name="ac53b9c1dd232b7371177b234dddad72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53b9c1dd232b7371177b234dddad72b">&#9670;&#160;</a></span>followWorldFrame</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool followWorldFrame = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Follow target in world frame. </p>

</div>
</div>
<a id="a739154d13ff6ba3b279f53961e83735b" name="a739154d13ff6ba3b279f53961e83735b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739154d13ff6ba3b279f53961e83735b">&#9670;&#160;</a></span>hfov</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Angle.html">math::Angle</a> hfov</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Horizontal camera field of view. </p>

</div>
</div>
<a id="af27e8673b86c6bc0175c65dc774f970c" name="af27e8673b86c6bc0175c65dc774f970c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27e8673b86c6bc0175c65dc774f970c">&#9670;&#160;</a></span>imageBuffer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1rendering.html#a04be7d792dc3459f903c3c360de0bef9">ImagePtr</a> imageBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac794dd46a5e3d003899228120870fc9f" name="ac794dd46a5e3d003899228120870fc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac794dd46a5e3d003899228120870fc9f">&#9670;&#160;</a></span>nearClip</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double nearClip = 0.01</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Near clipping plane distance. </p>

</div>
</div>
<a id="a40d6bf301fa6e7d7ac30e2b0f25f9112" name="a40d6bf301fa6e7d7ac30e2b0f25f9112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d6bf301fa6e7d7ac30e2b0f25f9112">&#9670;&#160;</a></span>newFrameEvent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gazebosim.org/api/common/6/classgz_1_1common_1_1EventT.html">common::EventT</a>&lt;void(const void *, unsigned int, unsigned int, unsigned int, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;)&gt; newFrameEvent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e404e759ecb2d6bdbb6c13860414679" name="a1e404e759ecb2d6bdbb6c13860414679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e404e759ecb2d6bdbb6c13860414679">&#9670;&#160;</a></span>projectionMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#afe7ea008ee9e656fb34621264a42e04a">math::Matrix4d</a> projectionMatrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom projection matrix. </p>

</div>
</div>
<a id="afb258d5d212df8ac3db0173600475dd8" name="afb258d5d212df8ac3db0173600475dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb258d5d212df8ac3db0173600475dd8">&#9670;&#160;</a></span>projectionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1rendering.html#a07f284387dda2cd2d77f2b7a027f501f">CameraProjectionType</a> projectionType = <a class="el" href="namespacegz_1_1rendering.html#a07f284387dda2cd2d77f2b7a027f501fa33a438a24012e33e488b38a4a1794864">CPT_PERSPECTIVE</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classgz_1_1rendering_1_1Camera.html" title="Posable camera used for rendering the scene graph.">Camera</a> projection type. </p>

</div>
</div>
<a id="a0e6bda239c5675d1e84c5b9a34a51457" name="a0e6bda239c5675d1e84c5b9a34a51457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6bda239c5675d1e84c5b9a34a51457">&#9670;&#160;</a></span>trackNode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> trackNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Target node to track if camera tracking is on. </p>

</div>
</div>
<a id="acb3ba25d12f56c1fdb01d58c384576fd" name="acb3ba25d12f56c1fdb01d58c384576fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3ba25d12f56c1fdb01d58c384576fd">&#9670;&#160;</a></span>trackOffset</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html#a1f05093f5ee1a9ecdd54476792e4c206">math::Vector3d</a> trackOffset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set camera to track a point offset in target node's local or world frame depending on trackWorldFrame. </p>

</div>
</div>
<a id="aad1051d1593f812a4fa3991bd5c2d95d" name="aad1051d1593f812a4fa3991bd5c2d95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1051d1593f812a4fa3991bd5c2d95d">&#9670;&#160;</a></span>trackPGain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double trackPGain = 1.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>P gain for tracking. Determines how fast the camera rotates to look at the target node. Valid range: [0-1]. </p>

</div>
</div>
<a id="a9a5416d1099a0f51312b7acd2da25f73" name="a9a5416d1099a0f51312b7acd2da25f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5416d1099a0f51312b7acd2da25f73">&#9670;&#160;</a></span>trackWorldFrame</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool trackWorldFrame = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Track point relative to target in world frame. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="BaseCamera_8hh_source.html">BaseCamera.hh</a></li>
</ul>
</div><!-- contents -->
      </div>
    </main>
  </div>
</body>
