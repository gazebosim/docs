<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Rendering">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Rendering: Scene Class Reference</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Rendering</h1>
        <h2>API Reference</h2>
        <div class="version">
        8.2.0
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.1 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegz.html">gz</a></li><li class="navelem"><a class="el" href="namespacegz_1_1rendering.html">rendering</a></li><li class="navelem"><a class="el" href="classgz_1_1rendering_1_1Scene.html">Scene</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classgz_1_1rendering_1_1Scene-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Scene Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node. A <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a> also serves as a factory for all scene objects.  
 <a href="classgz_1_1rendering_1_1Scene.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Scene_8hh_source.html">gz/rendering/Scene.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3b8d7a28a38493f69a0fd09f5f315cf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ac3b8d7a28a38493f69a0fd09f5f315cf">~Scene</a> ()</td></tr>
<tr class="memdesc:ac3b8d7a28a38493f69a0fd09f5f315cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classgz_1_1rendering_1_1Scene.html#ac3b8d7a28a38493f69a0fd09f5f315cf">More...</a><br /></td></tr>
<tr class="separator:ac3b8d7a28a38493f69a0fd09f5f315cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032cd71ad4781243fec7c0ce096a2e95"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/7/classgz_1_1math_1_1Color.html">math::Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a032cd71ad4781243fec7c0ce096a2e95">AmbientLight</a> () const =0</td></tr>
<tr class="memdesc:a032cd71ad4781243fec7c0ce096a2e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scene ambient light color.  <a href="classgz_1_1rendering_1_1Scene.html#a032cd71ad4781243fec7c0ce096a2e95">More...</a><br /></td></tr>
<tr class="separator:a032cd71ad4781243fec7c0ce096a2e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26091dd2571ab2486ec8cb9b535db1bd"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="https://gazebosim.org/api/math/7/classgz_1_1math_1_1Color.html">math::Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a26091dd2571ab2486ec8cb9b535db1bd">BackgroundColor</a> () const =0</td></tr>
<tr class="memdesc:a26091dd2571ab2486ec8cb9b535db1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scene background color.  <a href="classgz_1_1rendering_1_1Scene.html#a26091dd2571ab2486ec8cb9b535db1bd">More...</a><br /></td></tr>
<tr class="separator:a26091dd2571ab2486ec8cb9b535db1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c9a9bf549a44b5bd202f6351d02a4e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a56c9a9bf549a44b5bd202f6351d02a4e">BackgroundMaterial</a> () const =0</td></tr>
<tr class="memdesc:a56c9a9bf549a44b5bd202f6351d02a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scene background material e.g. a material with skybox cubemap texture.  <a href="classgz_1_1rendering_1_1Scene.html#a56c9a9bf549a44b5bd202f6351d02a4e">More...</a><br /></td></tr>
<tr class="separator:a56c9a9bf549a44b5bd202f6351d02a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb5f45578bcf3643147fba7c19ff380"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a3fb5f45578bcf3643147fba7c19ff380">CameraPassCountPerGpuFlush</a> () const =0</td></tr>
<tr class="memdesc:a3fb5f45578bcf3643147fba7c19ff380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value set in SetCameraPassCountPerGpuFlush.  <a href="classgz_1_1rendering_1_1Scene.html#a3fb5f45578bcf3643147fba7c19ff380">More...</a><br /></td></tr>
<tr class="separator:a3fb5f45578bcf3643147fba7c19ff380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b31c976cc6734003d9950e731dfed3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#aa5b31c976cc6734003d9950e731dfed3">Clear</a> ()=0</td></tr>
<tr class="memdesc:aa5b31c976cc6734003d9950e731dfed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and destroy all objects from the scene graph. This does not completely destroy scene resources, so new objects can be created and added to the scene afterwards.  <a href="classgz_1_1rendering_1_1Scene.html#aa5b31c976cc6734003d9950e731dfed3">More...</a><br /></td></tr>
<tr class="separator:aa5b31c976cc6734003d9950e731dfed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47444f2cc9809d61d2a0514186cb97b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aae53901524397bca9d27f8767c8b2f14">ArrowVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ac47444f2cc9809d61d2a0514186cb97b">CreateArrowVisual</a> ()=0</td></tr>
<tr class="memdesc:ac47444f2cc9809d61d2a0514186cb97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new arrow visual. A unique ID and name will automatically be assigned to the visual.  <a href="classgz_1_1rendering_1_1Scene.html#ac47444f2cc9809d61d2a0514186cb97b">More...</a><br /></td></tr>
<tr class="separator:ac47444f2cc9809d61d2a0514186cb97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e401c88d214de1754c77f78fc225626"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aae53901524397bca9d27f8767c8b2f14">ArrowVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a4e401c88d214de1754c77f78fc225626">CreateArrowVisual</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a4e401c88d214de1754c77f78fc225626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new arrow visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a4e401c88d214de1754c77f78fc225626">More...</a><br /></td></tr>
<tr class="separator:a4e401c88d214de1754c77f78fc225626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf2259ff68acb864ba01403821875cf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aae53901524397bca9d27f8767c8b2f14">ArrowVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#acaf2259ff68acb864ba01403821875cf">CreateArrowVisual</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:acaf2259ff68acb864ba01403821875cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new arrow visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#acaf2259ff68acb864ba01403821875cf">More...</a><br /></td></tr>
<tr class="separator:acaf2259ff68acb864ba01403821875cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04895c0d67840a5d2cbdea4189c3aad"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aae53901524397bca9d27f8767c8b2f14">ArrowVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ae04895c0d67840a5d2cbdea4189c3aad">CreateArrowVisual</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:ae04895c0d67840a5d2cbdea4189c3aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new arrow visual with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ae04895c0d67840a5d2cbdea4189c3aad">More...</a><br /></td></tr>
<tr class="separator:ae04895c0d67840a5d2cbdea4189c3aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2479dfec039650a448bec7742535ee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a3d226d80e377750d4840fe874717138e">AxisVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a9f2479dfec039650a448bec7742535ee">CreateAxisVisual</a> ()=0</td></tr>
<tr class="memdesc:a9f2479dfec039650a448bec7742535ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new axis visual. A unique ID and name will automatically be assigned to the visual.  <a href="classgz_1_1rendering_1_1Scene.html#a9f2479dfec039650a448bec7742535ee">More...</a><br /></td></tr>
<tr class="separator:a9f2479dfec039650a448bec7742535ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaa6002ad639283ee923ee25444c7c0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a3d226d80e377750d4840fe874717138e">AxisVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a2eaa6002ad639283ee923ee25444c7c0">CreateAxisVisual</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a2eaa6002ad639283ee923ee25444c7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new axis visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a2eaa6002ad639283ee923ee25444c7c0">More...</a><br /></td></tr>
<tr class="separator:a2eaa6002ad639283ee923ee25444c7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72407fecec75409c5e80ca7aa6d8585"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a3d226d80e377750d4840fe874717138e">AxisVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ab72407fecec75409c5e80ca7aa6d8585">CreateAxisVisual</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:ab72407fecec75409c5e80ca7aa6d8585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new axis visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ab72407fecec75409c5e80ca7aa6d8585">More...</a><br /></td></tr>
<tr class="separator:ab72407fecec75409c5e80ca7aa6d8585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d652d648d296eb72eb0a2914c56520b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a3d226d80e377750d4840fe874717138e">AxisVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a4d652d648d296eb72eb0a2914c56520b">CreateAxisVisual</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a4d652d648d296eb72eb0a2914c56520b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new axis visual with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a4d652d648d296eb72eb0a2914c56520b">More...</a><br /></td></tr>
<tr class="separator:a4d652d648d296eb72eb0a2914c56520b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de4ede39964b6dba14ff15297b585ad"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a3b5bc8e4ba8d97749293280ab8e132e8">BoundingBoxCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a5de4ede39964b6dba14ff15297b585ad">CreateBoundingBoxCamera</a> ()=0</td></tr>
<tr class="memdesc:a5de4ede39964b6dba14ff15297b585ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new <a class="el" href="classgz_1_1rendering_1_1BoundingBox.html" title="2D or 3D Bounding box. It stores the position / orientation / size info of the box and its label">BoundingBox</a> camera. A unique ID and name will automatically be assigned to the camera.  <a href="classgz_1_1rendering_1_1Scene.html#a5de4ede39964b6dba14ff15297b585ad">More...</a><br /></td></tr>
<tr class="separator:a5de4ede39964b6dba14ff15297b585ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fe131b541689621129ea70c86c2bc4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a3b5bc8e4ba8d97749293280ab8e132e8">BoundingBoxCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a39fe131b541689621129ea70c86c2bc4">CreateBoundingBoxCamera</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a39fe131b541689621129ea70c86c2bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new <a class="el" href="classgz_1_1rendering_1_1BoundingBox.html" title="2D or 3D Bounding box. It stores the position / orientation / size info of the box and its label">BoundingBox</a> camera with the given name. A unique ID will automatically be assigned to the camera. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a39fe131b541689621129ea70c86c2bc4">More...</a><br /></td></tr>
<tr class="separator:a39fe131b541689621129ea70c86c2bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdb4d53c11c79910e55c2819b981184"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a3b5bc8e4ba8d97749293280ab8e132e8">BoundingBoxCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#abcdb4d53c11c79910e55c2819b981184">CreateBoundingBoxCamera</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:abcdb4d53c11c79910e55c2819b981184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new <a class="el" href="classgz_1_1rendering_1_1BoundingBox.html" title="2D or 3D Bounding box. It stores the position / orientation / size info of the box and its label">BoundingBox</a> camera with the given ID. A unique name will automatically be assigned to the camera. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#abcdb4d53c11c79910e55c2819b981184">More...</a><br /></td></tr>
<tr class="separator:abcdb4d53c11c79910e55c2819b981184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99600311cab824134d03a34a5fbd5e72"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a3b5bc8e4ba8d97749293280ab8e132e8">BoundingBoxCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a99600311cab824134d03a34a5fbd5e72">CreateBoundingBoxCamera</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a99600311cab824134d03a34a5fbd5e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new <a class="el" href="classgz_1_1rendering_1_1BoundingBox.html" title="2D or 3D Bounding box. It stores the position / orientation / size info of the box and its label">BoundingBox</a> camera with the given ID &amp; name. If either the given ID or name is already in use, will return NULL.  <a href="classgz_1_1rendering_1_1Scene.html#a99600311cab824134d03a34a5fbd5e72">More...</a><br /></td></tr>
<tr class="separator:a99600311cab824134d03a34a5fbd5e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674b7d2bb813ff47bac2c583b33a1f3e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a32bd50043028477c50f07cce13213556">GeometryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a674b7d2bb813ff47bac2c583b33a1f3e">CreateBox</a> ()=0</td></tr>
<tr class="memdesc:a674b7d2bb813ff47bac2c583b33a1f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new box geometry.  <a href="classgz_1_1rendering_1_1Scene.html#a674b7d2bb813ff47bac2c583b33a1f3e">More...</a><br /></td></tr>
<tr class="separator:a674b7d2bb813ff47bac2c583b33a1f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3271c911d48de8063145ccc3a5e9dc8c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#afc9577975b8c7e847de55c43bd5798c0">CameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a3271c911d48de8063145ccc3a5e9dc8c">CreateCamera</a> ()=0</td></tr>
<tr class="memdesc:a3271c911d48de8063145ccc3a5e9dc8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new camera. A unique ID and name will automatically be assigned to the camera.  <a href="classgz_1_1rendering_1_1Scene.html#a3271c911d48de8063145ccc3a5e9dc8c">More...</a><br /></td></tr>
<tr class="separator:a3271c911d48de8063145ccc3a5e9dc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2397042a56eb7c0e2e5aff1ab35552d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#afc9577975b8c7e847de55c43bd5798c0">CameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ab2397042a56eb7c0e2e5aff1ab35552d">CreateCamera</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:ab2397042a56eb7c0e2e5aff1ab35552d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new camera with the given name. A unique ID will automatically be assigned to the camera. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ab2397042a56eb7c0e2e5aff1ab35552d">More...</a><br /></td></tr>
<tr class="separator:ab2397042a56eb7c0e2e5aff1ab35552d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b4dc991920167dbea3d347aec18371"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#afc9577975b8c7e847de55c43bd5798c0">CameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ab7b4dc991920167dbea3d347aec18371">CreateCamera</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:ab7b4dc991920167dbea3d347aec18371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new camera with the given ID. A unique name will automatically be assigned to the camera. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ab7b4dc991920167dbea3d347aec18371">More...</a><br /></td></tr>
<tr class="separator:ab7b4dc991920167dbea3d347aec18371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f273f230c2927c7dd73f881747649f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#afc9577975b8c7e847de55c43bd5798c0">CameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a30f273f230c2927c7dd73f881747649f">CreateCamera</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a30f273f230c2927c7dd73f881747649f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new camera with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a30f273f230c2927c7dd73f881747649f">More...</a><br /></td></tr>
<tr class="separator:a30f273f230c2927c7dd73f881747649f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe24cea72806676e08008cd1b3c2ec1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a249ca83f5d8ea47506727cbb44d14aa9">CapsulePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#adfe24cea72806676e08008cd1b3c2ec1">CreateCapsule</a> ()=0</td></tr>
<tr class="memdesc:adfe24cea72806676e08008cd1b3c2ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new capsule geometry.  <a href="classgz_1_1rendering_1_1Scene.html#adfe24cea72806676e08008cd1b3c2ec1">More...</a><br /></td></tr>
<tr class="separator:adfe24cea72806676e08008cd1b3c2ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542098817d87ca595712fbd3898f9c26"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aeeb897b4ec5b5c14ed9556b94c82cd17">COMVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a542098817d87ca595712fbd3898f9c26">CreateCOMVisual</a> ()=0</td></tr>
<tr class="memdesc:a542098817d87ca595712fbd3898f9c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new CoM visual. A unique ID and name will automatically be assigned to the CoM visual.  <a href="classgz_1_1rendering_1_1Scene.html#a542098817d87ca595712fbd3898f9c26">More...</a><br /></td></tr>
<tr class="separator:a542098817d87ca595712fbd3898f9c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ded0a6b615968a4413ce83eb8459d4b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aeeb897b4ec5b5c14ed9556b94c82cd17">COMVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a2ded0a6b615968a4413ce83eb8459d4b">CreateCOMVisual</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a2ded0a6b615968a4413ce83eb8459d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new CoM visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a2ded0a6b615968a4413ce83eb8459d4b">More...</a><br /></td></tr>
<tr class="separator:a2ded0a6b615968a4413ce83eb8459d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0246623f4b4716bd2674001c9fd88fc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aeeb897b4ec5b5c14ed9556b94c82cd17">COMVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ad0246623f4b4716bd2674001c9fd88fc">CreateCOMVisual</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:ad0246623f4b4716bd2674001c9fd88fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new CoM visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ad0246623f4b4716bd2674001c9fd88fc">More...</a><br /></td></tr>
<tr class="separator:ad0246623f4b4716bd2674001c9fd88fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a3370206d3d859ab8797fc8aef5434"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aeeb897b4ec5b5c14ed9556b94c82cd17">COMVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ae6a3370206d3d859ab8797fc8aef5434">CreateCOMVisual</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:ae6a3370206d3d859ab8797fc8aef5434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new CoM visual with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ae6a3370206d3d859ab8797fc8aef5434">More...</a><br /></td></tr>
<tr class="separator:ae6a3370206d3d859ab8797fc8aef5434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224c8301e4981bb95f66f510c396a4e2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a32bd50043028477c50f07cce13213556">GeometryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a224c8301e4981bb95f66f510c396a4e2">CreateCone</a> ()=0</td></tr>
<tr class="memdesc:a224c8301e4981bb95f66f510c396a4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new cone geometry.  <a href="classgz_1_1rendering_1_1Scene.html#a224c8301e4981bb95f66f510c396a4e2">More...</a><br /></td></tr>
<tr class="separator:a224c8301e4981bb95f66f510c396a4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd457431115e80e2d7a95b6edb1ee818"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a32bd50043028477c50f07cce13213556">GeometryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#afd457431115e80e2d7a95b6edb1ee818">CreateCylinder</a> ()=0</td></tr>
<tr class="memdesc:afd457431115e80e2d7a95b6edb1ee818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new cylinder geometry.  <a href="classgz_1_1rendering_1_1Scene.html#afd457431115e80e2d7a95b6edb1ee818">More...</a><br /></td></tr>
<tr class="separator:afd457431115e80e2d7a95b6edb1ee818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a0db3e251219a719244933100a7830"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a7b7291d7f5d3bc1ee846763b2e7429a5">DepthCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a45a0db3e251219a719244933100a7830">CreateDepthCamera</a> ()=0</td></tr>
<tr class="memdesc:a45a0db3e251219a719244933100a7830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new depth camera. A unique ID and name will automatically be assigned to the camera.  <a href="classgz_1_1rendering_1_1Scene.html#a45a0db3e251219a719244933100a7830">More...</a><br /></td></tr>
<tr class="separator:a45a0db3e251219a719244933100a7830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddb7c78e8b624ed92f00ede9a93bffc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a7b7291d7f5d3bc1ee846763b2e7429a5">DepthCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a8ddb7c78e8b624ed92f00ede9a93bffc">CreateDepthCamera</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a8ddb7c78e8b624ed92f00ede9a93bffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new depth camera with the given name. A unique ID will automatically be assigned to the camera. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a8ddb7c78e8b624ed92f00ede9a93bffc">More...</a><br /></td></tr>
<tr class="separator:a8ddb7c78e8b624ed92f00ede9a93bffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140a666d886fd28ee93b73d483ed6e11"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a7b7291d7f5d3bc1ee846763b2e7429a5">DepthCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a140a666d886fd28ee93b73d483ed6e11">CreateDepthCamera</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a140a666d886fd28ee93b73d483ed6e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new depth camera with the given ID. A unique name will automatically be assigned to the camera. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a140a666d886fd28ee93b73d483ed6e11">More...</a><br /></td></tr>
<tr class="separator:a140a666d886fd28ee93b73d483ed6e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c38b2a9e0da6ed42144a4f0110b4e2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a7b7291d7f5d3bc1ee846763b2e7429a5">DepthCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ae6c38b2a9e0da6ed42144a4f0110b4e2">CreateDepthCamera</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:ae6c38b2a9e0da6ed42144a4f0110b4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new depth camera with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ae6c38b2a9e0da6ed42144a4f0110b4e2">More...</a><br /></td></tr>
<tr class="separator:ae6c38b2a9e0da6ed42144a4f0110b4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac473e7c03d9d8c53da614d8530ebcb24"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#abcafeecad84375cb761b8f4c0a4408c0">DirectionalLightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ac473e7c03d9d8c53da614d8530ebcb24">CreateDirectionalLight</a> ()=0</td></tr>
<tr class="memdesc:ac473e7c03d9d8c53da614d8530ebcb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new directional light. A unique ID and name will automatically be assigned to the light.  <a href="classgz_1_1rendering_1_1Scene.html#ac473e7c03d9d8c53da614d8530ebcb24">More...</a><br /></td></tr>
<tr class="separator:ac473e7c03d9d8c53da614d8530ebcb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067004fac837a1d43bb2724cc254fefa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#abcafeecad84375cb761b8f4c0a4408c0">DirectionalLightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a067004fac837a1d43bb2724cc254fefa">CreateDirectionalLight</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a067004fac837a1d43bb2724cc254fefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new directional light with the given name. A unique ID will automatically be assigned to the light. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a067004fac837a1d43bb2724cc254fefa">More...</a><br /></td></tr>
<tr class="separator:a067004fac837a1d43bb2724cc254fefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c660fc522f33afbac24e6120294afff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#abcafeecad84375cb761b8f4c0a4408c0">DirectionalLightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a1c660fc522f33afbac24e6120294afff">CreateDirectionalLight</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a1c660fc522f33afbac24e6120294afff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new directional light with the given ID. A unique name will automatically be assigned to the light. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a1c660fc522f33afbac24e6120294afff">More...</a><br /></td></tr>
<tr class="separator:a1c660fc522f33afbac24e6120294afff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd59d3693981d6fd538f3c1268b62ab6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#abcafeecad84375cb761b8f4c0a4408c0">DirectionalLightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#acd59d3693981d6fd538f3c1268b62ab6">CreateDirectionalLight</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:acd59d3693981d6fd538f3c1268b62ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new directional light with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#acd59d3693981d6fd538f3c1268b62ab6">More...</a><br /></td></tr>
<tr class="separator:acd59d3693981d6fd538f3c1268b62ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add47771718e396140697ecc916fc72bd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ab386d61975c3cdfb0497cf958ee3506a">GizmoVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#add47771718e396140697ecc916fc72bd">CreateGizmoVisual</a> ()=0</td></tr>
<tr class="memdesc:add47771718e396140697ecc916fc72bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new gizmo visual. A unique ID and name will automatically be assigned to the visual.  <a href="classgz_1_1rendering_1_1Scene.html#add47771718e396140697ecc916fc72bd">More...</a><br /></td></tr>
<tr class="separator:add47771718e396140697ecc916fc72bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966de3642e0847870d890dc75050dacf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ab386d61975c3cdfb0497cf958ee3506a">GizmoVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a966de3642e0847870d890dc75050dacf">CreateGizmoVisual</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a966de3642e0847870d890dc75050dacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new gizmo visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a966de3642e0847870d890dc75050dacf">More...</a><br /></td></tr>
<tr class="separator:a966de3642e0847870d890dc75050dacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f5e0d29d825cd9052b825cb7aba8cb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ab386d61975c3cdfb0497cf958ee3506a">GizmoVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ab4f5e0d29d825cd9052b825cb7aba8cb">CreateGizmoVisual</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:ab4f5e0d29d825cd9052b825cb7aba8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new gizmo visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ab4f5e0d29d825cd9052b825cb7aba8cb">More...</a><br /></td></tr>
<tr class="separator:ab4f5e0d29d825cd9052b825cb7aba8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c97548c380222d1bcc3a1f755c667b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ab386d61975c3cdfb0497cf958ee3506a">GizmoVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a13c97548c380222d1bcc3a1f755c667b">CreateGizmoVisual</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a13c97548c380222d1bcc3a1f755c667b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new gizmo visual with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a13c97548c380222d1bcc3a1f755c667b">More...</a><br /></td></tr>
<tr class="separator:a13c97548c380222d1bcc3a1f755c667b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddac29100802d367108ded04c4fbb0f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a9783b44dbd5dbc068fee5f484113ccf1">GlobalIlluminationCiVctPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a0ddac29100802d367108ded04c4fbb0f">CreateGlobalIlluminationCiVct</a> ()=0</td></tr>
<tr class="memdesc:a0ddac29100802d367108ded04c4fbb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new GI CIVCT solution with the given name. A unique ID and name will automatically be assigned to the GI.  <a href="classgz_1_1rendering_1_1Scene.html#a0ddac29100802d367108ded04c4fbb0f">More...</a><br /></td></tr>
<tr class="separator:a0ddac29100802d367108ded04c4fbb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065953d88546991b0470b3cdf63ec270"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a9783b44dbd5dbc068fee5f484113ccf1">GlobalIlluminationCiVctPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a065953d88546991b0470b3cdf63ec270">CreateGlobalIlluminationCiVct</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a065953d88546991b0470b3cdf63ec270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new GI CIVCT solution with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a065953d88546991b0470b3cdf63ec270">More...</a><br /></td></tr>
<tr class="separator:a065953d88546991b0470b3cdf63ec270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1423405af3cdc860ef3af3909323efcc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a9783b44dbd5dbc068fee5f484113ccf1">GlobalIlluminationCiVctPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a1423405af3cdc860ef3af3909323efcc">CreateGlobalIlluminationCiVct</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a1423405af3cdc860ef3af3909323efcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new GI CIVCT solution with the given name. A unique name will automatically be assigned to the GI. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a1423405af3cdc860ef3af3909323efcc">More...</a><br /></td></tr>
<tr class="separator:a1423405af3cdc860ef3af3909323efcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958ce4df212fd983ea7b36de7458f871"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a9783b44dbd5dbc068fee5f484113ccf1">GlobalIlluminationCiVctPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a958ce4df212fd983ea7b36de7458f871">CreateGlobalIlluminationCiVct</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a958ce4df212fd983ea7b36de7458f871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new GI CIVCT solution with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a958ce4df212fd983ea7b36de7458f871">More...</a><br /></td></tr>
<tr class="separator:a958ce4df212fd983ea7b36de7458f871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f59d725ed2ae66ab8018ed94c71f4ac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a92c9876994a02318c67d81cb77455a97">GlobalIlluminationVctPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a5f59d725ed2ae66ab8018ed94c71f4ac">CreateGlobalIlluminationVct</a> ()=0</td></tr>
<tr class="memdesc:a5f59d725ed2ae66ab8018ed94c71f4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new GI VCT solution with the given name. A unique ID and name will automatically be assigned to the GI.  <a href="classgz_1_1rendering_1_1Scene.html#a5f59d725ed2ae66ab8018ed94c71f4ac">More...</a><br /></td></tr>
<tr class="separator:a5f59d725ed2ae66ab8018ed94c71f4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31d239fbec297cadbcb3f160785017c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a92c9876994a02318c67d81cb77455a97">GlobalIlluminationVctPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#af31d239fbec297cadbcb3f160785017c">CreateGlobalIlluminationVct</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:af31d239fbec297cadbcb3f160785017c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new GI VCT solution with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#af31d239fbec297cadbcb3f160785017c">More...</a><br /></td></tr>
<tr class="separator:af31d239fbec297cadbcb3f160785017c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1542d612505423514e1621c1c0876618"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a92c9876994a02318c67d81cb77455a97">GlobalIlluminationVctPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a1542d612505423514e1621c1c0876618">CreateGlobalIlluminationVct</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a1542d612505423514e1621c1c0876618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new GI VCT solution with the given name. A unique name will automatically be assigned to the GI. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a1542d612505423514e1621c1c0876618">More...</a><br /></td></tr>
<tr class="separator:a1542d612505423514e1621c1c0876618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cf58227c7fc064742c89529d121e7a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a92c9876994a02318c67d81cb77455a97">GlobalIlluminationVctPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#aa3cf58227c7fc064742c89529d121e7a">CreateGlobalIlluminationVct</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:aa3cf58227c7fc064742c89529d121e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new GI VCT solution with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#aa3cf58227c7fc064742c89529d121e7a">More...</a><br /></td></tr>
<tr class="separator:aa3cf58227c7fc064742c89529d121e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff2ece2800797fb42b865104fa9ff69"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a5cd9e1e8200c513d17d316275be327c7">GpuRaysPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#abff2ece2800797fb42b865104fa9ff69">CreateGpuRays</a> ()=0</td></tr>
<tr class="memdesc:abff2ece2800797fb42b865104fa9ff69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new gpu rays caster. A unique ID and name will automatically be assigned to the gpu rays caster.  <a href="classgz_1_1rendering_1_1Scene.html#abff2ece2800797fb42b865104fa9ff69">More...</a><br /></td></tr>
<tr class="separator:abff2ece2800797fb42b865104fa9ff69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1255f04d0569fa406b96981d220544c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a5cd9e1e8200c513d17d316275be327c7">GpuRaysPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ac1255f04d0569fa406b96981d220544c">CreateGpuRays</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:ac1255f04d0569fa406b96981d220544c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new gpu rays caster with the given name. A unique ID will automatically be assigned to the gpu rays caster. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ac1255f04d0569fa406b96981d220544c">More...</a><br /></td></tr>
<tr class="separator:ac1255f04d0569fa406b96981d220544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b23beb5255b2f225be60bb1ea3ba69e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a5cd9e1e8200c513d17d316275be327c7">GpuRaysPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a2b23beb5255b2f225be60bb1ea3ba69e">CreateGpuRays</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a2b23beb5255b2f225be60bb1ea3ba69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new gpu rays caster with the given ID. A unique name will automatically be assigned to the gpu rays caster. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a2b23beb5255b2f225be60bb1ea3ba69e">More...</a><br /></td></tr>
<tr class="separator:a2b23beb5255b2f225be60bb1ea3ba69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5d6b09b51a23adde71204dbbd66b63"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a5cd9e1e8200c513d17d316275be327c7">GpuRaysPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a3c5d6b09b51a23adde71204dbbd66b63">CreateGpuRays</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a3c5d6b09b51a23adde71204dbbd66b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new gpu rays caster with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a3c5d6b09b51a23adde71204dbbd66b63">More...</a><br /></td></tr>
<tr class="separator:a3c5d6b09b51a23adde71204dbbd66b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb59ed9f5259b8b97e9e7c5350c93b4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aec68c97392cdf9868b01fc8019f2bde5">GridPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a8fb59ed9f5259b8b97e9e7c5350c93b4">CreateGrid</a> ()=0</td></tr>
<tr class="memdesc:a8fb59ed9f5259b8b97e9e7c5350c93b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new grid geometry.  <a href="classgz_1_1rendering_1_1Scene.html#a8fb59ed9f5259b8b97e9e7c5350c93b4">More...</a><br /></td></tr>
<tr class="separator:a8fb59ed9f5259b8b97e9e7c5350c93b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac738be7b9bd7e8f6a65312f1db5c3d77"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ad3d1141383b742e878ecca6f7a3b7241">HeightmapPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ac738be7b9bd7e8f6a65312f1db5c3d77">CreateHeightmap</a> (const <a class="el" href="classgz_1_1rendering_1_1HeightmapDescriptor.html">HeightmapDescriptor</a> &amp;_desc)=0</td></tr>
<tr class="memdesc:ac738be7b9bd7e8f6a65312f1db5c3d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new heightmap geomerty. The <a class="el" href="classgz_1_1rendering_1_1Heightmap.html" title="A terrain defined by a heightfield.">rendering::Heightmap</a> will be created from the given <a class="el" href="classgz_1_1rendering_1_1HeightmapDescriptor.html" title="Describes how a Heightmap should be loaded.">HeightmapDescriptor</a>.  <a href="classgz_1_1rendering_1_1Scene.html#ac738be7b9bd7e8f6a65312f1db5c3d77">More...</a><br /></td></tr>
<tr class="separator:ac738be7b9bd7e8f6a65312f1db5c3d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4412aa5a2875f6e4968eac5cec83f0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#affa41870d5eec126b03e9c2ad6159b49">InertiaVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a8a4412aa5a2875f6e4968eac5cec83f0">CreateInertiaVisual</a> ()=0</td></tr>
<tr class="memdesc:a8a4412aa5a2875f6e4968eac5cec83f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new inertia visual. A unique ID and name will automatically be assigned to the inertia visual.  <a href="classgz_1_1rendering_1_1Scene.html#a8a4412aa5a2875f6e4968eac5cec83f0">More...</a><br /></td></tr>
<tr class="separator:a8a4412aa5a2875f6e4968eac5cec83f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494e49555b4577c99f6bf10efa3b4c06"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#affa41870d5eec126b03e9c2ad6159b49">InertiaVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a494e49555b4577c99f6bf10efa3b4c06">CreateInertiaVisual</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a494e49555b4577c99f6bf10efa3b4c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new inertia visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a494e49555b4577c99f6bf10efa3b4c06">More...</a><br /></td></tr>
<tr class="separator:a494e49555b4577c99f6bf10efa3b4c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8d1486642842e0d3924462aa1ef6c5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#affa41870d5eec126b03e9c2ad6159b49">InertiaVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a4b8d1486642842e0d3924462aa1ef6c5">CreateInertiaVisual</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a4b8d1486642842e0d3924462aa1ef6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new inertia visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a4b8d1486642842e0d3924462aa1ef6c5">More...</a><br /></td></tr>
<tr class="separator:a4b8d1486642842e0d3924462aa1ef6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b07f46a791ad9aca937f6e8c86b6e2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#affa41870d5eec126b03e9c2ad6159b49">InertiaVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a32b07f46a791ad9aca937f6e8c86b6e2">CreateInertiaVisual</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a32b07f46a791ad9aca937f6e8c86b6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new inertia visual with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a32b07f46a791ad9aca937f6e8c86b6e2">More...</a><br /></td></tr>
<tr class="separator:a32b07f46a791ad9aca937f6e8c86b6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae888f922784d704fe63104ea24f7d575"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a5ce81676c62a4aa3e7fa798d42aafb43">JointVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ae888f922784d704fe63104ea24f7d575">CreateJointVisual</a> ()=0</td></tr>
<tr class="memdesc:ae888f922784d704fe63104ea24f7d575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new joint visual. A unique ID and name will automatically be assigned to the Joint visual.  <a href="classgz_1_1rendering_1_1Scene.html#ae888f922784d704fe63104ea24f7d575">More...</a><br /></td></tr>
<tr class="separator:ae888f922784d704fe63104ea24f7d575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e25a6cdc667d559470387a778f9e8f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a5ce81676c62a4aa3e7fa798d42aafb43">JointVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ad1e25a6cdc667d559470387a778f9e8f">CreateJointVisual</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:ad1e25a6cdc667d559470387a778f9e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new joint visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ad1e25a6cdc667d559470387a778f9e8f">More...</a><br /></td></tr>
<tr class="separator:ad1e25a6cdc667d559470387a778f9e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad626bfba7452b370b47ab45a159b67"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a5ce81676c62a4aa3e7fa798d42aafb43">JointVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#aaad626bfba7452b370b47ab45a159b67">CreateJointVisual</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:aaad626bfba7452b370b47ab45a159b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new joint visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#aaad626bfba7452b370b47ab45a159b67">More...</a><br /></td></tr>
<tr class="separator:aaad626bfba7452b370b47ab45a159b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afc714d06df598f9a2866845fe36463"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a5ce81676c62a4aa3e7fa798d42aafb43">JointVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a8afc714d06df598f9a2866845fe36463">CreateJointVisual</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a8afc714d06df598f9a2866845fe36463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new joint visual with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a8afc714d06df598f9a2866845fe36463">More...</a><br /></td></tr>
<tr class="separator:a8afc714d06df598f9a2866845fe36463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4611826d5400620d8ea432e05f8c557"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a0e3864bc06f90fba2169f71c3994b41c">LidarVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ac4611826d5400620d8ea432e05f8c557">CreateLidarVisual</a> ()=0</td></tr>
<tr class="memdesc:ac4611826d5400620d8ea432e05f8c557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new lidar visual. A unique ID and name will automatically be assigned to the lidar visual.  <a href="classgz_1_1rendering_1_1Scene.html#ac4611826d5400620d8ea432e05f8c557">More...</a><br /></td></tr>
<tr class="separator:ac4611826d5400620d8ea432e05f8c557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85c942b92fa59258e30f4641d592a8d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a0e3864bc06f90fba2169f71c3994b41c">LidarVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ad85c942b92fa59258e30f4641d592a8d">CreateLidarVisual</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:ad85c942b92fa59258e30f4641d592a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new lidar visual with the given name. A unique ID will automatically be assigned to the lidar visual. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ad85c942b92fa59258e30f4641d592a8d">More...</a><br /></td></tr>
<tr class="separator:ad85c942b92fa59258e30f4641d592a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffd4a655874b1ba65f267386cc1d1b6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a0e3864bc06f90fba2169f71c3994b41c">LidarVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a5ffd4a655874b1ba65f267386cc1d1b6">CreateLidarVisual</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a5ffd4a655874b1ba65f267386cc1d1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new lidar visual with the given ID. A unique name will automatically be assigned to the lidar visual. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a5ffd4a655874b1ba65f267386cc1d1b6">More...</a><br /></td></tr>
<tr class="separator:a5ffd4a655874b1ba65f267386cc1d1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87dfc9ab95851f4e8d6e05d4a0c6b903"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a0e3864bc06f90fba2169f71c3994b41c">LidarVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a87dfc9ab95851f4e8d6e05d4a0c6b903">CreateLidarVisual</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a87dfc9ab95851f4e8d6e05d4a0c6b903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new lidar visual with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a87dfc9ab95851f4e8d6e05d4a0c6b903">More...</a><br /></td></tr>
<tr class="separator:a87dfc9ab95851f4e8d6e05d4a0c6b903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af739005a2a537d6b3735bb88ad3f875e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ad789d3fba9cba5e0531dac9bf0d5dad2">LightVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#af739005a2a537d6b3735bb88ad3f875e">CreateLightVisual</a> ()=0</td></tr>
<tr class="memdesc:af739005a2a537d6b3735bb88ad3f875e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new light visual. A unique ID and name will automatically be assigned to the light visual.  <a href="classgz_1_1rendering_1_1Scene.html#af739005a2a537d6b3735bb88ad3f875e">More...</a><br /></td></tr>
<tr class="separator:af739005a2a537d6b3735bb88ad3f875e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d7d6bf6cf97ad34919fbcf0af105aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ad789d3fba9cba5e0531dac9bf0d5dad2">LightVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a62d7d6bf6cf97ad34919fbcf0af105aa">CreateLightVisual</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a62d7d6bf6cf97ad34919fbcf0af105aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new light visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a62d7d6bf6cf97ad34919fbcf0af105aa">More...</a><br /></td></tr>
<tr class="separator:a62d7d6bf6cf97ad34919fbcf0af105aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af929c8afb2dd3621c7389cf92b1707"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ad789d3fba9cba5e0531dac9bf0d5dad2">LightVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a7af929c8afb2dd3621c7389cf92b1707">CreateLightVisual</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a7af929c8afb2dd3621c7389cf92b1707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new light visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a7af929c8afb2dd3621c7389cf92b1707">More...</a><br /></td></tr>
<tr class="separator:a7af929c8afb2dd3621c7389cf92b1707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478a8fc34d535708cae43cddea9ece8c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ad789d3fba9cba5e0531dac9bf0d5dad2">LightVisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a478a8fc34d535708cae43cddea9ece8c">CreateLightVisual</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a478a8fc34d535708cae43cddea9ece8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new light visual with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a478a8fc34d535708cae43cddea9ece8c">More...</a><br /></td></tr>
<tr class="separator:a478a8fc34d535708cae43cddea9ece8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9219869f051a6ad686e24b247089a7b0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a5b784cf4efcbc71f4fb19e3009fc4a80">MarkerPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a9219869f051a6ad686e24b247089a7b0">CreateMarker</a> ()=0</td></tr>
<tr class="memdesc:a9219869f051a6ad686e24b247089a7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new marker geometry.  <a href="classgz_1_1rendering_1_1Scene.html#a9219869f051a6ad686e24b247089a7b0">More...</a><br /></td></tr>
<tr class="separator:a9219869f051a6ad686e24b247089a7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87f5382faf14f231fa55ff84c9e66e5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#aa87f5382faf14f231fa55ff84c9e66e5">CreateMaterial</a> (const <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1Material.html">common::Material</a> &amp;_material)=0</td></tr>
<tr class="memdesc:aa87f5382faf14f231fa55ff84c9e66e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new material from the reference <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1Material.html">common::Material</a>.  <a href="classgz_1_1rendering_1_1Scene.html#aa87f5382faf14f231fa55ff84c9e66e5">More...</a><br /></td></tr>
<tr class="separator:aa87f5382faf14f231fa55ff84c9e66e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8b1be5bf2a1798add3c860ba50c44d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a1d8b1be5bf2a1798add3c860ba50c44d">CreateMaterial</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name=&quot;&quot;)=0</td></tr>
<tr class="memdesc:a1d8b1be5bf2a1798add3c860ba50c44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new material with the given name. Created material will have default properties.  <a href="classgz_1_1rendering_1_1Scene.html#a1d8b1be5bf2a1798add3c860ba50c44d">More...</a><br /></td></tr>
<tr class="separator:a1d8b1be5bf2a1798add3c860ba50c44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac4d745cfd24a378cc3615d4f6e441e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#af37834327ffe201461e597ccea97064a">MeshPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a1ac4d745cfd24a378cc3615d4f6e441e">CreateMesh</a> (const <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1Mesh.html">common::Mesh</a> *_mesh)=0</td></tr>
<tr class="memdesc:a1ac4d745cfd24a378cc3615d4f6e441e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new mesh geomerty. The <a class="el" href="classgz_1_1rendering_1_1Mesh.html" title="Represents a collection of mesh geometries.">rendering::Mesh</a> will be created from the given <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1Mesh.html">common::Mesh</a>. All sub-meshes will be loaded into this created mesh, uncentered.  <a href="classgz_1_1rendering_1_1Scene.html#a1ac4d745cfd24a378cc3615d4f6e441e">More...</a><br /></td></tr>
<tr class="separator:a1ac4d745cfd24a378cc3615d4f6e441e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660681201c3c9517275cf6605594eddc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#af37834327ffe201461e597ccea97064a">MeshPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a660681201c3c9517275cf6605594eddc">CreateMesh</a> (const <a class="el" href="structgz_1_1rendering_1_1MeshDescriptor.html">MeshDescriptor</a> &amp;_desc)=0</td></tr>
<tr class="memdesc:a660681201c3c9517275cf6605594eddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new mesh geometry. The <a class="el" href="classgz_1_1rendering_1_1Mesh.html" title="Represents a collection of mesh geometries.">rendering::Mesh</a> will be created from the given <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1Mesh.html">common::Mesh</a> specified in the <a class="el" href="structgz_1_1rendering_1_1MeshDescriptor.html" title="Describes how a Mesh should be loaded.">MeshDescriptor</a>. Sub-meshes will be loaded and centered according to the descriptor.  <a href="classgz_1_1rendering_1_1Scene.html#a660681201c3c9517275cf6605594eddc">More...</a><br /></td></tr>
<tr class="separator:a660681201c3c9517275cf6605594eddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b54cf1b702b4bbf78311f23b0b1c0e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#af37834327ffe201461e597ccea97064a">MeshPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ad4b54cf1b702b4bbf78311f23b0b1c0e">CreateMesh</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_meshName)=0</td></tr>
<tr class="memdesc:ad4b54cf1b702b4bbf78311f23b0b1c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new mesh geomerty. The <a class="el" href="classgz_1_1rendering_1_1Mesh.html" title="Represents a collection of mesh geometries.">rendering::Mesh</a> will be created from a <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1Mesh.html">common::Mesh</a> retrieved from <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1MeshManager.html">common::MeshManager</a> using the given mesh name. If no mesh exists by this name, NULL will be returned. All sub-meshes will be loaded into the created mesh, uncentered.  <a href="classgz_1_1rendering_1_1Scene.html#ad4b54cf1b702b4bbf78311f23b0b1c0e">More...</a><br /></td></tr>
<tr class="separator:ad4b54cf1b702b4bbf78311f23b0b1c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebaa2c1b748f19cfa191cc8cb161af74"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a5052ea1e0a7143689ae12b54210c161b">ParticleEmitterPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#aebaa2c1b748f19cfa191cc8cb161af74">CreateParticleEmitter</a> ()=0</td></tr>
<tr class="memdesc:aebaa2c1b748f19cfa191cc8cb161af74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new particle emitter. A unique ID and name will automatically be assigned to the visual.  <a href="classgz_1_1rendering_1_1Scene.html#aebaa2c1b748f19cfa191cc8cb161af74">More...</a><br /></td></tr>
<tr class="separator:aebaa2c1b748f19cfa191cc8cb161af74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2986dec92369000288ae5623543b567"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a5052ea1e0a7143689ae12b54210c161b">ParticleEmitterPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#af2986dec92369000288ae5623543b567">CreateParticleEmitter</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:af2986dec92369000288ae5623543b567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new particle emitter with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#af2986dec92369000288ae5623543b567">More...</a><br /></td></tr>
<tr class="separator:af2986dec92369000288ae5623543b567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb9f692533cbca1108f16c45ef5a536"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a5052ea1e0a7143689ae12b54210c161b">ParticleEmitterPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a9bb9f692533cbca1108f16c45ef5a536">CreateParticleEmitter</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a9bb9f692533cbca1108f16c45ef5a536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new particle emitter with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a9bb9f692533cbca1108f16c45ef5a536">More...</a><br /></td></tr>
<tr class="separator:a9bb9f692533cbca1108f16c45ef5a536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1fe10fbc5122232e99b086ae8b18a7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a5052ea1e0a7143689ae12b54210c161b">ParticleEmitterPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a8e1fe10fbc5122232e99b086ae8b18a7">CreateParticleEmitter</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a8e1fe10fbc5122232e99b086ae8b18a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new particle emitter with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a8e1fe10fbc5122232e99b086ae8b18a7">More...</a><br /></td></tr>
<tr class="separator:a8e1fe10fbc5122232e99b086ae8b18a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de41800064b899f2e573fcc78668eb5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a32bd50043028477c50f07cce13213556">GeometryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a6de41800064b899f2e573fcc78668eb5">CreatePlane</a> ()=0</td></tr>
<tr class="memdesc:a6de41800064b899f2e573fcc78668eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new plane geometry.  <a href="classgz_1_1rendering_1_1Scene.html#a6de41800064b899f2e573fcc78668eb5">More...</a><br /></td></tr>
<tr class="separator:a6de41800064b899f2e573fcc78668eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e51935372f644d0d6c95651583c36a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#acb58cc265a1af914bf5416d601dd1800">PointLightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ab8e51935372f644d0d6c95651583c36a">CreatePointLight</a> ()=0</td></tr>
<tr class="memdesc:ab8e51935372f644d0d6c95651583c36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new point light. A unique ID and name will automatically be assigned to the light.  <a href="classgz_1_1rendering_1_1Scene.html#ab8e51935372f644d0d6c95651583c36a">More...</a><br /></td></tr>
<tr class="separator:ab8e51935372f644d0d6c95651583c36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5821c7c1ea947b16e5c4cc746327c45"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#acb58cc265a1af914bf5416d601dd1800">PointLightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ab5821c7c1ea947b16e5c4cc746327c45">CreatePointLight</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:ab5821c7c1ea947b16e5c4cc746327c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new point light with the given name. A unique ID will automatically be assigned to the light. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ab5821c7c1ea947b16e5c4cc746327c45">More...</a><br /></td></tr>
<tr class="separator:ab5821c7c1ea947b16e5c4cc746327c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c36990d69c3fd285fb22cd34d0ab025"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#acb58cc265a1af914bf5416d601dd1800">PointLightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a3c36990d69c3fd285fb22cd34d0ab025">CreatePointLight</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a3c36990d69c3fd285fb22cd34d0ab025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new point light with the given ID. A unique name will automatically be assigned to the light. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a3c36990d69c3fd285fb22cd34d0ab025">More...</a><br /></td></tr>
<tr class="separator:a3c36990d69c3fd285fb22cd34d0ab025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af529302478a2065ea517a83bcbec9cc9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#acb58cc265a1af914bf5416d601dd1800">PointLightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#af529302478a2065ea517a83bcbec9cc9">CreatePointLight</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:af529302478a2065ea517a83bcbec9cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new point light with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#af529302478a2065ea517a83bcbec9cc9">More...</a><br /></td></tr>
<tr class="separator:af529302478a2065ea517a83bcbec9cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab020fd710662ceb0671df4ce76cd046b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a88907530513e4998443d618ff074bc22">ProjectorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ab020fd710662ceb0671df4ce76cd046b">CreateProjector</a> ()=0</td></tr>
<tr class="memdesc:ab020fd710662ceb0671df4ce76cd046b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new projector. A unique ID and name will automatically be assigned to the visual.  <a href="classgz_1_1rendering_1_1Scene.html#ab020fd710662ceb0671df4ce76cd046b">More...</a><br /></td></tr>
<tr class="separator:ab020fd710662ceb0671df4ce76cd046b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b12896827f263fa7b48607b13da68e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a88907530513e4998443d618ff074bc22">ProjectorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ae7b12896827f263fa7b48607b13da68e">CreateProjector</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:ae7b12896827f263fa7b48607b13da68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new projector with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ae7b12896827f263fa7b48607b13da68e">More...</a><br /></td></tr>
<tr class="separator:ae7b12896827f263fa7b48607b13da68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa6675b7c52bbc143bd4792666eb656"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a88907530513e4998443d618ff074bc22">ProjectorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a3fa6675b7c52bbc143bd4792666eb656">CreateProjector</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a3fa6675b7c52bbc143bd4792666eb656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new projector with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a3fa6675b7c52bbc143bd4792666eb656">More...</a><br /></td></tr>
<tr class="separator:a3fa6675b7c52bbc143bd4792666eb656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b0bf2c46a106114d74e238a773ed98"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a88907530513e4998443d618ff074bc22">ProjectorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a30b0bf2c46a106114d74e238a773ed98">CreateProjector</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a30b0bf2c46a106114d74e238a773ed98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new projector with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a30b0bf2c46a106114d74e238a773ed98">More...</a><br /></td></tr>
<tr class="separator:a30b0bf2c46a106114d74e238a773ed98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991bec3f2e25c3ca3429bd973a4541bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a339d41e07ac42437b359952569f6e453">RayQueryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a991bec3f2e25c3ca3429bd973a4541bb">CreateRayQuery</a> ()=0</td></tr>
<tr class="memdesc:a991bec3f2e25c3ca3429bd973a4541bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new ray query.  <a href="classgz_1_1rendering_1_1Scene.html#a991bec3f2e25c3ca3429bd973a4541bb">More...</a><br /></td></tr>
<tr class="separator:a991bec3f2e25c3ca3429bd973a4541bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b899b4c2a97bfaaccc585d8e5795f5c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a34e895108c5d7fe55c6216985b7a500a">RenderTexturePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a7b899b4c2a97bfaaccc585d8e5795f5c">CreateRenderTexture</a> ()=0</td></tr>
<tr class="memdesc:a7b899b4c2a97bfaaccc585d8e5795f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new render texture.  <a href="classgz_1_1rendering_1_1Scene.html#a7b899b4c2a97bfaaccc585d8e5795f5c">More...</a><br /></td></tr>
<tr class="separator:a7b899b4c2a97bfaaccc585d8e5795f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a68cb11799ca99655190e4f5a665a47"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ac06da5e129043c70d45b66d453b2e092">RenderWindowPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a2a68cb11799ca99655190e4f5a665a47">CreateRenderWindow</a> ()=0</td></tr>
<tr class="memdesc:a2a68cb11799ca99655190e4f5a665a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new render window. This feature is render engine dependent. If the engine does not support attaching to a windowing system then it should behave as a a render texture.  <a href="classgz_1_1rendering_1_1Scene.html#a2a68cb11799ca99655190e4f5a665a47">More...</a><br /></td></tr>
<tr class="separator:a2a68cb11799ca99655190e4f5a665a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2a8791479ec882812d30330c85ba7a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a8faac2d655fea7ffc72c0c12dab8c270">SegmentationCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a3c2a8791479ec882812d30330c85ba7a">CreateSegmentationCamera</a> ()=0</td></tr>
<tr class="memdesc:a3c2a8791479ec882812d30330c85ba7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new segmentation camera. A unique ID and name will automatically be assigned to the camera.  <a href="classgz_1_1rendering_1_1Scene.html#a3c2a8791479ec882812d30330c85ba7a">More...</a><br /></td></tr>
<tr class="separator:a3c2a8791479ec882812d30330c85ba7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38ce48219061087b10daba9f20283ee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a8faac2d655fea7ffc72c0c12dab8c270">SegmentationCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ae38ce48219061087b10daba9f20283ee">CreateSegmentationCamera</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:ae38ce48219061087b10daba9f20283ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new segmentation camera with the given name. A unique ID will automatically be assigned to the camera. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ae38ce48219061087b10daba9f20283ee">More...</a><br /></td></tr>
<tr class="separator:ae38ce48219061087b10daba9f20283ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d342286cffb027f8fb5b95da0ea9ff7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a8faac2d655fea7ffc72c0c12dab8c270">SegmentationCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a6d342286cffb027f8fb5b95da0ea9ff7">CreateSegmentationCamera</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a6d342286cffb027f8fb5b95da0ea9ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new segmentation camera with the given ID. A unique name will automatically be assigned to the camera. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a6d342286cffb027f8fb5b95da0ea9ff7">More...</a><br /></td></tr>
<tr class="separator:a6d342286cffb027f8fb5b95da0ea9ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9feef2173b8f370c306a367cf12f0a13"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a8faac2d655fea7ffc72c0c12dab8c270">SegmentationCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a9feef2173b8f370c306a367cf12f0a13">CreateSegmentationCamera</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a9feef2173b8f370c306a367cf12f0a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new segmentation camera with the given name and ID. If either the given ID or name is already in use, will return NULL.  <a href="classgz_1_1rendering_1_1Scene.html#a9feef2173b8f370c306a367cf12f0a13">More...</a><br /></td></tr>
<tr class="separator:a9feef2173b8f370c306a367cf12f0a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7faab30af1832868bd8d9678960e3f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a32bd50043028477c50f07cce13213556">GeometryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a3a7faab30af1832868bd8d9678960e3f">CreateSphere</a> ()=0</td></tr>
<tr class="memdesc:a3a7faab30af1832868bd8d9678960e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new sphere or ellipsoid geometry This method allow to create ellipsoid too, because it can be scaled in 3 dimensions.  <a href="classgz_1_1rendering_1_1Scene.html#a3a7faab30af1832868bd8d9678960e3f">More...</a><br /></td></tr>
<tr class="separator:a3a7faab30af1832868bd8d9678960e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c91c1847b0f539e65e9cf253bb2659"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#afafdb4220fc308ea4ad40ed846734b4d">SpotLightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a44c91c1847b0f539e65e9cf253bb2659">CreateSpotLight</a> ()=0</td></tr>
<tr class="memdesc:a44c91c1847b0f539e65e9cf253bb2659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new spotlight. A unique ID and name will automatically be assigned to the light.  <a href="classgz_1_1rendering_1_1Scene.html#a44c91c1847b0f539e65e9cf253bb2659">More...</a><br /></td></tr>
<tr class="separator:a44c91c1847b0f539e65e9cf253bb2659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b4bf7d3639d3ef36a71afc98df14c5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#afafdb4220fc308ea4ad40ed846734b4d">SpotLightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#af9b4bf7d3639d3ef36a71afc98df14c5">CreateSpotLight</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:af9b4bf7d3639d3ef36a71afc98df14c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new spotlight with the given name. A unique ID will automatically be assigned to the light. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#af9b4bf7d3639d3ef36a71afc98df14c5">More...</a><br /></td></tr>
<tr class="separator:af9b4bf7d3639d3ef36a71afc98df14c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ec02c7637af4c3244284080ef0a1d3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#afafdb4220fc308ea4ad40ed846734b4d">SpotLightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a45ec02c7637af4c3244284080ef0a1d3">CreateSpotLight</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a45ec02c7637af4c3244284080ef0a1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new spotlight with the given ID. A unique name will automatically be assigned to the light. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a45ec02c7637af4c3244284080ef0a1d3">More...</a><br /></td></tr>
<tr class="separator:a45ec02c7637af4c3244284080ef0a1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbfb9c2fce7dcd8ab391e85a1916562"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#afafdb4220fc308ea4ad40ed846734b4d">SpotLightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a2fbfb9c2fce7dcd8ab391e85a1916562">CreateSpotLight</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a2fbfb9c2fce7dcd8ab391e85a1916562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new spotlight with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a2fbfb9c2fce7dcd8ab391e85a1916562">More...</a><br /></td></tr>
<tr class="separator:a2fbfb9c2fce7dcd8ab391e85a1916562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adf9cbe55db56e0b42b22e7a22a4ab4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a23360ba152f25aababf8f75212206650">TextPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a3adf9cbe55db56e0b42b22e7a22a4ab4">CreateText</a> ()=0</td></tr>
<tr class="memdesc:a3adf9cbe55db56e0b42b22e7a22a4ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new text geometry.  <a href="classgz_1_1rendering_1_1Scene.html#a3adf9cbe55db56e0b42b22e7a22a4ab4">More...</a><br /></td></tr>
<tr class="separator:a3adf9cbe55db56e0b42b22e7a22a4ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf345602cfef3f7882dcfb2594a39ee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a77c5d6e2e974d36dd5355b4001c1fb55">ThermalCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a4cf345602cfef3f7882dcfb2594a39ee">CreateThermalCamera</a> ()=0</td></tr>
<tr class="memdesc:a4cf345602cfef3f7882dcfb2594a39ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new thermal camera. A unique ID and name will automatically be assigned to the camera.  <a href="classgz_1_1rendering_1_1Scene.html#a4cf345602cfef3f7882dcfb2594a39ee">More...</a><br /></td></tr>
<tr class="separator:a4cf345602cfef3f7882dcfb2594a39ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4e8a2bff259d35040eafd838b6d7fd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a77c5d6e2e974d36dd5355b4001c1fb55">ThermalCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a3c4e8a2bff259d35040eafd838b6d7fd">CreateThermalCamera</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a3c4e8a2bff259d35040eafd838b6d7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new thermal camera with the given name. A unique ID will automatically be assigned to the camera. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a3c4e8a2bff259d35040eafd838b6d7fd">More...</a><br /></td></tr>
<tr class="separator:a3c4e8a2bff259d35040eafd838b6d7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1959a1f42a5b04da6b24d313d73b598e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a77c5d6e2e974d36dd5355b4001c1fb55">ThermalCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a1959a1f42a5b04da6b24d313d73b598e">CreateThermalCamera</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a1959a1f42a5b04da6b24d313d73b598e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new thermal camera with the given ID. A unique name will automatically be assigned to the camera. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a1959a1f42a5b04da6b24d313d73b598e">More...</a><br /></td></tr>
<tr class="separator:a1959a1f42a5b04da6b24d313d73b598e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86443a6c64118e5c260f9a41bb2da748"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a77c5d6e2e974d36dd5355b4001c1fb55">ThermalCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a86443a6c64118e5c260f9a41bb2da748">CreateThermalCamera</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a86443a6c64118e5c260f9a41bb2da748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new thermal camera with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a86443a6c64118e5c260f9a41bb2da748">More...</a><br /></td></tr>
<tr class="separator:a86443a6c64118e5c260f9a41bb2da748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53298573a740bfaa5c4f214dfab5885"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#af53298573a740bfaa5c4f214dfab5885">CreateVisual</a> ()=0</td></tr>
<tr class="memdesc:af53298573a740bfaa5c4f214dfab5885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new visual. A unique ID and name will automatically be assigned to the visual.  <a href="classgz_1_1rendering_1_1Scene.html#af53298573a740bfaa5c4f214dfab5885">More...</a><br /></td></tr>
<tr class="separator:af53298573a740bfaa5c4f214dfab5885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cae65be44eaabb0af178f18d1a984fa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a0cae65be44eaabb0af178f18d1a984fa">CreateVisual</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a0cae65be44eaabb0af178f18d1a984fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a0cae65be44eaabb0af178f18d1a984fa">More...</a><br /></td></tr>
<tr class="separator:a0cae65be44eaabb0af178f18d1a984fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9f58335da23cf708ca487e0d0ee46a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a5b9f58335da23cf708ca487e0d0ee46a">CreateVisual</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a5b9f58335da23cf708ca487e0d0ee46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a5b9f58335da23cf708ca487e0d0ee46a">More...</a><br /></td></tr>
<tr class="separator:a5b9f58335da23cf708ca487e0d0ee46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17f582aec835f428d4db56dd132e331"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#aa17f582aec835f428d4db56dd132e331">CreateVisual</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:aa17f582aec835f428d4db56dd132e331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new visual with the given name. If either the given ID or name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#aa17f582aec835f428d4db56dd132e331">More...</a><br /></td></tr>
<tr class="separator:aa17f582aec835f428d4db56dd132e331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ba87845cf46224ea9282fea5a7a271"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ae2a9f26a9414efca43f3fb6a5468c7b1">WideAngleCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a58ba87845cf46224ea9282fea5a7a271">CreateWideAngleCamera</a> ()=0</td></tr>
<tr class="memdesc:a58ba87845cf46224ea9282fea5a7a271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new wide angle camera. A unique ID and name will automatically be assigned to the camera.  <a href="classgz_1_1rendering_1_1Scene.html#a58ba87845cf46224ea9282fea5a7a271">More...</a><br /></td></tr>
<tr class="separator:a58ba87845cf46224ea9282fea5a7a271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ab69d0f5df1c8979300d539ba99ce7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ae2a9f26a9414efca43f3fb6a5468c7b1">WideAngleCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a84ab69d0f5df1c8979300d539ba99ce7">CreateWideAngleCamera</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a84ab69d0f5df1c8979300d539ba99ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new wide angle camera with the given name. A unique ID will automatically be assigned to the camera. If the given name is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a84ab69d0f5df1c8979300d539ba99ce7">More...</a><br /></td></tr>
<tr class="separator:a84ab69d0f5df1c8979300d539ba99ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa66b31409729696b1e9482e757946db"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ae2a9f26a9414efca43f3fb6a5468c7b1">WideAngleCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#afa66b31409729696b1e9482e757946db">CreateWideAngleCamera</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:afa66b31409729696b1e9482e757946db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create wide angle camera with the given ID. A unique name will automatically be assigned to the camera. If the given ID is already in use, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#afa66b31409729696b1e9482e757946db">More...</a><br /></td></tr>
<tr class="separator:afa66b31409729696b1e9482e757946db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aff9032a39e38c953e421a7ea7187f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ae2a9f26a9414efca43f3fb6a5468c7b1">WideAngleCameraPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a90aff9032a39e38c953e421a7ea7187f">CreateWideAngleCamera</a> (unsigned int _id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a90aff9032a39e38c953e421a7ea7187f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new wide angle camera with the given name and ID. If either the given ID or name is already in use, will return NULL.  <a href="classgz_1_1rendering_1_1Scene.html#a90aff9032a39e38c953e421a7ea7187f">More...</a><br /></td></tr>
<tr class="separator:a90aff9032a39e38c953e421a7ea7187f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef680b5d9f7c59c7bebeed11d98c9d9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ab9fbd4591c3733f44eef88b055b77fda">WireBoxPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a8ef680b5d9f7c59c7bebeed11d98c9d9">CreateWireBox</a> ()=0</td></tr>
<tr class="memdesc:a8ef680b5d9f7c59c7bebeed11d98c9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new wire box geometry.  <a href="classgz_1_1rendering_1_1Scene.html#a8ef680b5d9f7c59c7bebeed11d98c9d9">More...</a><br /></td></tr>
<tr class="separator:a8ef680b5d9f7c59c7bebeed11d98c9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84693792fa8cba90b312c0b1caf53716"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a84693792fa8cba90b312c0b1caf53716">Destroy</a> ()=0</td></tr>
<tr class="memdesc:a84693792fa8cba90b312c0b1caf53716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completely destroy the scene an all its resources. Continued use of this scene after its destruction will result in undefined behavior.  <a href="classgz_1_1rendering_1_1Scene.html#a84693792fa8cba90b312c0b1caf53716">More...</a><br /></td></tr>
<tr class="separator:a84693792fa8cba90b312c0b1caf53716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaea3c39bcfbb419a5d6f0ab42b699e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#acaea3c39bcfbb419a5d6f0ab42b699e3">DestroyLight</a> (<a class="el" href="namespacegz_1_1rendering.html#aab8d92ebc05d82a9ae908385584c142d">LightPtr</a> _light, bool _recursive=false)=0</td></tr>
<tr class="memdesc:acaea3c39bcfbb419a5d6f0ab42b699e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy given light. If the given light is not managed by this scene, no work will be done. Depending on the _recursive argument, this function will either detach all child nodes from the scene graph or recursively destroy them.  <a href="classgz_1_1rendering_1_1Scene.html#acaea3c39bcfbb419a5d6f0ab42b699e3">More...</a><br /></td></tr>
<tr class="separator:acaea3c39bcfbb419a5d6f0ab42b699e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309391c0f1c7d2d2d5c7d4015b96beed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a309391c0f1c7d2d2d5c7d4015b96beed">DestroyLightById</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a309391c0f1c7d2d2d5c7d4015b96beed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy light with the given id. If no light exists with the given id, no work will be done. All children of the light will consequently be detached from the scene graph, but not destroyed.  <a href="classgz_1_1rendering_1_1Scene.html#a309391c0f1c7d2d2d5c7d4015b96beed">More...</a><br /></td></tr>
<tr class="separator:a309391c0f1c7d2d2d5c7d4015b96beed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8a59e602dabe7b55344f3ae54a9ff4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a5c8a59e602dabe7b55344f3ae54a9ff4">DestroyLightByIndex</a> (unsigned int _index)=0</td></tr>
<tr class="memdesc:a5c8a59e602dabe7b55344f3ae54a9ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy light at the given index. If no light exists at the given index, no work will be done. All children of the light will consequently be detached from the scene graph, but not destroyed.  <a href="classgz_1_1rendering_1_1Scene.html#a5c8a59e602dabe7b55344f3ae54a9ff4">More...</a><br /></td></tr>
<tr class="separator:a5c8a59e602dabe7b55344f3ae54a9ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f95bbd4a89c43f94462453a891c691e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a7f95bbd4a89c43f94462453a891c691e">DestroyLightByName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a7f95bbd4a89c43f94462453a891c691e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy light with the given name. If no light exists with the given name, no work will be done. All children of the light will consequently be detached from the scene graph, but not destroyed.  <a href="classgz_1_1rendering_1_1Scene.html#a7f95bbd4a89c43f94462453a891c691e">More...</a><br /></td></tr>
<tr class="separator:a7f95bbd4a89c43f94462453a891c691e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f781a6ac90ddb935e8737720145c56f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a6f781a6ac90ddb935e8737720145c56f">DestroyLights</a> ()=0</td></tr>
<tr class="memdesc:a6f781a6ac90ddb935e8737720145c56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy all lights manages by this scene.  <a href="classgz_1_1rendering_1_1Scene.html#a6f781a6ac90ddb935e8737720145c56f">More...</a><br /></td></tr>
<tr class="separator:a6f781a6ac90ddb935e8737720145c56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f0ab574cc1997b7a062c73b8d78077"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a77f0ab574cc1997b7a062c73b8d78077">DestroyMaterial</a> (<a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a> _material)=0</td></tr>
<tr class="memdesc:a77f0ab574cc1997b7a062c73b8d78077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister and destroy a material.  <a href="classgz_1_1rendering_1_1Scene.html#a77f0ab574cc1997b7a062c73b8d78077">More...</a><br /></td></tr>
<tr class="separator:a77f0ab574cc1997b7a062c73b8d78077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43df5dfeda03be4d8009253fa26a8150"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a43df5dfeda03be4d8009253fa26a8150">DestroyMaterials</a> ()=0</td></tr>
<tr class="memdesc:a43df5dfeda03be4d8009253fa26a8150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister and destroys all registered materials.  <a href="classgz_1_1rendering_1_1Scene.html#a43df5dfeda03be4d8009253fa26a8150">More...</a><br /></td></tr>
<tr class="separator:a43df5dfeda03be4d8009253fa26a8150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bc5affd75cbffa50e5145bef053bbd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ae7bc5affd75cbffa50e5145bef053bbd">DestroyNode</a> (<a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> _node, bool _recursive=false)=0</td></tr>
<tr class="memdesc:ae7bc5affd75cbffa50e5145bef053bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy given node. If the given node is not managed by this scene, no work will be done. Depending on the _recursive argument, this function will either detach all child nodes from the scene graph or recursively destroy them.  <a href="classgz_1_1rendering_1_1Scene.html#ae7bc5affd75cbffa50e5145bef053bbd">More...</a><br /></td></tr>
<tr class="separator:ae7bc5affd75cbffa50e5145bef053bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba0b438d1c5a642ceafeb5f47deef6f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a5ba0b438d1c5a642ceafeb5f47deef6f">DestroyNodeById</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a5ba0b438d1c5a642ceafeb5f47deef6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy node with the given id. If no node exists with the given id, no work will be done. All children of the node will consequently be detached from the scene graph, but not destroyed.  <a href="classgz_1_1rendering_1_1Scene.html#a5ba0b438d1c5a642ceafeb5f47deef6f">More...</a><br /></td></tr>
<tr class="separator:a5ba0b438d1c5a642ceafeb5f47deef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2005769f595ad103294a375b6287361c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a2005769f595ad103294a375b6287361c">DestroyNodeByIndex</a> (unsigned int _index)=0</td></tr>
<tr class="memdesc:a2005769f595ad103294a375b6287361c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy node at the given index. If no node exists at the given index, no work will be done. All children of the node will consequently be detached from the scene graph, but not destroyed.  <a href="classgz_1_1rendering_1_1Scene.html#a2005769f595ad103294a375b6287361c">More...</a><br /></td></tr>
<tr class="separator:a2005769f595ad103294a375b6287361c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe08c8fb252fad51e665838014f7248"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a2fe08c8fb252fad51e665838014f7248">DestroyNodeByName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a2fe08c8fb252fad51e665838014f7248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy node with the given name. If no node exists with the given name, no work will be done. All children of the node will consequently be detached from the scene graph, but not destroyed.  <a href="classgz_1_1rendering_1_1Scene.html#a2fe08c8fb252fad51e665838014f7248">More...</a><br /></td></tr>
<tr class="separator:a2fe08c8fb252fad51e665838014f7248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d83811f659d1b596e82406c41b736b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ae5d83811f659d1b596e82406c41b736b">DestroyNodes</a> ()=0</td></tr>
<tr class="memdesc:ae5d83811f659d1b596e82406c41b736b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy all nodes manages by this scene.  <a href="classgz_1_1rendering_1_1Scene.html#ae5d83811f659d1b596e82406c41b736b">More...</a><br /></td></tr>
<tr class="separator:ae5d83811f659d1b596e82406c41b736b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e73fda0f8201adbbd312427843dcc2c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a0e73fda0f8201adbbd312427843dcc2c">DestroySensor</a> (<a class="el" href="namespacegz_1_1rendering.html#a77e555648cdbea32e9262a478a637202">SensorPtr</a> _sensor, bool _recursive=false)=0</td></tr>
<tr class="memdesc:a0e73fda0f8201adbbd312427843dcc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy given sensor. If the given sensor is not managed by this scene, no work will be done. Depending on the _recursive argument, this function will either detach all child nodes from the scene graph or recursively destroy them.  <a href="classgz_1_1rendering_1_1Scene.html#a0e73fda0f8201adbbd312427843dcc2c">More...</a><br /></td></tr>
<tr class="separator:a0e73fda0f8201adbbd312427843dcc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa987e0622324ec7d55c035b38cd5b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a1aa987e0622324ec7d55c035b38cd5b7">DestroySensorById</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a1aa987e0622324ec7d55c035b38cd5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy sensor with the given id. If no sensor exists with the given id, no work will be done. All children of the sensor will consequently be detached from the scene graph, but not destroyed.  <a href="classgz_1_1rendering_1_1Scene.html#a1aa987e0622324ec7d55c035b38cd5b7">More...</a><br /></td></tr>
<tr class="separator:a1aa987e0622324ec7d55c035b38cd5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6d5204941d6f78a9e6c213b6415486"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#afb6d5204941d6f78a9e6c213b6415486">DestroySensorByIndex</a> (unsigned int _index)=0</td></tr>
<tr class="memdesc:afb6d5204941d6f78a9e6c213b6415486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy sensor at the given index. If no sensor exists at the given index, no work will be done. All children of the sensor will consequently be detached from the scene graph, but not destroyed.  <a href="classgz_1_1rendering_1_1Scene.html#afb6d5204941d6f78a9e6c213b6415486">More...</a><br /></td></tr>
<tr class="separator:afb6d5204941d6f78a9e6c213b6415486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2fac9beb223cb9b5dedbcb7a0a0016"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a1e2fac9beb223cb9b5dedbcb7a0a0016">DestroySensorByName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a1e2fac9beb223cb9b5dedbcb7a0a0016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy sensor with the given name. If no sensor exists with the given name, no work will be done. All children of the sensor will consequently be detached from the scene graph, but not destroyed.  <a href="classgz_1_1rendering_1_1Scene.html#a1e2fac9beb223cb9b5dedbcb7a0a0016">More...</a><br /></td></tr>
<tr class="separator:a1e2fac9beb223cb9b5dedbcb7a0a0016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e8c945a2882f458b7fbbe45d461225"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a18e8c945a2882f458b7fbbe45d461225">DestroySensors</a> ()=0</td></tr>
<tr class="memdesc:a18e8c945a2882f458b7fbbe45d461225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy all sensors manages by this scene.  <a href="classgz_1_1rendering_1_1Scene.html#a18e8c945a2882f458b7fbbe45d461225">More...</a><br /></td></tr>
<tr class="separator:a18e8c945a2882f458b7fbbe45d461225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eca4cd8d921737060405fd7996bdb92"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a9eca4cd8d921737060405fd7996bdb92">DestroyVisual</a> (<a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a> _node, bool _recursive=false)=0</td></tr>
<tr class="memdesc:a9eca4cd8d921737060405fd7996bdb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy given node. If the given node is not managed by this scene, no work will be done. Depending on the _recursive argument, this function will either detach all child nodes from the scene graph or recursively destroy them. consequently be detached from the scene graph, but not destroyed.  <a href="classgz_1_1rendering_1_1Scene.html#a9eca4cd8d921737060405fd7996bdb92">More...</a><br /></td></tr>
<tr class="separator:a9eca4cd8d921737060405fd7996bdb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5907ddd25781110ba1726528ddc234cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a5907ddd25781110ba1726528ddc234cc">DestroyVisualById</a> (unsigned int _id)=0</td></tr>
<tr class="memdesc:a5907ddd25781110ba1726528ddc234cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy node with the given id. If no node exists with the given id, no work will be done. All children of the node will consequently be detached from the scene graph, but not destroyed.  <a href="classgz_1_1rendering_1_1Scene.html#a5907ddd25781110ba1726528ddc234cc">More...</a><br /></td></tr>
<tr class="separator:a5907ddd25781110ba1726528ddc234cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee3fe9d3ac3ec2b56c5d582fccc6926"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#afee3fe9d3ac3ec2b56c5d582fccc6926">DestroyVisualByIndex</a> (unsigned int _index)=0</td></tr>
<tr class="memdesc:afee3fe9d3ac3ec2b56c5d582fccc6926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy node at the given index. If no node exists at the given index, no work will be done. All children of the node will consequently be detached from the scene graph, but not destroyed.  <a href="classgz_1_1rendering_1_1Scene.html#afee3fe9d3ac3ec2b56c5d582fccc6926">More...</a><br /></td></tr>
<tr class="separator:afee3fe9d3ac3ec2b56c5d582fccc6926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044988d036e3e7be485911d6ecfb3821"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a044988d036e3e7be485911d6ecfb3821">DestroyVisualByName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a044988d036e3e7be485911d6ecfb3821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy node with the given name. If no node exists with the given name, no work will be done. All children of the node will consequently be detached from the scene graph, but not destroyed.  <a href="classgz_1_1rendering_1_1Scene.html#a044988d036e3e7be485911d6ecfb3821">More...</a><br /></td></tr>
<tr class="separator:a044988d036e3e7be485911d6ecfb3821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d3d1877f7997bab3aa3de5244f2196"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#af7d3d1877f7997bab3aa3de5244f2196">DestroyVisuals</a> ()=0</td></tr>
<tr class="memdesc:af7d3d1877f7997bab3aa3de5244f2196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy all nodes manages by this scene.  <a href="classgz_1_1rendering_1_1Scene.html#af7d3d1877f7997bab3aa3de5244f2196">More...</a><br /></td></tr>
<tr class="separator:af7d3d1877f7997bab3aa3de5244f2196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38922be9a07a57794b9ce5d223aafb60"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgz_1_1rendering_1_1RenderEngine.html">RenderEngine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a38922be9a07a57794b9ce5d223aafb60">Engine</a> () const =0</td></tr>
<tr class="memdesc:a38922be9a07a57794b9ce5d223aafb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the creating render-engine of the scene.  <a href="classgz_1_1rendering_1_1Scene.html#a38922be9a07a57794b9ce5d223aafb60">More...</a><br /></td></tr>
<tr class="separator:a38922be9a07a57794b9ce5d223aafb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5fee34e55d20d5da6174216a33d818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgz_1_1rendering_1_1SceneExt.html">SceneExt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a8f5fee34e55d20d5da6174216a33d818">Extension</a> () const</td></tr>
<tr class="memdesc:a8f5fee34e55d20d5da6174216a33d818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get scene extention APIs This provides new <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a> APIs that are experimental.  <a href="classgz_1_1rendering_1_1Scene.html#a8f5fee34e55d20d5da6174216a33d818">More...</a><br /></td></tr>
<tr class="separator:a8f5fee34e55d20d5da6174216a33d818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ab09639dcc9875bf3814ca022c9a09"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a44ab09639dcc9875bf3814ca022c9a09">Fini</a> ()=0</td></tr>
<tr class="separator:a44ab09639dcc9875bf3814ca022c9a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3906d931128cd3b883b70aa6da2ca25"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="https://gazebosim.org/api/math/7/classgz_1_1math_1_1Color.html">math::Color</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ad3906d931128cd3b883b70aa6da2ca25">GradientBackgroundColor</a> () const =0</td></tr>
<tr class="memdesc:ad3906d931128cd3b883b70aa6da2ca25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scene gradient background color.  <a href="classgz_1_1rendering_1_1Scene.html#ad3906d931128cd3b883b70aa6da2ca25">More...</a><br /></td></tr>
<tr class="separator:ad3906d931128cd3b883b70aa6da2ca25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6d76456df0243e0409d9d437987e54"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a1f6d76456df0243e0409d9d437987e54">HasLight</a> (<a class="el" href="namespacegz_1_1rendering.html#a2be6a738363170a0a8b2d52c3acee1e0">ConstLightPtr</a> _light) const =0</td></tr>
<tr class="memdesc:a1f6d76456df0243e0409d9d437987e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the given light is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>.  <a href="classgz_1_1rendering_1_1Scene.html#a1f6d76456df0243e0409d9d437987e54">More...</a><br /></td></tr>
<tr class="separator:a1f6d76456df0243e0409d9d437987e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c97e682db693a9f4834cdd7878ea50"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ac3c97e682db693a9f4834cdd7878ea50">HasLightId</a> (unsigned int _id) const =0</td></tr>
<tr class="memdesc:ac3c97e682db693a9f4834cdd7878ea50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given light with the given id is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>.  <a href="classgz_1_1rendering_1_1Scene.html#ac3c97e682db693a9f4834cdd7878ea50">More...</a><br /></td></tr>
<tr class="separator:ac3c97e682db693a9f4834cdd7878ea50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d5fba76c4fa63c9389936c5e465e0f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a00d5fba76c4fa63c9389936c5e465e0f">HasLightName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const =0</td></tr>
<tr class="memdesc:a00d5fba76c4fa63c9389936c5e465e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given light with the given name is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>.  <a href="classgz_1_1rendering_1_1Scene.html#a00d5fba76c4fa63c9389936c5e465e0f">More...</a><br /></td></tr>
<tr class="separator:a00d5fba76c4fa63c9389936c5e465e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af378125e2c81a11e92b148e355aa183a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#af378125e2c81a11e92b148e355aa183a">HasNode</a> (<a class="el" href="namespacegz_1_1rendering.html#a50d64ba521131daafe5877c35eddfd14">ConstNodePtr</a> _node) const =0</td></tr>
<tr class="memdesc:af378125e2c81a11e92b148e355aa183a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the given node is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>.  <a href="classgz_1_1rendering_1_1Scene.html#af378125e2c81a11e92b148e355aa183a">More...</a><br /></td></tr>
<tr class="separator:af378125e2c81a11e92b148e355aa183a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c0a7a763fb453f205a5d895bac0507"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ab1c0a7a763fb453f205a5d895bac0507">HasNodeId</a> (unsigned int _id) const =0</td></tr>
<tr class="memdesc:ab1c0a7a763fb453f205a5d895bac0507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given node with the given id is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>.  <a href="classgz_1_1rendering_1_1Scene.html#ab1c0a7a763fb453f205a5d895bac0507">More...</a><br /></td></tr>
<tr class="separator:ab1c0a7a763fb453f205a5d895bac0507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc5d225da600b6a7b654239befbfa2d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a8fc5d225da600b6a7b654239befbfa2d">HasNodeName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const =0</td></tr>
<tr class="memdesc:a8fc5d225da600b6a7b654239befbfa2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given node with the given name is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>.  <a href="classgz_1_1rendering_1_1Scene.html#a8fc5d225da600b6a7b654239befbfa2d">More...</a><br /></td></tr>
<tr class="separator:a8fc5d225da600b6a7b654239befbfa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf51099d1d89e4ade0198faee86ed36f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#adf51099d1d89e4ade0198faee86ed36f">HasSensor</a> (<a class="el" href="namespacegz_1_1rendering.html#ad51570a6b8de80c8c413e29aaee29bc2">ConstSensorPtr</a> _sensor) const =0</td></tr>
<tr class="memdesc:adf51099d1d89e4ade0198faee86ed36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the given sensor is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>.  <a href="classgz_1_1rendering_1_1Scene.html#adf51099d1d89e4ade0198faee86ed36f">More...</a><br /></td></tr>
<tr class="separator:adf51099d1d89e4ade0198faee86ed36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdf4a9e46d3552995b65d6024abdf73"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a4bdf4a9e46d3552995b65d6024abdf73">HasSensorId</a> (unsigned int _id) const =0</td></tr>
<tr class="memdesc:a4bdf4a9e46d3552995b65d6024abdf73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given sensor with the given id is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>.  <a href="classgz_1_1rendering_1_1Scene.html#a4bdf4a9e46d3552995b65d6024abdf73">More...</a><br /></td></tr>
<tr class="separator:a4bdf4a9e46d3552995b65d6024abdf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e628691675e93d6d9a9011fba9b9095"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a9e628691675e93d6d9a9011fba9b9095">HasSensorName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const =0</td></tr>
<tr class="memdesc:a9e628691675e93d6d9a9011fba9b9095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given sensor with the given name is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>.  <a href="classgz_1_1rendering_1_1Scene.html#a9e628691675e93d6d9a9011fba9b9095">More...</a><br /></td></tr>
<tr class="separator:a9e628691675e93d6d9a9011fba9b9095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba97ccee81ecb5989124d36cb30b54f8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#aba97ccee81ecb5989124d36cb30b54f8">HasVisual</a> (<a class="el" href="namespacegz_1_1rendering.html#a14e3ea7e4edce7d80dae5346640eedce">ConstVisualPtr</a> _node) const =0</td></tr>
<tr class="memdesc:aba97ccee81ecb5989124d36cb30b54f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the given node is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>.  <a href="classgz_1_1rendering_1_1Scene.html#aba97ccee81ecb5989124d36cb30b54f8">More...</a><br /></td></tr>
<tr class="separator:aba97ccee81ecb5989124d36cb30b54f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d263e865330fb4f132acf3738dcbc53"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a7d263e865330fb4f132acf3738dcbc53">HasVisualId</a> (unsigned int _id) const =0</td></tr>
<tr class="memdesc:a7d263e865330fb4f132acf3738dcbc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given node with the given id is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>.  <a href="classgz_1_1rendering_1_1Scene.html#a7d263e865330fb4f132acf3738dcbc53">More...</a><br /></td></tr>
<tr class="separator:a7d263e865330fb4f132acf3738dcbc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d462fe3126c8f11b78d194ab811f47"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a64d462fe3126c8f11b78d194ab811f47">HasVisualName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const =0</td></tr>
<tr class="memdesc:a64d462fe3126c8f11b78d194ab811f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given node with the given name is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>.  <a href="classgz_1_1rendering_1_1Scene.html#a64d462fe3126c8f11b78d194ab811f47">More...</a><br /></td></tr>
<tr class="separator:a64d462fe3126c8f11b78d194ab811f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af440fd9edb16553775262ac2c5fcd315"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#af440fd9edb16553775262ac2c5fcd315">Id</a> () const =0</td></tr>
<tr class="memdesc:af440fd9edb16553775262ac2c5fcd315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of the scene.  <a href="classgz_1_1rendering_1_1Scene.html#af440fd9edb16553775262ac2c5fcd315">More...</a><br /></td></tr>
<tr class="separator:af440fd9edb16553775262ac2c5fcd315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5368a4a3fff770682cf257e81707d9f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a5368a4a3fff770682cf257e81707d9f0">Init</a> ()=0</td></tr>
<tr class="memdesc:a5368a4a3fff770682cf257e81707d9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the scene.  <a href="classgz_1_1rendering_1_1Scene.html#a5368a4a3fff770682cf257e81707d9f0">More...</a><br /></td></tr>
<tr class="separator:a5368a4a3fff770682cf257e81707d9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafccfdffdda0b6336799b8d1750de1a9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#aafccfdffdda0b6336799b8d1750de1a9">IsGradientBackgroundColor</a> () const =0</td></tr>
<tr class="memdesc:aafccfdffdda0b6336799b8d1750de1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the scene has a gradient background or not (solid)  <a href="classgz_1_1rendering_1_1Scene.html#aafccfdffdda0b6336799b8d1750de1a9">More...</a><br /></td></tr>
<tr class="separator:aafccfdffdda0b6336799b8d1750de1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56855f48547c7b7bb51324f6dc1fc6cd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a56855f48547c7b7bb51324f6dc1fc6cd">IsInitialized</a> () const =0</td></tr>
<tr class="memdesc:a56855f48547c7b7bb51324f6dc1fc6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the scene is initialized.  <a href="classgz_1_1rendering_1_1Scene.html#a56855f48547c7b7bb51324f6dc1fc6cd">More...</a><br /></td></tr>
<tr class="separator:a56855f48547c7b7bb51324f6dc1fc6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e91d08c010b57accde3d5fb1e656768"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a8e91d08c010b57accde3d5fb1e656768">LegacyAutoGpuFlush</a> () const =0</td></tr>
<tr class="memdesc:a8e91d08c010b57accde3d5fb1e656768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if SetCameraPassCountPerGpuFlush is 0.  <a href="classgz_1_1rendering_1_1Scene.html#a8e91d08c010b57accde3d5fb1e656768">More...</a><br /></td></tr>
<tr class="separator:a8e91d08c010b57accde3d5fb1e656768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9bad601997a4f5337737719e2be0ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aab8d92ebc05d82a9ae908385584c142d">LightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#acc9bad601997a4f5337737719e2be0ea">LightById</a> (unsigned int _id) const =0</td></tr>
<tr class="memdesc:acc9bad601997a4f5337737719e2be0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get light with the given id. If no light exists with the given id, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#acc9bad601997a4f5337737719e2be0ea">More...</a><br /></td></tr>
<tr class="separator:acc9bad601997a4f5337737719e2be0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a9cd0a3f2aafbeb8319e3c4ea4e64e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aab8d92ebc05d82a9ae908385584c142d">LightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a04a9cd0a3f2aafbeb8319e3c4ea4e64e">LightByIndex</a> (unsigned int _index) const =0</td></tr>
<tr class="memdesc:a04a9cd0a3f2aafbeb8319e3c4ea4e64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get light at the given index. If no light exists at the given index, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a04a9cd0a3f2aafbeb8319e3c4ea4e64e">More...</a><br /></td></tr>
<tr class="separator:a04a9cd0a3f2aafbeb8319e3c4ea4e64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad08acf97da684c3150f41c58368658"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aab8d92ebc05d82a9ae908385584c142d">LightPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#aaad08acf97da684c3150f41c58368658">LightByName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const =0</td></tr>
<tr class="memdesc:aaad08acf97da684c3150f41c58368658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get light with the given name. If no light exists with the given name, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#aaad08acf97da684c3150f41c58368658">More...</a><br /></td></tr>
<tr class="separator:aaad08acf97da684c3150f41c58368658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fba8dba1107788658743b1e2e5301a8"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a2fba8dba1107788658743b1e2e5301a8">LightCount</a> () const =0</td></tr>
<tr class="memdesc:a2fba8dba1107788658743b1e2e5301a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of lights managed by this scene. Note these lights may not be directly or indirectly attached to the root light.  <a href="classgz_1_1rendering_1_1Scene.html#a2fba8dba1107788658743b1e2e5301a8">More...</a><br /></td></tr>
<tr class="separator:a2fba8dba1107788658743b1e2e5301a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580ff46616b0657d8c1abc021a53f134"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a580ff46616b0657d8c1abc021a53f134">Load</a> ()=0</td></tr>
<tr class="memdesc:a580ff46616b0657d8c1abc021a53f134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load scene-specific resources.  <a href="classgz_1_1rendering_1_1Scene.html#a580ff46616b0657d8c1abc021a53f134">More...</a><br /></td></tr>
<tr class="separator:a580ff46616b0657d8c1abc021a53f134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2832fb86f24ded5d2291acfcbd2e513f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a2832fb86f24ded5d2291acfcbd2e513f">Material</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const =0</td></tr>
<tr class="memdesc:a2832fb86f24ded5d2291acfcbd2e513f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get material registered under the given name. If no material is registered under the given name, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a2832fb86f24ded5d2291acfcbd2e513f">More...</a><br /></td></tr>
<tr class="separator:a2832fb86f24ded5d2291acfcbd2e513f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ac4972557d384b86d5e21c27d32f77"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ac2ac4972557d384b86d5e21c27d32f77">MaterialRegistered</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const =0</td></tr>
<tr class="memdesc:ac2ac4972557d384b86d5e21c27d32f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a material is registered under the given name.  <a href="classgz_1_1rendering_1_1Scene.html#ac2ac4972557d384b86d5e21c27d32f77">More...</a><br /></td></tr>
<tr class="separator:ac2ac4972557d384b86d5e21c27d32f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ee001ce76c53aebb215a9f51653ab3"><td class="memItemLeft" align="right" valign="top">virtual <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a70ee001ce76c53aebb215a9f51653ab3">Name</a> () const =0</td></tr>
<tr class="memdesc:a70ee001ce76c53aebb215a9f51653ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the scene.  <a href="classgz_1_1rendering_1_1Scene.html#a70ee001ce76c53aebb215a9f51653ab3">More...</a><br /></td></tr>
<tr class="separator:a70ee001ce76c53aebb215a9f51653ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3038ba5e196657508d349f4ae5a15d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a5f3038ba5e196657508d349f4ae5a15d">NodeById</a> (unsigned int _id) const =0</td></tr>
<tr class="memdesc:a5f3038ba5e196657508d349f4ae5a15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node with the given id. If no node exists with the given id, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a5f3038ba5e196657508d349f4ae5a15d">More...</a><br /></td></tr>
<tr class="separator:a5f3038ba5e196657508d349f4ae5a15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade313f435ba2b5d463b5e4e0ed76e329"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ade313f435ba2b5d463b5e4e0ed76e329">NodeByIndex</a> (unsigned int _index) const =0</td></tr>
<tr class="memdesc:ade313f435ba2b5d463b5e4e0ed76e329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node at the given index. If no node exists at the given index, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ade313f435ba2b5d463b5e4e0ed76e329">More...</a><br /></td></tr>
<tr class="separator:ade313f435ba2b5d463b5e4e0ed76e329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f926d8692e658af01b1d5107d50108f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a7f926d8692e658af01b1d5107d50108f">NodeByName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const =0</td></tr>
<tr class="memdesc:a7f926d8692e658af01b1d5107d50108f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node with the given name. If no node exists with the given name, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a7f926d8692e658af01b1d5107d50108f">More...</a><br /></td></tr>
<tr class="separator:a7f926d8692e658af01b1d5107d50108f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29f5ebe4ee90af164fb8ec8f827b00c"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ad29f5ebe4ee90af164fb8ec8f827b00c">NodeCount</a> () const =0</td></tr>
<tr class="memdesc:ad29f5ebe4ee90af164fb8ec8f827b00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nodes managed by this scene. Note these nodes may not be directly or indirectly attached to the root node.  <a href="classgz_1_1rendering_1_1Scene.html#ad29f5ebe4ee90af164fb8ec8f827b00c">More...</a><br /></td></tr>
<tr class="separator:ad29f5ebe4ee90af164fb8ec8f827b00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee73a4d9fd3bca2a941038e4a5a3879d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#aee73a4d9fd3bca2a941038e4a5a3879d">PostRender</a> ()=0</td></tr>
<tr class="memdesc:aee73a4d9fd3bca2a941038e4a5a3879d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function after you're done updating ALL cameras.  <a href="classgz_1_1rendering_1_1Scene.html#aee73a4d9fd3bca2a941038e4a5a3879d">More...</a><br /></td></tr>
<tr class="separator:aee73a4d9fd3bca2a941038e4a5a3879d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffb56e0e545fefebf96b36f295396e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#adffb56e0e545fefebf96b36f295396e9">PreRender</a> ()=0</td></tr>
<tr class="memdesc:adffb56e0e545fefebf96b36f295396e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare scene for rendering. The scene will flushing any scene changes by traversing scene-graph, calling PreRender on all objects.  <a href="classgz_1_1rendering_1_1Scene.html#adffb56e0e545fefebf96b36f295396e9">More...</a><br /></td></tr>
<tr class="separator:adffb56e0e545fefebf96b36f295396e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4df8fff8d878964bebeeef399284de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a4f4df8fff8d878964bebeeef399284de">RegisterMaterial</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name, <a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a> _material)=0</td></tr>
<tr class="memdesc:a4f4df8fff8d878964bebeeef399284de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new material under the given name. If the name is already in use, no work will be done.  <a href="classgz_1_1rendering_1_1Scene.html#a4f4df8fff8d878964bebeeef399284de">More...</a><br /></td></tr>
<tr class="separator:a4f4df8fff8d878964bebeeef399284de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc623995984bdb89639154a81a2704af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#adc623995984bdb89639154a81a2704af">RemoveGradientBackgroundColor</a> ()=0</td></tr>
<tr class="memdesc:adc623995984bdb89639154a81a2704af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the scene gradient background color.  <a href="classgz_1_1rendering_1_1Scene.html#adc623995984bdb89639154a81a2704af">More...</a><br /></td></tr>
<tr class="separator:adc623995984bdb89639154a81a2704af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa097e71abf425bf91e8f159e490d8f06"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#aa097e71abf425bf91e8f159e490d8f06">RootVisual</a> () const =0</td></tr>
<tr class="memdesc:aa097e71abf425bf91e8f159e490d8f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get root <a class="el" href="classgz_1_1rendering_1_1Visual.html" title="Represents a visual node in a scene graph. A Visual is the only node that can have Geometry and other...">Visual</a> node. All nodes that are desired to be rendered in a scene should be added to this <a class="el" href="classgz_1_1rendering_1_1Visual.html" title="Represents a visual node in a scene graph. A Visual is the only node that can have Geometry and other...">Visual</a> or one of its ancestors in the scene-graph. Nodes created by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a> will not be added to the scene by default.  <a href="classgz_1_1rendering_1_1Scene.html#aa097e71abf425bf91e8f159e490d8f06">More...</a><br /></td></tr>
<tr class="separator:aa097e71abf425bf91e8f159e490d8f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06881da527f30f2f7fa458a644fb1827"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a77e555648cdbea32e9262a478a637202">SensorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a06881da527f30f2f7fa458a644fb1827">SensorById</a> (unsigned int _id) const =0</td></tr>
<tr class="memdesc:a06881da527f30f2f7fa458a644fb1827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get sensor with the given id. If no sensor exists with the given id, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a06881da527f30f2f7fa458a644fb1827">More...</a><br /></td></tr>
<tr class="separator:a06881da527f30f2f7fa458a644fb1827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390bc0bef45a73c3bee13a3a7f0461b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a77e555648cdbea32e9262a478a637202">SensorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a390bc0bef45a73c3bee13a3a7f0461b2">SensorByIndex</a> (unsigned int _index) const =0</td></tr>
<tr class="memdesc:a390bc0bef45a73c3bee13a3a7f0461b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get sensor at the given index. If no sensor exists at the given index, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a390bc0bef45a73c3bee13a3a7f0461b2">More...</a><br /></td></tr>
<tr class="separator:a390bc0bef45a73c3bee13a3a7f0461b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89203bdd8f37fdb48923f03cd1bd73a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#a77e555648cdbea32e9262a478a637202">SensorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a89203bdd8f37fdb48923f03cd1bd73a3">SensorByName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const =0</td></tr>
<tr class="memdesc:a89203bdd8f37fdb48923f03cd1bd73a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get sensor with the given name. If no sensor exists with the given name, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a89203bdd8f37fdb48923f03cd1bd73a3">More...</a><br /></td></tr>
<tr class="separator:a89203bdd8f37fdb48923f03cd1bd73a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdad64499784fd46f2fd57b0d998b3f2"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#abdad64499784fd46f2fd57b0d998b3f2">SensorCount</a> () const =0</td></tr>
<tr class="memdesc:abdad64499784fd46f2fd57b0d998b3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of sensors managed by this scene. Note these sensors may not be directly or indirectly attached to the root sensor.  <a href="classgz_1_1rendering_1_1Scene.html#abdad64499784fd46f2fd57b0d998b3f2">More...</a><br /></td></tr>
<tr class="separator:abdad64499784fd46f2fd57b0d998b3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29472d6456fd6e434f84ef2e9a929ee5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a29472d6456fd6e434f84ef2e9a929ee5">SetActiveGlobalIllumination</a> (<a class="el" href="namespacegz_1_1rendering.html#a23b8dead8c5aea88ea973f2c4cfb16e8">GlobalIlluminationBasePtr</a> _gi)=0</td></tr>
<tr class="memdesc:a29472d6456fd6e434f84ef2e9a929ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given GI as the current new active GI solution.  <a href="classgz_1_1rendering_1_1Scene.html#a29472d6456fd6e434f84ef2e9a929ee5">More...</a><br /></td></tr>
<tr class="separator:a29472d6456fd6e434f84ef2e9a929ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e4b1578ed15a0bc16d4e0508ef0daa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a69e4b1578ed15a0bc16d4e0508ef0daa">SetAmbientLight</a> (const <a class="elRef" href="https://gazebosim.org/api/math/7/classgz_1_1math_1_1Color.html">math::Color</a> &amp;_color)=0</td></tr>
<tr class="memdesc:a69e4b1578ed15a0bc16d4e0508ef0daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene ambient light color.  <a href="classgz_1_1rendering_1_1Scene.html#a69e4b1578ed15a0bc16d4e0508ef0daa">More...</a><br /></td></tr>
<tr class="separator:a69e4b1578ed15a0bc16d4e0508ef0daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f60348a73f4682a1cba96a0a25b8fd1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a8f60348a73f4682a1cba96a0a25b8fd1">SetAmbientLight</a> (double _r, double _g, double _b, double _a=1.0)=0</td></tr>
<tr class="memdesc:a8f60348a73f4682a1cba96a0a25b8fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene ambient light color.  <a href="classgz_1_1rendering_1_1Scene.html#a8f60348a73f4682a1cba96a0a25b8fd1">More...</a><br /></td></tr>
<tr class="separator:a8f60348a73f4682a1cba96a0a25b8fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0727c95811665e6f27dbce0d1d7f5426"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a0727c95811665e6f27dbce0d1d7f5426">SetBackgroundColor</a> (const <a class="elRef" href="https://gazebosim.org/api/math/7/classgz_1_1math_1_1Color.html">math::Color</a> &amp;_color)=0</td></tr>
<tr class="memdesc:a0727c95811665e6f27dbce0d1d7f5426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene background color.  <a href="classgz_1_1rendering_1_1Scene.html#a0727c95811665e6f27dbce0d1d7f5426">More...</a><br /></td></tr>
<tr class="separator:a0727c95811665e6f27dbce0d1d7f5426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a202de0928fc8a2abe9f58f0c92e93a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a3a202de0928fc8a2abe9f58f0c92e93a">SetBackgroundColor</a> (double _r, double _g, double _b, double _a=1.0)=0</td></tr>
<tr class="memdesc:a3a202de0928fc8a2abe9f58f0c92e93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene background color.  <a href="classgz_1_1rendering_1_1Scene.html#a3a202de0928fc8a2abe9f58f0c92e93a">More...</a><br /></td></tr>
<tr class="separator:a3a202de0928fc8a2abe9f58f0c92e93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d9d2c4346f6bf952debbe486ecad35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a69d9d2c4346f6bf952debbe486ecad35">SetBackgroundMaterial</a> (<a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a> _material)=0</td></tr>
<tr class="memdesc:a69d9d2c4346f6bf952debbe486ecad35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene background material e.g. a material with skybox cubemap texture.  <a href="classgz_1_1rendering_1_1Scene.html#a69d9d2c4346f6bf952debbe486ecad35">More...</a><br /></td></tr>
<tr class="separator:a69d9d2c4346f6bf952debbe486ecad35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0701d6383a2039285eaf87544b695c35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a0701d6383a2039285eaf87544b695c35">SetCameraPassCountPerGpuFlush</a> (uint8_t _numPass)=0</td></tr>
<tr class="memdesc:a0701d6383a2039285eaf87544b695c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ideal render loop is as follows:  <a href="classgz_1_1rendering_1_1Scene.html#a0701d6383a2039285eaf87544b695c35">More...</a><br /></td></tr>
<tr class="separator:a0701d6383a2039285eaf87544b695c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32f5e69f2fe4904d7810f6175cd4a32"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ad32f5e69f2fe4904d7810f6175cd4a32">SetGradientBackgroundColor</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="https://gazebosim.org/api/math/7/classgz_1_1math_1_1Color.html">math::Color</a>, 4 &gt; &amp;_colors)=0</td></tr>
<tr class="memdesc:ad32f5e69f2fe4904d7810f6175cd4a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom gradient background color on top of the regular background. Default should be black.  <a href="classgz_1_1rendering_1_1Scene.html#ad32f5e69f2fe4904d7810f6175cd4a32">More...</a><br /></td></tr>
<tr class="separator:ad32f5e69f2fe4904d7810f6175cd4a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13e23dca28e9e302925ab65662255c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ae13e23dca28e9e302925ab65662255c1">SetSkyEnabled</a> (bool _enabled)=0</td></tr>
<tr class="memdesc:ae13e23dca28e9e302925ab65662255c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable sky in the scene.  <a href="classgz_1_1rendering_1_1Scene.html#ae13e23dca28e9e302925ab65662255c1">More...</a><br /></td></tr>
<tr class="separator:ae13e23dca28e9e302925ab65662255c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a43ce3c44418e9f947b4d0eb0db0199"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a6a43ce3c44418e9f947b4d0eb0db0199">SetTime</a> (const std::chrono::steady_clock::duration &amp;_time)=0</td></tr>
<tr class="memdesc:a6a43ce3c44418e9f947b4d0eb0db0199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the last simulation update time.  <a href="classgz_1_1rendering_1_1Scene.html#a6a43ce3c44418e9f947b4d0eb0db0199">More...</a><br /></td></tr>
<tr class="separator:a6a43ce3c44418e9f947b4d0eb0db0199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058e2249f693d1b69ec98c2be23093b5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a058e2249f693d1b69ec98c2be23093b5">SkyEnabled</a> () const =0</td></tr>
<tr class="memdesc:a058e2249f693d1b69ec98c2be23093b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the sky is enabled in the scene.  <a href="classgz_1_1rendering_1_1Scene.html#a058e2249f693d1b69ec98c2be23093b5">More...</a><br /></td></tr>
<tr class="separator:a058e2249f693d1b69ec98c2be23093b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a19be4c4ee7fd7c1bc80b4e545ffbcc"><td class="memItemLeft" align="right" valign="top">virtual std::chrono::steady_clock::duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a8a19be4c4ee7fd7c1bc80b4e545ffbcc">Time</a> () const =0</td></tr>
<tr class="memdesc:a8a19be4c4ee7fd7c1bc80b4e545ffbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last simulation update time.  <a href="classgz_1_1rendering_1_1Scene.html#a8a19be4c4ee7fd7c1bc80b4e545ffbcc">More...</a><br /></td></tr>
<tr class="separator:a8a19be4c4ee7fd7c1bc80b4e545ffbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f730dc187e79e16da3d44fe908151f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a33f730dc187e79e16da3d44fe908151f">UnregisterMaterial</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name)=0</td></tr>
<tr class="memdesc:a33f730dc187e79e16da3d44fe908151f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister material registered under the given name. If no material is registered under this name, no work will be done.  <a href="classgz_1_1rendering_1_1Scene.html#a33f730dc187e79e16da3d44fe908151f">More...</a><br /></td></tr>
<tr class="separator:a33f730dc187e79e16da3d44fe908151f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8088acf3b369ac32d6c5d9ee5b08c696"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a8088acf3b369ac32d6c5d9ee5b08c696">UnregisterMaterials</a> ()=0</td></tr>
<tr class="memdesc:a8088acf3b369ac32d6c5d9ee5b08c696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister all registered materials.  <a href="classgz_1_1rendering_1_1Scene.html#a8088acf3b369ac32d6c5d9ee5b08c696">More...</a><br /></td></tr>
<tr class="separator:a8088acf3b369ac32d6c5d9ee5b08c696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9601bb7b20f4c35fc3e4f1f1d1fb2177"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a9601bb7b20f4c35fc3e4f1f1d1fb2177">VisualAt</a> (const <a class="el" href="namespacegz_1_1rendering.html#afc9577975b8c7e847de55c43bd5798c0">CameraPtr</a> &amp;_camera, const <a class="elRef" href="https://gazebosim.org/api/math/7/namespacegz_1_1math.html#aa83d444bd6cbecb112158663c2e0c213">math::Vector2i</a> &amp;_mousePos)=0</td></tr>
<tr class="memdesc:a9601bb7b20f4c35fc3e4f1f1d1fb2177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a visual at a mouse position.  <a href="classgz_1_1rendering_1_1Scene.html#a9601bb7b20f4c35fc3e4f1f1d1fb2177">More...</a><br /></td></tr>
<tr class="separator:a9601bb7b20f4c35fc3e4f1f1d1fb2177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26f4ffd95711ec7ad2a3f88628e1263"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ad26f4ffd95711ec7ad2a3f88628e1263">VisualById</a> (unsigned int _id) const =0</td></tr>
<tr class="memdesc:ad26f4ffd95711ec7ad2a3f88628e1263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node with the given id. If no node exists with the given id, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#ad26f4ffd95711ec7ad2a3f88628e1263">More...</a><br /></td></tr>
<tr class="separator:ad26f4ffd95711ec7ad2a3f88628e1263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef00ef77d31095ad8721d54f9dfa0a39"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#aef00ef77d31095ad8721d54f9dfa0a39">VisualByIndex</a> (unsigned int _index) const =0</td></tr>
<tr class="memdesc:aef00ef77d31095ad8721d54f9dfa0a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node at the given index. If no node exists at the given index, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#aef00ef77d31095ad8721d54f9dfa0a39">More...</a><br /></td></tr>
<tr class="separator:aef00ef77d31095ad8721d54f9dfa0a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a59b54760d857f55e47395a88781c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#a74a59b54760d857f55e47395a88781c1">VisualByName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const =0</td></tr>
<tr class="memdesc:a74a59b54760d857f55e47395a88781c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node with the given name. If no node exists with the given name, NULL will be returned.  <a href="classgz_1_1rendering_1_1Scene.html#a74a59b54760d857f55e47395a88781c1">More...</a><br /></td></tr>
<tr class="separator:a74a59b54760d857f55e47395a88781c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde82125babccfb3d6572980b7b40ce5"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#abde82125babccfb3d6572980b7b40ce5">VisualCount</a> () const =0</td></tr>
<tr class="memdesc:abde82125babccfb3d6572980b7b40ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nodes managed by this scene. Note these nodes may not be directly or indirectly attached to the root node.  <a href="classgz_1_1rendering_1_1Scene.html#abde82125babccfb3d6572980b7b40ce5">More...</a><br /></td></tr>
<tr class="separator:abde82125babccfb3d6572980b7b40ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac80bc8c3242a5c91a6ccc979a5d0f43a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1rendering_1_1Scene.html#ac80bc8c3242a5c91a6ccc979a5d0f43a">SetExtension</a> (<a class="el" href="classgz_1_1rendering_1_1SceneExt.html">SceneExt</a> *_ext)</td></tr>
<tr class="memdesc:ac80bc8c3242a5c91a6ccc979a5d0f43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scene extention API This is called by underlying render engines.  <a href="classgz_1_1rendering_1_1Scene.html#ac80bc8c3242a5c91a6ccc979a5d0f43a">More...</a><br /></td></tr>
<tr class="separator:ac80bc8c3242a5c91a6ccc979a5d0f43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node. A <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a> also serves as a factory for all scene objects. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac3b8d7a28a38493f69a0fd09f5f315cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b8d7a28a38493f69a0fd09f5f315cf">&#9670;&nbsp;</a></span>~Scene()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classgz_1_1rendering_1_1Scene.html">Scene</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a032cd71ad4781243fec7c0ce096a2e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032cd71ad4781243fec7c0ce096a2e95">&#9670;&nbsp;</a></span>AmbientLight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="elRef" href="https://gazebosim.org/api/math/7/classgz_1_1math_1_1Color.html">math::Color</a> AmbientLight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scene ambient light color. </p>
<dl class="section return"><dt>Returns</dt><dd>The scene ambient light color </dd></dl>

</div>
</div>
<a id="a26091dd2571ab2486ec8cb9b535db1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26091dd2571ab2486ec8cb9b535db1bd">&#9670;&nbsp;</a></span>BackgroundColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="elRef" href="https://gazebosim.org/api/math/7/classgz_1_1math_1_1Color.html">math::Color</a> BackgroundColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scene background color. </p>
<dl class="section return"><dt>Returns</dt><dd>The scene background color </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseRenderTarget.html#ab0fd24679d0e9d4c7f2f3ff6a0e10a98">BaseRenderTarget&lt; T &gt;::BackgroundColor()</a>.</p>

</div>
</div>
<a id="a56c9a9bf549a44b5bd202f6351d02a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c9a9bf549a44b5bd202f6351d02a4e">&#9670;&nbsp;</a></span>BackgroundMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a> BackgroundMaterial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scene background material e.g. a material with skybox cubemap texture. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgz_1_1rendering_1_1Material.html" title="Represents a surface material of a Geometry.">Material</a> of the background </dd></dl>

</div>
</div>
<a id="a3fb5f45578bcf3643147fba7c19ff380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb5f45578bcf3643147fba7c19ff380">&#9670;&nbsp;</a></span>CameraPassCountPerGpuFlush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint8_t CameraPassCountPerGpuFlush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value set in SetCameraPassCountPerGpuFlush. </p>
<dl class="section return"><dt>Returns</dt><dd>Value in range [0; 255]. ALWAYS returns 0 for plugins that ignore SetCameraPassCountPerGpuFlush </dd></dl>

</div>
</div>
<a id="aa5b31c976cc6734003d9950e731dfed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b31c976cc6734003d9950e731dfed3">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove and destroy all objects from the scene graph. This does not completely destroy scene resources, so new objects can be created and added to the scene afterwards. </p>

</div>
</div>
<a id="ac47444f2cc9809d61d2a0514186cb97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47444f2cc9809d61d2a0514186cb97b">&#9670;&nbsp;</a></span>CreateArrowVisual() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aae53901524397bca9d27f8767c8b2f14">ArrowVisualPtr</a> CreateArrowVisual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new arrow visual. A unique ID and name will automatically be assigned to the visual. </p>
<dl class="section return"><dt>Returns</dt><dd>The created arrow visual </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseJointVisual.html#a875c28ac9622dc12eae213a13a171901">BaseJointVisual&lt; T &gt;::CreateAxis()</a>, and <a class="el" href="classgz_1_1rendering_1_1BaseAxisVisual.html#a47de93e849d14c3eda08d78613506608">BaseAxisVisual&lt; T &gt;::Init()</a>.</p>

</div>
</div>
<a id="a4e401c88d214de1754c77f78fc225626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e401c88d214de1754c77f78fc225626">&#9670;&nbsp;</a></span>CreateArrowVisual() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aae53901524397bca9d27f8767c8b2f14">ArrowVisualPtr</a> CreateArrowVisual </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new arrow visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new arrow visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created arrow visual </dd></dl>

</div>
</div>
<a id="acaf2259ff68acb864ba01403821875cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf2259ff68acb864ba01403821875cf">&#9670;&nbsp;</a></span>CreateArrowVisual() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aae53901524397bca9d27f8767c8b2f14">ArrowVisualPtr</a> CreateArrowVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new arrow visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new arrow visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created arrow visual </dd></dl>

</div>
</div>
<a id="ae04895c0d67840a5d2cbdea4189c3aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04895c0d67840a5d2cbdea4189c3aad">&#9670;&nbsp;</a></span>CreateArrowVisual() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aae53901524397bca9d27f8767c8b2f14">ArrowVisualPtr</a> CreateArrowVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new arrow visual with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new arrow visual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new arrow visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created arrow visual </dd></dl>

</div>
</div>
<a id="a9f2479dfec039650a448bec7742535ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2479dfec039650a448bec7742535ee">&#9670;&nbsp;</a></span>CreateAxisVisual() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a3d226d80e377750d4840fe874717138e">AxisVisualPtr</a> CreateAxisVisual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new axis visual. A unique ID and name will automatically be assigned to the visual. </p>
<dl class="section return"><dt>Returns</dt><dd>The created axis visual </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseJointVisual.html#a47de93e849d14c3eda08d78613506608">BaseJointVisual&lt; T &gt;::Init()</a>.</p>

</div>
</div>
<a id="a2eaa6002ad639283ee923ee25444c7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eaa6002ad639283ee923ee25444c7c0">&#9670;&nbsp;</a></span>CreateAxisVisual() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a3d226d80e377750d4840fe874717138e">AxisVisualPtr</a> CreateAxisVisual </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new axis visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new axis visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created axis visual </dd></dl>

</div>
</div>
<a id="ab72407fecec75409c5e80ca7aa6d8585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72407fecec75409c5e80ca7aa6d8585">&#9670;&nbsp;</a></span>CreateAxisVisual() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a3d226d80e377750d4840fe874717138e">AxisVisualPtr</a> CreateAxisVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new axis visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new axis visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created axis visual </dd></dl>

</div>
</div>
<a id="a4d652d648d296eb72eb0a2914c56520b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d652d648d296eb72eb0a2914c56520b">&#9670;&nbsp;</a></span>CreateAxisVisual() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a3d226d80e377750d4840fe874717138e">AxisVisualPtr</a> CreateAxisVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new axis visual with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new axis visual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new axis visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created axis visual </dd></dl>

</div>
</div>
<a id="a5de4ede39964b6dba14ff15297b585ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de4ede39964b6dba14ff15297b585ad">&#9670;&nbsp;</a></span>CreateBoundingBoxCamera() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a3b5bc8e4ba8d97749293280ab8e132e8">BoundingBoxCameraPtr</a> CreateBoundingBoxCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new <a class="el" href="classgz_1_1rendering_1_1BoundingBox.html" title="2D or 3D Bounding box. It stores the position / orientation / size info of the box and its label">BoundingBox</a> camera. A unique ID and name will automatically be assigned to the camera. </p>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a39fe131b541689621129ea70c86c2bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fe131b541689621129ea70c86c2bc4">&#9670;&nbsp;</a></span>CreateBoundingBoxCamera() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a3b5bc8e4ba8d97749293280ab8e132e8">BoundingBoxCameraPtr</a> CreateBoundingBoxCamera </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new <a class="el" href="classgz_1_1rendering_1_1BoundingBox.html" title="2D or 3D Bounding box. It stores the position / orientation / size info of the box and its label">BoundingBox</a> camera with the given name. A unique ID will automatically be assigned to the camera. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="abcdb4d53c11c79910e55c2819b981184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdb4d53c11c79910e55c2819b981184">&#9670;&nbsp;</a></span>CreateBoundingBoxCamera() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a3b5bc8e4ba8d97749293280ab8e132e8">BoundingBoxCameraPtr</a> CreateBoundingBoxCamera </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new <a class="el" href="classgz_1_1rendering_1_1BoundingBox.html" title="2D or 3D Bounding box. It stores the position / orientation / size info of the box and its label">BoundingBox</a> camera with the given ID. A unique name will automatically be assigned to the camera. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a99600311cab824134d03a34a5fbd5e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99600311cab824134d03a34a5fbd5e72">&#9670;&nbsp;</a></span>CreateBoundingBoxCamera() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a3b5bc8e4ba8d97749293280ab8e132e8">BoundingBoxCameraPtr</a> CreateBoundingBoxCamera </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new <a class="el" href="classgz_1_1rendering_1_1BoundingBox.html" title="2D or 3D Bounding box. It stores the position / orientation / size info of the box and its label">BoundingBox</a> camera with the given ID &amp; name. If either the given ID or name is already in use, will return NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new camera </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a674b7d2bb813ff47bac2c583b33a1f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674b7d2bb813ff47bac2c583b33a1f3e">&#9670;&nbsp;</a></span>CreateBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a32bd50043028477c50f07cce13213556">GeometryPtr</a> CreateBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new box geometry. </p>
<dl class="section return"><dt>Returns</dt><dd>The created box </dd></dl>

</div>
</div>
<a id="a3271c911d48de8063145ccc3a5e9dc8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3271c911d48de8063145ccc3a5e9dc8c">&#9670;&nbsp;</a></span>CreateCamera() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#afc9577975b8c7e847de55c43bd5798c0">CameraPtr</a> CreateCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new camera. A unique ID and name will automatically be assigned to the camera. </p>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="ab2397042a56eb7c0e2e5aff1ab35552d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2397042a56eb7c0e2e5aff1ab35552d">&#9670;&nbsp;</a></span>CreateCamera() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#afc9577975b8c7e847de55c43bd5798c0">CameraPtr</a> CreateCamera </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new camera with the given name. A unique ID will automatically be assigned to the camera. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="ab7b4dc991920167dbea3d347aec18371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b4dc991920167dbea3d347aec18371">&#9670;&nbsp;</a></span>CreateCamera() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#afc9577975b8c7e847de55c43bd5798c0">CameraPtr</a> CreateCamera </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new camera with the given ID. A unique name will automatically be assigned to the camera. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a30f273f230c2927c7dd73f881747649f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f273f230c2927c7dd73f881747649f">&#9670;&nbsp;</a></span>CreateCamera() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#afc9577975b8c7e847de55c43bd5798c0">CameraPtr</a> CreateCamera </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new camera with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new camera </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="adfe24cea72806676e08008cd1b3c2ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe24cea72806676e08008cd1b3c2ec1">&#9670;&nbsp;</a></span>CreateCapsule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a249ca83f5d8ea47506727cbb44d14aa9">CapsulePtr</a> CreateCapsule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new capsule geometry. </p>
<dl class="section return"><dt>Returns</dt><dd>The created capsule </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseCapsule.html#a300602d913a85496df902b50fcbe884f">BaseCapsule&lt; T &gt;::Clone()</a>.</p>

</div>
</div>
<a id="a542098817d87ca595712fbd3898f9c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542098817d87ca595712fbd3898f9c26">&#9670;&nbsp;</a></span>CreateCOMVisual() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aeeb897b4ec5b5c14ed9556b94c82cd17">COMVisualPtr</a> CreateCOMVisual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new CoM visual. A unique ID and name will automatically be assigned to the CoM visual. </p>
<dl class="section return"><dt>Returns</dt><dd>The created CoM visual </dd></dl>

</div>
</div>
<a id="a2ded0a6b615968a4413ce83eb8459d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ded0a6b615968a4413ce83eb8459d4b">&#9670;&nbsp;</a></span>CreateCOMVisual() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aeeb897b4ec5b5c14ed9556b94c82cd17">COMVisualPtr</a> CreateCOMVisual </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new CoM visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new CoM visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created CoM visual </dd></dl>

</div>
</div>
<a id="ad0246623f4b4716bd2674001c9fd88fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0246623f4b4716bd2674001c9fd88fc">&#9670;&nbsp;</a></span>CreateCOMVisual() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aeeb897b4ec5b5c14ed9556b94c82cd17">COMVisualPtr</a> CreateCOMVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new CoM visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new CoM visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created CoM visual </dd></dl>

</div>
</div>
<a id="ae6a3370206d3d859ab8797fc8aef5434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a3370206d3d859ab8797fc8aef5434">&#9670;&nbsp;</a></span>CreateCOMVisual() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aeeb897b4ec5b5c14ed9556b94c82cd17">COMVisualPtr</a> CreateCOMVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new CoM visual with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new CoM visual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new CoM visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created CoM visual </dd></dl>

</div>
</div>
<a id="a224c8301e4981bb95f66f510c396a4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224c8301e4981bb95f66f510c396a4e2">&#9670;&nbsp;</a></span>CreateCone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a32bd50043028477c50f07cce13213556">GeometryPtr</a> CreateCone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new cone geometry. </p>
<dl class="section return"><dt>Returns</dt><dd>The created cone </dd></dl>

</div>
</div>
<a id="afd457431115e80e2d7a95b6edb1ee818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd457431115e80e2d7a95b6edb1ee818">&#9670;&nbsp;</a></span>CreateCylinder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a32bd50043028477c50f07cce13213556">GeometryPtr</a> CreateCylinder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new cylinder geometry. </p>
<dl class="section return"><dt>Returns</dt><dd>The created cylinder </dd></dl>

</div>
</div>
<a id="a45a0db3e251219a719244933100a7830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a0db3e251219a719244933100a7830">&#9670;&nbsp;</a></span>CreateDepthCamera() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a7b7291d7f5d3bc1ee846763b2e7429a5">DepthCameraPtr</a> CreateDepthCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new depth camera. A unique ID and name will automatically be assigned to the camera. </p>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a8ddb7c78e8b624ed92f00ede9a93bffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddb7c78e8b624ed92f00ede9a93bffc">&#9670;&nbsp;</a></span>CreateDepthCamera() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a7b7291d7f5d3bc1ee846763b2e7429a5">DepthCameraPtr</a> CreateDepthCamera </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new depth camera with the given name. A unique ID will automatically be assigned to the camera. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a140a666d886fd28ee93b73d483ed6e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140a666d886fd28ee93b73d483ed6e11">&#9670;&nbsp;</a></span>CreateDepthCamera() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a7b7291d7f5d3bc1ee846763b2e7429a5">DepthCameraPtr</a> CreateDepthCamera </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new depth camera with the given ID. A unique name will automatically be assigned to the camera. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="ae6c38b2a9e0da6ed42144a4f0110b4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c38b2a9e0da6ed42144a4f0110b4e2">&#9670;&nbsp;</a></span>CreateDepthCamera() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a7b7291d7f5d3bc1ee846763b2e7429a5">DepthCameraPtr</a> CreateDepthCamera </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new depth camera with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new camera </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="ac473e7c03d9d8c53da614d8530ebcb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac473e7c03d9d8c53da614d8530ebcb24">&#9670;&nbsp;</a></span>CreateDirectionalLight() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#abcafeecad84375cb761b8f4c0a4408c0">DirectionalLightPtr</a> CreateDirectionalLight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new directional light. A unique ID and name will automatically be assigned to the light. </p>
<dl class="section return"><dt>Returns</dt><dd>The created light </dd></dl>

</div>
</div>
<a id="a067004fac837a1d43bb2724cc254fefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067004fac837a1d43bb2724cc254fefa">&#9670;&nbsp;</a></span>CreateDirectionalLight() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#abcafeecad84375cb761b8f4c0a4408c0">DirectionalLightPtr</a> CreateDirectionalLight </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new directional light with the given name. A unique ID will automatically be assigned to the light. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light </dd></dl>

</div>
</div>
<a id="a1c660fc522f33afbac24e6120294afff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c660fc522f33afbac24e6120294afff">&#9670;&nbsp;</a></span>CreateDirectionalLight() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#abcafeecad84375cb761b8f4c0a4408c0">DirectionalLightPtr</a> CreateDirectionalLight </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new directional light with the given ID. A unique name will automatically be assigned to the light. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light </dd></dl>

</div>
</div>
<a id="acd59d3693981d6fd538f3c1268b62ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd59d3693981d6fd538f3c1268b62ab6">&#9670;&nbsp;</a></span>CreateDirectionalLight() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#abcafeecad84375cb761b8f4c0a4408c0">DirectionalLightPtr</a> CreateDirectionalLight </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new directional light with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new light </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light </dd></dl>

</div>
</div>
<a id="add47771718e396140697ecc916fc72bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add47771718e396140697ecc916fc72bd">&#9670;&nbsp;</a></span>CreateGizmoVisual() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ab386d61975c3cdfb0497cf958ee3506a">GizmoVisualPtr</a> CreateGizmoVisual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new gizmo visual. A unique ID and name will automatically be assigned to the visual. </p>
<dl class="section return"><dt>Returns</dt><dd>The created gizmo visual </dd></dl>

</div>
</div>
<a id="a966de3642e0847870d890dc75050dacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966de3642e0847870d890dc75050dacf">&#9670;&nbsp;</a></span>CreateGizmoVisual() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ab386d61975c3cdfb0497cf958ee3506a">GizmoVisualPtr</a> CreateGizmoVisual </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new gizmo visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new gizmo visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created gizmo visual </dd></dl>

</div>
</div>
<a id="ab4f5e0d29d825cd9052b825cb7aba8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f5e0d29d825cd9052b825cb7aba8cb">&#9670;&nbsp;</a></span>CreateGizmoVisual() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ab386d61975c3cdfb0497cf958ee3506a">GizmoVisualPtr</a> CreateGizmoVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new gizmo visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new gizmo visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created gizmo visual </dd></dl>

</div>
</div>
<a id="a13c97548c380222d1bcc3a1f755c667b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c97548c380222d1bcc3a1f755c667b">&#9670;&nbsp;</a></span>CreateGizmoVisual() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ab386d61975c3cdfb0497cf958ee3506a">GizmoVisualPtr</a> CreateGizmoVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new gizmo visual with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new gizmo visual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new gizmo visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created gizmo visual </dd></dl>

</div>
</div>
<a id="a0ddac29100802d367108ded04c4fbb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddac29100802d367108ded04c4fbb0f">&#9670;&nbsp;</a></span>CreateGlobalIlluminationCiVct() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a9783b44dbd5dbc068fee5f484113ccf1">GlobalIlluminationCiVctPtr</a> CreateGlobalIlluminationCiVct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new GI CIVCT solution with the given name. A unique ID and name will automatically be assigned to the GI. </p>
<dl class="section return"><dt>Returns</dt><dd>The created GI CIVCT </dd></dl>

</div>
</div>
<a id="a065953d88546991b0470b3cdf63ec270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065953d88546991b0470b3cdf63ec270">&#9670;&nbsp;</a></span>CreateGlobalIlluminationCiVct() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a9783b44dbd5dbc068fee5f484113ccf1">GlobalIlluminationCiVctPtr</a> CreateGlobalIlluminationCiVct </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new GI CIVCT solution with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new GI CIVCT solution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created GI CIVCT </dd></dl>

</div>
</div>
<a id="a1423405af3cdc860ef3af3909323efcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1423405af3cdc860ef3af3909323efcc">&#9670;&nbsp;</a></span>CreateGlobalIlluminationCiVct() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a9783b44dbd5dbc068fee5f484113ccf1">GlobalIlluminationCiVctPtr</a> CreateGlobalIlluminationCiVct </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new GI CIVCT solution with the given name. A unique name will automatically be assigned to the GI. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new particle emitter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created GI CIVCT </dd></dl>

</div>
</div>
<a id="a958ce4df212fd983ea7b36de7458f871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958ce4df212fd983ea7b36de7458f871">&#9670;&nbsp;</a></span>CreateGlobalIlluminationCiVct() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a9783b44dbd5dbc068fee5f484113ccf1">GlobalIlluminationCiVctPtr</a> CreateGlobalIlluminationCiVct </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new GI CIVCT solution with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new particle emitter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new GI CIVCT solution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created GI CIVCT </dd></dl>

</div>
</div>
<a id="a5f59d725ed2ae66ab8018ed94c71f4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f59d725ed2ae66ab8018ed94c71f4ac">&#9670;&nbsp;</a></span>CreateGlobalIlluminationVct() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a92c9876994a02318c67d81cb77455a97">GlobalIlluminationVctPtr</a> CreateGlobalIlluminationVct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new GI VCT solution with the given name. A unique ID and name will automatically be assigned to the GI. </p>
<dl class="section return"><dt>Returns</dt><dd>The created GI VCT </dd></dl>

</div>
</div>
<a id="af31d239fbec297cadbcb3f160785017c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31d239fbec297cadbcb3f160785017c">&#9670;&nbsp;</a></span>CreateGlobalIlluminationVct() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a92c9876994a02318c67d81cb77455a97">GlobalIlluminationVctPtr</a> CreateGlobalIlluminationVct </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new GI VCT solution with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new GI VCT solution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created GI VCT </dd></dl>

</div>
</div>
<a id="a1542d612505423514e1621c1c0876618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1542d612505423514e1621c1c0876618">&#9670;&nbsp;</a></span>CreateGlobalIlluminationVct() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a92c9876994a02318c67d81cb77455a97">GlobalIlluminationVctPtr</a> CreateGlobalIlluminationVct </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new GI VCT solution with the given name. A unique name will automatically be assigned to the GI. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new particle emitter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created GI VCT </dd></dl>

</div>
</div>
<a id="aa3cf58227c7fc064742c89529d121e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cf58227c7fc064742c89529d121e7a">&#9670;&nbsp;</a></span>CreateGlobalIlluminationVct() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a92c9876994a02318c67d81cb77455a97">GlobalIlluminationVctPtr</a> CreateGlobalIlluminationVct </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new GI VCT solution with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new particle emitter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new GI VCT solution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created GI VCT </dd></dl>

</div>
</div>
<a id="abff2ece2800797fb42b865104fa9ff69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff2ece2800797fb42b865104fa9ff69">&#9670;&nbsp;</a></span>CreateGpuRays() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a5cd9e1e8200c513d17d316275be327c7">GpuRaysPtr</a> CreateGpuRays </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new gpu rays caster. A unique ID and name will automatically be assigned to the gpu rays caster. </p>
<dl class="section return"><dt>Returns</dt><dd>The created gpu rays caster </dd></dl>

</div>
</div>
<a id="ac1255f04d0569fa406b96981d220544c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1255f04d0569fa406b96981d220544c">&#9670;&nbsp;</a></span>CreateGpuRays() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a5cd9e1e8200c513d17d316275be327c7">GpuRaysPtr</a> CreateGpuRays </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new gpu rays caster with the given name. A unique ID will automatically be assigned to the gpu rays caster. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new gpu rays caster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created gpu ray caster </dd></dl>

</div>
</div>
<a id="a2b23beb5255b2f225be60bb1ea3ba69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b23beb5255b2f225be60bb1ea3ba69e">&#9670;&nbsp;</a></span>CreateGpuRays() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a5cd9e1e8200c513d17d316275be327c7">GpuRaysPtr</a> CreateGpuRays </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new gpu rays caster with the given ID. A unique name will automatically be assigned to the gpu rays caster. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new gpu rays caster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created gpu rays caster </dd></dl>

</div>
</div>
<a id="a3c5d6b09b51a23adde71204dbbd66b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5d6b09b51a23adde71204dbbd66b63">&#9670;&nbsp;</a></span>CreateGpuRays() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a5cd9e1e8200c513d17d316275be327c7">GpuRaysPtr</a> CreateGpuRays </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new gpu rays caster with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the gpu ray caster </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new gpu ray caster </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created Gpu ray caster </dd></dl>

</div>
</div>
<a id="a8fb59ed9f5259b8b97e9e7c5350c93b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb59ed9f5259b8b97e9e7c5350c93b4">&#9670;&nbsp;</a></span>CreateGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aec68c97392cdf9868b01fc8019f2bde5">GridPtr</a> CreateGrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new grid geometry. </p>
<dl class="section return"><dt>Returns</dt><dd>The created grid </dd></dl>

</div>
</div>
<a id="ac738be7b9bd7e8f6a65312f1db5c3d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac738be7b9bd7e8f6a65312f1db5c3d77">&#9670;&nbsp;</a></span>CreateHeightmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ad3d1141383b742e878ecca6f7a3b7241">HeightmapPtr</a> CreateHeightmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1rendering_1_1HeightmapDescriptor.html">HeightmapDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>_desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new heightmap geomerty. The <a class="el" href="classgz_1_1rendering_1_1Heightmap.html" title="A terrain defined by a heightfield.">rendering::Heightmap</a> will be created from the given <a class="el" href="classgz_1_1rendering_1_1HeightmapDescriptor.html" title="Describes how a Heightmap should be loaded.">HeightmapDescriptor</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_desc</td><td>Data about the heightmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created heightmap </dd></dl>

</div>
</div>
<a id="a8a4412aa5a2875f6e4968eac5cec83f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4412aa5a2875f6e4968eac5cec83f0">&#9670;&nbsp;</a></span>CreateInertiaVisual() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#affa41870d5eec126b03e9c2ad6159b49">InertiaVisualPtr</a> CreateInertiaVisual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new inertia visual. A unique ID and name will automatically be assigned to the inertia visual. </p>
<dl class="section return"><dt>Returns</dt><dd>The created inertia visual </dd></dl>

</div>
</div>
<a id="a494e49555b4577c99f6bf10efa3b4c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494e49555b4577c99f6bf10efa3b4c06">&#9670;&nbsp;</a></span>CreateInertiaVisual() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#affa41870d5eec126b03e9c2ad6159b49">InertiaVisualPtr</a> CreateInertiaVisual </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new inertia visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new inertia visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light visual </dd></dl>

</div>
</div>
<a id="a4b8d1486642842e0d3924462aa1ef6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8d1486642842e0d3924462aa1ef6c5">&#9670;&nbsp;</a></span>CreateInertiaVisual() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#affa41870d5eec126b03e9c2ad6159b49">InertiaVisualPtr</a> CreateInertiaVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new inertia visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new inertia visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light visual </dd></dl>

</div>
</div>
<a id="a32b07f46a791ad9aca937f6e8c86b6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b07f46a791ad9aca937f6e8c86b6e2">&#9670;&nbsp;</a></span>CreateInertiaVisual() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#affa41870d5eec126b03e9c2ad6159b49">InertiaVisualPtr</a> CreateInertiaVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new inertia visual with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new inertia visual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new inertia visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created inertia visual </dd></dl>

</div>
</div>
<a id="ae888f922784d704fe63104ea24f7d575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae888f922784d704fe63104ea24f7d575">&#9670;&nbsp;</a></span>CreateJointVisual() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a5ce81676c62a4aa3e7fa798d42aafb43">JointVisualPtr</a> CreateJointVisual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new joint visual. A unique ID and name will automatically be assigned to the Joint visual. </p>
<dl class="section return"><dt>Returns</dt><dd>The created Joint visual </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseJointVisual.html#a5444c90c26804ca0b7440a87cd1793f3">BaseJointVisual&lt; T &gt;::CreateParentAxis()</a>.</p>

</div>
</div>
<a id="ad1e25a6cdc667d559470387a778f9e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e25a6cdc667d559470387a778f9e8f">&#9670;&nbsp;</a></span>CreateJointVisual() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a5ce81676c62a4aa3e7fa798d42aafb43">JointVisualPtr</a> CreateJointVisual </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new joint visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new Joint visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created Joint visual </dd></dl>

</div>
</div>
<a id="aaad626bfba7452b370b47ab45a159b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad626bfba7452b370b47ab45a159b67">&#9670;&nbsp;</a></span>CreateJointVisual() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a5ce81676c62a4aa3e7fa798d42aafb43">JointVisualPtr</a> CreateJointVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new joint visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new Joint visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created Joint visual </dd></dl>

</div>
</div>
<a id="a8afc714d06df598f9a2866845fe36463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afc714d06df598f9a2866845fe36463">&#9670;&nbsp;</a></span>CreateJointVisual() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a5ce81676c62a4aa3e7fa798d42aafb43">JointVisualPtr</a> CreateJointVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new joint visual with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new Joint visual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new Joint visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created Joint visual </dd></dl>

</div>
</div>
<a id="ac4611826d5400620d8ea432e05f8c557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4611826d5400620d8ea432e05f8c557">&#9670;&nbsp;</a></span>CreateLidarVisual() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a0e3864bc06f90fba2169f71c3994b41c">LidarVisualPtr</a> CreateLidarVisual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new lidar visual. A unique ID and name will automatically be assigned to the lidar visual. </p>
<dl class="section return"><dt>Returns</dt><dd>The created lidar visual </dd></dl>

</div>
</div>
<a id="ad85c942b92fa59258e30f4641d592a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85c942b92fa59258e30f4641d592a8d">&#9670;&nbsp;</a></span>CreateLidarVisual() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a0e3864bc06f90fba2169f71c3994b41c">LidarVisualPtr</a> CreateLidarVisual </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new lidar visual with the given name. A unique ID will automatically be assigned to the lidar visual. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new lidar visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created lidar visual </dd></dl>

</div>
</div>
<a id="a5ffd4a655874b1ba65f267386cc1d1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffd4a655874b1ba65f267386cc1d1b6">&#9670;&nbsp;</a></span>CreateLidarVisual() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a0e3864bc06f90fba2169f71c3994b41c">LidarVisualPtr</a> CreateLidarVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new lidar visual with the given ID. A unique name will automatically be assigned to the lidar visual. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new lidar visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created lidar visual </dd></dl>

</div>
</div>
<a id="a87dfc9ab95851f4e8d6e05d4a0c6b903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87dfc9ab95851f4e8d6e05d4a0c6b903">&#9670;&nbsp;</a></span>CreateLidarVisual() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a0e3864bc06f90fba2169f71c3994b41c">LidarVisualPtr</a> CreateLidarVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new lidar visual with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the lidar visual. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new lidar visual. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created lidar visual </dd></dl>

</div>
</div>
<a id="af739005a2a537d6b3735bb88ad3f875e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af739005a2a537d6b3735bb88ad3f875e">&#9670;&nbsp;</a></span>CreateLightVisual() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ad789d3fba9cba5e0531dac9bf0d5dad2">LightVisualPtr</a> CreateLightVisual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new light visual. A unique ID and name will automatically be assigned to the light visual. </p>
<dl class="section return"><dt>Returns</dt><dd>The created light visual </dd></dl>

</div>
</div>
<a id="a62d7d6bf6cf97ad34919fbcf0af105aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d7d6bf6cf97ad34919fbcf0af105aa">&#9670;&nbsp;</a></span>CreateLightVisual() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ad789d3fba9cba5e0531dac9bf0d5dad2">LightVisualPtr</a> CreateLightVisual </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new light visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new light visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light visual </dd></dl>

</div>
</div>
<a id="a7af929c8afb2dd3621c7389cf92b1707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af929c8afb2dd3621c7389cf92b1707">&#9670;&nbsp;</a></span>CreateLightVisual() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ad789d3fba9cba5e0531dac9bf0d5dad2">LightVisualPtr</a> CreateLightVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new light visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new light visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light visual </dd></dl>

</div>
</div>
<a id="a478a8fc34d535708cae43cddea9ece8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478a8fc34d535708cae43cddea9ece8c">&#9670;&nbsp;</a></span>CreateLightVisual() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ad789d3fba9cba5e0531dac9bf0d5dad2">LightVisualPtr</a> CreateLightVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new light visual with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new light visual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new light visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light visual </dd></dl>

</div>
</div>
<a id="a9219869f051a6ad686e24b247089a7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9219869f051a6ad686e24b247089a7b0">&#9670;&nbsp;</a></span>CreateMarker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a5b784cf4efcbc71f4fb19e3009fc4a80">MarkerPtr</a> CreateMarker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new marker geometry. </p>
<dl class="section return"><dt>Returns</dt><dd>The created marker </dd></dl>

</div>
</div>
<a id="aa87f5382faf14f231fa55ff84c9e66e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87f5382faf14f231fa55ff84c9e66e5">&#9670;&nbsp;</a></span>CreateMaterial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a> CreateMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1Material.html">common::Material</a> &amp;&#160;</td>
          <td class="paramname"><em>_material</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new material from the reference <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1Material.html">common::Material</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_material</td><td>Reference material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created material </dd></dl>

</div>
</div>
<a id="a1d8b1be5bf2a1798add3c860ba50c44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8b1be5bf2a1798add3c860ba50c44d">&#9670;&nbsp;</a></span>CreateMaterial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a> CreateMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new material with the given name. Created material will have default properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name for the new material. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created material </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseGizmoVisual.html#a1dc43a293d212b139df76ca7ea873c67">BaseGizmoVisual&lt; T &gt;::CreateMaterials()</a>, and <a class="el" href="classgz_1_1rendering_1_1BaseLidarVisual.html#a1dc43a293d212b139df76ca7ea873c67">BaseLidarVisual&lt; T &gt;::CreateMaterials()</a>.</p>

</div>
</div>
<a id="a1ac4d745cfd24a378cc3615d4f6e441e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac4d745cfd24a378cc3615d4f6e441e">&#9670;&nbsp;</a></span>CreateMesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#af37834327ffe201461e597ccea97064a">MeshPtr</a> CreateMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1Mesh.html">common::Mesh</a> *&#160;</td>
          <td class="paramname"><em>_mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new mesh geomerty. The <a class="el" href="classgz_1_1rendering_1_1Mesh.html" title="Represents a collection of mesh geometries.">rendering::Mesh</a> will be created from the given <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1Mesh.html">common::Mesh</a>. All sub-meshes will be loaded into this created mesh, uncentered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_mesh</td><td>Reference mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created mesh </dd></dl>

</div>
</div>
<a id="a660681201c3c9517275cf6605594eddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660681201c3c9517275cf6605594eddc">&#9670;&nbsp;</a></span>CreateMesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#af37834327ffe201461e597ccea97064a">MeshPtr</a> CreateMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgz_1_1rendering_1_1MeshDescriptor.html">MeshDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>_desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new mesh geometry. The <a class="el" href="classgz_1_1rendering_1_1Mesh.html" title="Represents a collection of mesh geometries.">rendering::Mesh</a> will be created from the given <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1Mesh.html">common::Mesh</a> specified in the <a class="el" href="structgz_1_1rendering_1_1MeshDescriptor.html" title="Describes how a Mesh should be loaded.">MeshDescriptor</a>. Sub-meshes will be loaded and centered according to the descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_desc</td><td>Descriptor of the mesh to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created mesh </dd></dl>

</div>
</div>
<a id="ad4b54cf1b702b4bbf78311f23b0b1c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b54cf1b702b4bbf78311f23b0b1c0e">&#9670;&nbsp;</a></span>CreateMesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#af37834327ffe201461e597ccea97064a">MeshPtr</a> CreateMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_meshName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new mesh geomerty. The <a class="el" href="classgz_1_1rendering_1_1Mesh.html" title="Represents a collection of mesh geometries.">rendering::Mesh</a> will be created from a <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1Mesh.html">common::Mesh</a> retrieved from <a class="elRef" href="https://gazebosim.org/api/common/5/classgz_1_1common_1_1MeshManager.html">common::MeshManager</a> using the given mesh name. If no mesh exists by this name, NULL will be returned. All sub-meshes will be loaded into the created mesh, uncentered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_meshName</td><td>Name of the reference mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created mesh </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseMesh.html#a300602d913a85496df902b50fcbe884f">BaseMesh&lt; T &gt;::Clone()</a>.</p>

</div>
</div>
<a id="aebaa2c1b748f19cfa191cc8cb161af74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebaa2c1b748f19cfa191cc8cb161af74">&#9670;&nbsp;</a></span>CreateParticleEmitter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a5052ea1e0a7143689ae12b54210c161b">ParticleEmitterPtr</a> CreateParticleEmitter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new particle emitter. A unique ID and name will automatically be assigned to the visual. </p>
<dl class="section return"><dt>Returns</dt><dd>The created particle emitter </dd></dl>

</div>
</div>
<a id="af2986dec92369000288ae5623543b567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2986dec92369000288ae5623543b567">&#9670;&nbsp;</a></span>CreateParticleEmitter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a5052ea1e0a7143689ae12b54210c161b">ParticleEmitterPtr</a> CreateParticleEmitter </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new particle emitter with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new particle emitter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created particle emitter </dd></dl>

</div>
</div>
<a id="a9bb9f692533cbca1108f16c45ef5a536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb9f692533cbca1108f16c45ef5a536">&#9670;&nbsp;</a></span>CreateParticleEmitter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a5052ea1e0a7143689ae12b54210c161b">ParticleEmitterPtr</a> CreateParticleEmitter </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new particle emitter with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new particle emitter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created particle emitter </dd></dl>

</div>
</div>
<a id="a8e1fe10fbc5122232e99b086ae8b18a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1fe10fbc5122232e99b086ae8b18a7">&#9670;&nbsp;</a></span>CreateParticleEmitter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a5052ea1e0a7143689ae12b54210c161b">ParticleEmitterPtr</a> CreateParticleEmitter </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new particle emitter with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new particle emitter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new particle emitter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created particle emitter </dd></dl>

</div>
</div>
<a id="a6de41800064b899f2e573fcc78668eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de41800064b899f2e573fcc78668eb5">&#9670;&nbsp;</a></span>CreatePlane()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a32bd50043028477c50f07cce13213556">GeometryPtr</a> CreatePlane </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new plane geometry. </p>
<dl class="section return"><dt>Returns</dt><dd>The created plane </dd></dl>

</div>
</div>
<a id="ab8e51935372f644d0d6c95651583c36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e51935372f644d0d6c95651583c36a">&#9670;&nbsp;</a></span>CreatePointLight() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#acb58cc265a1af914bf5416d601dd1800">PointLightPtr</a> CreatePointLight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new point light. A unique ID and name will automatically be assigned to the light. </p>
<dl class="section return"><dt>Returns</dt><dd>The created light </dd></dl>

</div>
</div>
<a id="ab5821c7c1ea947b16e5c4cc746327c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5821c7c1ea947b16e5c4cc746327c45">&#9670;&nbsp;</a></span>CreatePointLight() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#acb58cc265a1af914bf5416d601dd1800">PointLightPtr</a> CreatePointLight </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new point light with the given name. A unique ID will automatically be assigned to the light. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light </dd></dl>

</div>
</div>
<a id="a3c36990d69c3fd285fb22cd34d0ab025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c36990d69c3fd285fb22cd34d0ab025">&#9670;&nbsp;</a></span>CreatePointLight() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#acb58cc265a1af914bf5416d601dd1800">PointLightPtr</a> CreatePointLight </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new point light with the given ID. A unique name will automatically be assigned to the light. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light </dd></dl>

</div>
</div>
<a id="af529302478a2065ea517a83bcbec9cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af529302478a2065ea517a83bcbec9cc9">&#9670;&nbsp;</a></span>CreatePointLight() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#acb58cc265a1af914bf5416d601dd1800">PointLightPtr</a> CreatePointLight </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new point light with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new light </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light </dd></dl>

</div>
</div>
<a id="ab020fd710662ceb0671df4ce76cd046b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab020fd710662ceb0671df4ce76cd046b">&#9670;&nbsp;</a></span>CreateProjector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a88907530513e4998443d618ff074bc22">ProjectorPtr</a> CreateProjector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new projector. A unique ID and name will automatically be assigned to the visual. </p>
<dl class="section return"><dt>Returns</dt><dd>The created projector </dd></dl>

</div>
</div>
<a id="ae7b12896827f263fa7b48607b13da68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b12896827f263fa7b48607b13da68e">&#9670;&nbsp;</a></span>CreateProjector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a88907530513e4998443d618ff074bc22">ProjectorPtr</a> CreateProjector </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new projector with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new projector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fa6675b7c52bbc143bd4792666eb656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa6675b7c52bbc143bd4792666eb656">&#9670;&nbsp;</a></span>CreateProjector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a88907530513e4998443d618ff074bc22">ProjectorPtr</a> CreateProjector </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new projector with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new projector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created projector </dd></dl>

</div>
</div>
<a id="a30b0bf2c46a106114d74e238a773ed98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b0bf2c46a106114d74e238a773ed98">&#9670;&nbsp;</a></span>CreateProjector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a88907530513e4998443d618ff074bc22">ProjectorPtr</a> CreateProjector </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new projector with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new projector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new projector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created projector </dd></dl>

</div>
</div>
<a id="a991bec3f2e25c3ca3429bd973a4541bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991bec3f2e25c3ca3429bd973a4541bb">&#9670;&nbsp;</a></span>CreateRayQuery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a339d41e07ac42437b359952569f6e453">RayQueryPtr</a> CreateRayQuery </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new ray query. </p>
<dl class="section return"><dt>Returns</dt><dd>The created ray query </dd></dl>

</div>
</div>
<a id="a7b899b4c2a97bfaaccc585d8e5795f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b899b4c2a97bfaaccc585d8e5795f5c">&#9670;&nbsp;</a></span>CreateRenderTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a34e895108c5d7fe55c6216985b7a500a">RenderTexturePtr</a> CreateRenderTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new render texture. </p>
<dl class="section return"><dt>Returns</dt><dd>The created render texture </dd></dl>

</div>
</div>
<a id="a2a68cb11799ca99655190e4f5a665a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a68cb11799ca99655190e4f5a665a47">&#9670;&nbsp;</a></span>CreateRenderWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ac06da5e129043c70d45b66d453b2e092">RenderWindowPtr</a> CreateRenderWindow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new render window. This feature is render engine dependent. If the engine does not support attaching to a windowing system then it should behave as a a render texture. </p>
<dl class="section return"><dt>Returns</dt><dd>The created render window </dd></dl>

</div>
</div>
<a id="a3c2a8791479ec882812d30330c85ba7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2a8791479ec882812d30330c85ba7a">&#9670;&nbsp;</a></span>CreateSegmentationCamera() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a8faac2d655fea7ffc72c0c12dab8c270">SegmentationCameraPtr</a> CreateSegmentationCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new segmentation camera. A unique ID and name will automatically be assigned to the camera. </p>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="ae38ce48219061087b10daba9f20283ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38ce48219061087b10daba9f20283ee">&#9670;&nbsp;</a></span>CreateSegmentationCamera() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a8faac2d655fea7ffc72c0c12dab8c270">SegmentationCameraPtr</a> CreateSegmentationCamera </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new segmentation camera with the given name. A unique ID will automatically be assigned to the camera. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a6d342286cffb027f8fb5b95da0ea9ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d342286cffb027f8fb5b95da0ea9ff7">&#9670;&nbsp;</a></span>CreateSegmentationCamera() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a8faac2d655fea7ffc72c0c12dab8c270">SegmentationCameraPtr</a> CreateSegmentationCamera </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new segmentation camera with the given ID. A unique name will automatically be assigned to the camera. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a9feef2173b8f370c306a367cf12f0a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9feef2173b8f370c306a367cf12f0a13">&#9670;&nbsp;</a></span>CreateSegmentationCamera() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a8faac2d655fea7ffc72c0c12dab8c270">SegmentationCameraPtr</a> CreateSegmentationCamera </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new segmentation camera with the given name and ID. If either the given ID or name is already in use, will return NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new camera </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a3a7faab30af1832868bd8d9678960e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7faab30af1832868bd8d9678960e3f">&#9670;&nbsp;</a></span>CreateSphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a32bd50043028477c50f07cce13213556">GeometryPtr</a> CreateSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new sphere or ellipsoid geometry This method allow to create ellipsoid too, because it can be scaled in 3 dimensions. </p>
<dl class="section return"><dt>Returns</dt><dd>The created sphere </dd></dl>

</div>
</div>
<a id="a44c91c1847b0f539e65e9cf253bb2659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c91c1847b0f539e65e9cf253bb2659">&#9670;&nbsp;</a></span>CreateSpotLight() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#afafdb4220fc308ea4ad40ed846734b4d">SpotLightPtr</a> CreateSpotLight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new spotlight. A unique ID and name will automatically be assigned to the light. </p>
<dl class="section return"><dt>Returns</dt><dd>The created light </dd></dl>

</div>
</div>
<a id="af9b4bf7d3639d3ef36a71afc98df14c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b4bf7d3639d3ef36a71afc98df14c5">&#9670;&nbsp;</a></span>CreateSpotLight() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#afafdb4220fc308ea4ad40ed846734b4d">SpotLightPtr</a> CreateSpotLight </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new spotlight with the given name. A unique ID will automatically be assigned to the light. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light </dd></dl>

</div>
</div>
<a id="a45ec02c7637af4c3244284080ef0a1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ec02c7637af4c3244284080ef0a1d3">&#9670;&nbsp;</a></span>CreateSpotLight() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#afafdb4220fc308ea4ad40ed846734b4d">SpotLightPtr</a> CreateSpotLight </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new spotlight with the given ID. A unique name will automatically be assigned to the light. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light </dd></dl>

</div>
</div>
<a id="a2fbfb9c2fce7dcd8ab391e85a1916562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbfb9c2fce7dcd8ab391e85a1916562">&#9670;&nbsp;</a></span>CreateSpotLight() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#afafdb4220fc308ea4ad40ed846734b4d">SpotLightPtr</a> CreateSpotLight </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new spotlight with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new light </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created light </dd></dl>

</div>
</div>
<a id="a3adf9cbe55db56e0b42b22e7a22a4ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adf9cbe55db56e0b42b22e7a22a4ab4">&#9670;&nbsp;</a></span>CreateText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a23360ba152f25aababf8f75212206650">TextPtr</a> CreateText </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new text geometry. </p>
<dl class="section return"><dt>Returns</dt><dd>The created text </dd></dl>

</div>
</div>
<a id="a4cf345602cfef3f7882dcfb2594a39ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf345602cfef3f7882dcfb2594a39ee">&#9670;&nbsp;</a></span>CreateThermalCamera() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a77c5d6e2e974d36dd5355b4001c1fb55">ThermalCameraPtr</a> CreateThermalCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new thermal camera. A unique ID and name will automatically be assigned to the camera. </p>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a3c4e8a2bff259d35040eafd838b6d7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4e8a2bff259d35040eafd838b6d7fd">&#9670;&nbsp;</a></span>CreateThermalCamera() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a77c5d6e2e974d36dd5355b4001c1fb55">ThermalCameraPtr</a> CreateThermalCamera </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new thermal camera with the given name. A unique ID will automatically be assigned to the camera. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a1959a1f42a5b04da6b24d313d73b598e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1959a1f42a5b04da6b24d313d73b598e">&#9670;&nbsp;</a></span>CreateThermalCamera() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a77c5d6e2e974d36dd5355b4001c1fb55">ThermalCameraPtr</a> CreateThermalCamera </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new thermal camera with the given ID. A unique name will automatically be assigned to the camera. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a86443a6c64118e5c260f9a41bb2da748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86443a6c64118e5c260f9a41bb2da748">&#9670;&nbsp;</a></span>CreateThermalCamera() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a77c5d6e2e974d36dd5355b4001c1fb55">ThermalCameraPtr</a> CreateThermalCamera </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new thermal camera with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new camera </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="af53298573a740bfaa5c4f214dfab5885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53298573a740bfaa5c4f214dfab5885">&#9670;&nbsp;</a></span>CreateVisual() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a> CreateVisual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new visual. A unique ID and name will automatically be assigned to the visual. </p>
<dl class="section return"><dt>Returns</dt><dd>The created visual </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseGizmoVisual.html#a11aeddd84221bab9709add5da7c8fc2c">BaseGizmoVisual&lt; T &gt;::CreateRotationVisual()</a>, <a class="el" href="classgz_1_1rendering_1_1BaseGizmoVisual.html#a0c784930764a25118ae293515d11d6df">BaseGizmoVisual&lt; T &gt;::CreateScaleVisual()</a>, <a class="el" href="classgz_1_1rendering_1_1BaseGizmoVisual.html#ab1279c696bed29fcb54da90a28ae4355">BaseGizmoVisual&lt; T &gt;::CreateTranslationVisual()</a>, and <a class="el" href="classgz_1_1rendering_1_1BaseArrowVisual.html#a47de93e849d14c3eda08d78613506608">BaseArrowVisual&lt; T &gt;::Init()</a>.</p>

</div>
</div>
<a id="a0cae65be44eaabb0af178f18d1a984fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cae65be44eaabb0af178f18d1a984fa">&#9670;&nbsp;</a></span>CreateVisual() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a> CreateVisual </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new visual with the given name. A unique ID will automatically be assigned to the visual. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created visual </dd></dl>

</div>
</div>
<a id="a5b9f58335da23cf708ca487e0d0ee46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9f58335da23cf708ca487e0d0ee46a">&#9670;&nbsp;</a></span>CreateVisual() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a> CreateVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new visual with the given ID. A unique name will automatically be assigned to the visual. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created visual </dd></dl>

</div>
</div>
<a id="aa17f582aec835f428d4db56dd132e331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17f582aec835f428d4db56dd132e331">&#9670;&nbsp;</a></span>CreateVisual() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a> CreateVisual </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new visual with the given name. If either the given ID or name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new visual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new visual </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created visual </dd></dl>

</div>
</div>
<a id="a58ba87845cf46224ea9282fea5a7a271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ba87845cf46224ea9282fea5a7a271">&#9670;&nbsp;</a></span>CreateWideAngleCamera() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ae2a9f26a9414efca43f3fb6a5468c7b1">WideAngleCameraPtr</a> CreateWideAngleCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new wide angle camera. A unique ID and name will automatically be assigned to the camera. </p>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a84ab69d0f5df1c8979300d539ba99ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ab69d0f5df1c8979300d539ba99ce7">&#9670;&nbsp;</a></span>CreateWideAngleCamera() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ae2a9f26a9414efca43f3fb6a5468c7b1">WideAngleCameraPtr</a> CreateWideAngleCamera </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new wide angle camera with the given name. A unique ID will automatically be assigned to the camera. If the given name is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="afa66b31409729696b1e9482e757946db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa66b31409729696b1e9482e757946db">&#9670;&nbsp;</a></span>CreateWideAngleCamera() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ae2a9f26a9414efca43f3fb6a5468c7b1">WideAngleCameraPtr</a> CreateWideAngleCamera </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create wide angle camera with the given ID. A unique name will automatically be assigned to the camera. If the given ID is already in use, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a90aff9032a39e38c953e421a7ea7187f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aff9032a39e38c953e421a7ea7187f">&#9670;&nbsp;</a></span>CreateWideAngleCamera() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ae2a9f26a9414efca43f3fb6a5468c7b1">WideAngleCameraPtr</a> CreateWideAngleCamera </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new wide angle camera with the given name and ID. If either the given ID or name is already in use, will return NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the new camera </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the new camera </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created camera </dd></dl>

</div>
</div>
<a id="a8ef680b5d9f7c59c7bebeed11d98c9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef680b5d9f7c59c7bebeed11d98c9d9">&#9670;&nbsp;</a></span>CreateWireBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ab9fbd4591c3733f44eef88b055b77fda">WireBoxPtr</a> CreateWireBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new wire box geometry. </p>
<dl class="section return"><dt>Returns</dt><dd>The created wire box </dd></dl>

</div>
</div>
<a id="a84693792fa8cba90b312c0b1caf53716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84693792fa8cba90b312c0b1caf53716">&#9670;&nbsp;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completely destroy the scene an all its resources. Continued use of this scene after its destruction will result in undefined behavior. </p>

</div>
</div>
<a id="acaea3c39bcfbb419a5d6f0ab42b699e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaea3c39bcfbb419a5d6f0ab42b699e3">&#9670;&nbsp;</a></span>DestroyLight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyLight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#aab8d92ebc05d82a9ae908385584c142d">LightPtr</a>&#160;</td>
          <td class="paramname"><em>_light</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_recursive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy given light. If the given light is not managed by this scene, no work will be done. Depending on the _recursive argument, this function will either detach all child nodes from the scene graph or recursively destroy them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_light</td><td><a class="el" href="classgz_1_1rendering_1_1Light.html" title="Represents a light source in the scene graph.">Light</a> pointer to destroy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_recursive</td><td>True to recursively destroy the node and its children, false to destroy only this node and detach the children </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a309391c0f1c7d2d2d5c7d4015b96beed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309391c0f1c7d2d2d5c7d4015b96beed">&#9670;&nbsp;</a></span>DestroyLightById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyLightById </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy light with the given id. If no light exists with the given id, no work will be done. All children of the light will consequently be detached from the scene graph, but not destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the light to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c8a59e602dabe7b55344f3ae54a9ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8a59e602dabe7b55344f3ae54a9ff4">&#9670;&nbsp;</a></span>DestroyLightByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyLightByIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy light at the given index. If no light exists at the given index, no work will be done. All children of the light will consequently be detached from the scene graph, but not destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_index</td><td>Index of the light to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f95bbd4a89c43f94462453a891c691e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f95bbd4a89c43f94462453a891c691e">&#9670;&nbsp;</a></span>DestroyLightByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyLightByName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy light with the given name. If no light exists with the given name, no work will be done. All children of the light will consequently be detached from the scene graph, but not destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the light to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f781a6ac90ddb935e8737720145c56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f781a6ac90ddb935e8737720145c56f">&#9670;&nbsp;</a></span>DestroyLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyLights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy all lights manages by this scene. </p>

</div>
</div>
<a id="a77f0ab574cc1997b7a062c73b8d78077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f0ab574cc1997b7a062c73b8d78077">&#9670;&nbsp;</a></span>DestroyMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a>&#160;</td>
          <td class="paramname"><em>_material</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister and destroy a material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_material</td><td><a class="el" href="classgz_1_1rendering_1_1Material.html" title="Represents a surface material of a Geometry.">Material</a> to be unregistered and destroyed </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseMesh.html#a9138802bd505003fa7224b0dc0413fb4">BaseMesh&lt; T &gt;::Destroy()</a>, <a class="el" href="classgz_1_1rendering_1_1BaseSubMesh.html#a9138802bd505003fa7224b0dc0413fb4">BaseSubMesh&lt; T &gt;::Destroy()</a>, <a class="el" href="classgz_1_1rendering_1_1BaseMesh.html#ae94b60291dde1c96e8dd261713454e0e">BaseMesh&lt; T &gt;::SetMaterial()</a>, and <a class="el" href="classgz_1_1rendering_1_1BaseSubMesh.html#ae94b60291dde1c96e8dd261713454e0e">BaseSubMesh&lt; T &gt;::SetMaterial()</a>.</p>

</div>
</div>
<a id="a43df5dfeda03be4d8009253fa26a8150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43df5dfeda03be4d8009253fa26a8150">&#9670;&nbsp;</a></span>DestroyMaterials()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyMaterials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister and destroys all registered materials. </p>

</div>
</div>
<a id="ae7bc5affd75cbffa50e5145bef053bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bc5affd75cbffa50e5145bef053bbd">&#9670;&nbsp;</a></span>DestroyNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a>&#160;</td>
          <td class="paramname"><em>_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_recursive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy given node. If the given node is not managed by this scene, no work will be done. Depending on the _recursive argument, this function will either detach all child nodes from the scene graph or recursively destroy them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_node</td><td><a class="el" href="classgz_1_1rendering_1_1Node.html" title="Represents a single posable node in the scene graph.">Node</a> pointer to destroy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_recursive</td><td>True to recursively destroy the node and its children, false to destroy only this node and detach the children </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ba0b438d1c5a642ceafeb5f47deef6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba0b438d1c5a642ceafeb5f47deef6f">&#9670;&nbsp;</a></span>DestroyNodeById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyNodeById </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy node with the given id. If no node exists with the given id, no work will be done. All children of the node will consequently be detached from the scene graph, but not destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the node to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2005769f595ad103294a375b6287361c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2005769f595ad103294a375b6287361c">&#9670;&nbsp;</a></span>DestroyNodeByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyNodeByIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy node at the given index. If no node exists at the given index, no work will be done. All children of the node will consequently be detached from the scene graph, but not destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_index</td><td>Index of the node to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fe08c8fb252fad51e665838014f7248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe08c8fb252fad51e665838014f7248">&#9670;&nbsp;</a></span>DestroyNodeByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyNodeByName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy node with the given name. If no node exists with the given name, no work will be done. All children of the node will consequently be detached from the scene graph, but not destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the node to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5d83811f659d1b596e82406c41b736b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d83811f659d1b596e82406c41b736b">&#9670;&nbsp;</a></span>DestroyNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy all nodes manages by this scene. </p>

</div>
</div>
<a id="a0e73fda0f8201adbbd312427843dcc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e73fda0f8201adbbd312427843dcc2c">&#9670;&nbsp;</a></span>DestroySensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroySensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#a77e555648cdbea32e9262a478a637202">SensorPtr</a>&#160;</td>
          <td class="paramname"><em>_sensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_recursive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy given sensor. If the given sensor is not managed by this scene, no work will be done. Depending on the _recursive argument, this function will either detach all child nodes from the scene graph or recursively destroy them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_sensor</td><td><a class="el" href="classgz_1_1rendering_1_1Sensor.html" title="Represents a scene sensor. The most obvious example is a camera, but it can be anything that generate...">Sensor</a> pointer to destroy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_recursive</td><td>True to recursively destroy the node and its children, false to destroy only this node and detach the children </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1aa987e0622324ec7d55c035b38cd5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa987e0622324ec7d55c035b38cd5b7">&#9670;&nbsp;</a></span>DestroySensorById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroySensorById </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy sensor with the given id. If no sensor exists with the given id, no work will be done. All children of the sensor will consequently be detached from the scene graph, but not destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the sensor to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb6d5204941d6f78a9e6c213b6415486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6d5204941d6f78a9e6c213b6415486">&#9670;&nbsp;</a></span>DestroySensorByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroySensorByIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy sensor at the given index. If no sensor exists at the given index, no work will be done. All children of the sensor will consequently be detached from the scene graph, but not destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_index</td><td>Index of the sensor to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e2fac9beb223cb9b5dedbcb7a0a0016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2fac9beb223cb9b5dedbcb7a0a0016">&#9670;&nbsp;</a></span>DestroySensorByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroySensorByName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy sensor with the given name. If no sensor exists with the given name, no work will be done. All children of the sensor will consequently be detached from the scene graph, but not destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the sensor to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18e8c945a2882f458b7fbbe45d461225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e8c945a2882f458b7fbbe45d461225">&#9670;&nbsp;</a></span>DestroySensors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroySensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy all sensors manages by this scene. </p>

</div>
</div>
<a id="a9eca4cd8d921737060405fd7996bdb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eca4cd8d921737060405fd7996bdb92">&#9670;&nbsp;</a></span>DestroyVisual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyVisual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a>&#160;</td>
          <td class="paramname"><em>_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_recursive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy given node. If the given node is not managed by this scene, no work will be done. Depending on the _recursive argument, this function will either detach all child nodes from the scene graph or recursively destroy them. consequently be detached from the scene graph, but not destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_node</td><td><a class="el" href="classgz_1_1rendering_1_1Visual.html" title="Represents a visual node in a scene graph. A Visual is the only node that can have Geometry and other...">Visual</a> pointer to destroy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_recursive</td><td>True to recursively destroy the node and its children, false to destroy only this node and detach the children </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5907ddd25781110ba1726528ddc234cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5907ddd25781110ba1726528ddc234cc">&#9670;&nbsp;</a></span>DestroyVisualById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyVisualById </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy node with the given id. If no node exists with the given id, no work will be done. All children of the node will consequently be detached from the scene graph, but not destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the node to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afee3fe9d3ac3ec2b56c5d582fccc6926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee3fe9d3ac3ec2b56c5d582fccc6926">&#9670;&nbsp;</a></span>DestroyVisualByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyVisualByIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy node at the given index. If no node exists at the given index, no work will be done. All children of the node will consequently be detached from the scene graph, but not destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_index</td><td>Index of the node to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a044988d036e3e7be485911d6ecfb3821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044988d036e3e7be485911d6ecfb3821">&#9670;&nbsp;</a></span>DestroyVisualByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyVisualByName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy node with the given name. If no node exists with the given name, no work will be done. All children of the node will consequently be detached from the scene graph, but not destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the node to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7d3d1877f7997bab3aa3de5244f2196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d3d1877f7997bab3aa3de5244f2196">&#9670;&nbsp;</a></span>DestroyVisuals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DestroyVisuals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy all nodes manages by this scene. </p>

</div>
</div>
<a id="a38922be9a07a57794b9ce5d223aafb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38922be9a07a57794b9ce5d223aafb60">&#9670;&nbsp;</a></span>Engine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgz_1_1rendering_1_1RenderEngine.html">RenderEngine</a>* Engine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the creating render-engine of the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>The creating render-engine </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#adbea568ef2df6575ae3c5602b2862bc1">BaseCamera&lt; T &gt;::CreateRenderWindow()</a>, <a class="el" href="classgz_1_1rendering_1_1BaseWideAngleCamera.html#a8867ddcc704c826ab5e2101a8d757d43">BaseWideAngleCamera&lt; T &gt;::Project3d()</a>, <a class="el" href="classgz_1_1rendering_1_1BaseMesh.html#a7e93c20ebaa0c2842aec7f95cfa53cc7">BaseMesh&lt; T &gt;::SetSkeletonWeights()</a>, <a class="el" href="classgz_1_1rendering_1_1BaseVisual.html#a519a35bbe7cf598fd49d24a7c0f619bb">BaseVisual&lt; T &gt;::SetStatic()</a>, <a class="el" href="classgz_1_1rendering_1_1BaseVisual.html#a90331d9ccfce5321f48b33c2327368df">BaseVisual&lt; T &gt;::SetVisible()</a>, and <a class="el" href="classgz_1_1rendering_1_1BaseVisual.html#a6ce173b2f5301c0096281d335ebaa5fa">BaseVisual&lt; T &gt;::SetWireframe()</a>.</p>

</div>
</div>
<a id="a8f5fee34e55d20d5da6174216a33d818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5fee34e55d20d5da6174216a33d818">&#9670;&nbsp;</a></span>Extension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1rendering_1_1SceneExt.html">SceneExt</a>* Extension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get scene extention APIs This provides new <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a> APIs that are experimental. </p>

</div>
</div>
<a id="a44ab09639dcc9875bf3814ca022c9a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ab09639dcc9875bf3814ca022c9a09">&#9670;&nbsp;</a></span>Fini()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Fini </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3906d931128cd3b883b70aa6da2ca25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3906d931128cd3b883b70aa6da2ca25">&#9670;&nbsp;</a></span>GradientBackgroundColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" href="https://gazebosim.org/api/math/7/classgz_1_1math_1_1Color.html">math::Color</a>, 4&gt; GradientBackgroundColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scene gradient background color. </p>
<dl class="section return"><dt>Returns</dt><dd>The scene gradient background color </dd></dl>
<dl class="section see"><dt>See also</dt><dd>bool <a class="el" href="classgz_1_1rendering_1_1Scene.html#aafccfdffdda0b6336799b8d1750de1a9" title="Whether the scene has a gradient background or not (solid)">IsGradientBackgroundColor() const </a> </dd></dl>

</div>
</div>
<a id="a1f6d76456df0243e0409d9d437987e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6d76456df0243e0409d9d437987e54">&#9670;&nbsp;</a></span>HasLight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasLight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#a2be6a738363170a0a8b2d52c3acee1e0">ConstLightPtr</a>&#160;</td>
          <td class="paramname"><em>_light</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the given light is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_light</td><td><a class="el" href="classgz_1_1rendering_1_1Light.html" title="Represents a light source in the scene graph.">Light</a> in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a light is managed by this scene </dd></dl>

</div>
</div>
<a id="ac3c97e682db693a9f4834cdd7878ea50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c97e682db693a9f4834cdd7878ea50">&#9670;&nbsp;</a></span>HasLightId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasLightId </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a given light with the given id is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the light in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a light is managed by this scene </dd></dl>

</div>
</div>
<a id="a00d5fba76c4fa63c9389936c5e465e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d5fba76c4fa63c9389936c5e465e0f">&#9670;&nbsp;</a></span>HasLightName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasLightName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a given light with the given name is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the light in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a light is managed by this scene </dd></dl>

</div>
</div>
<a id="af378125e2c81a11e92b148e355aa183a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af378125e2c81a11e92b148e355aa183a">&#9670;&nbsp;</a></span>HasNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#a50d64ba521131daafe5877c35eddfd14">ConstNodePtr</a>&#160;</td>
          <td class="paramname"><em>_node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the given node is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_node</td><td><a class="el" href="classgz_1_1rendering_1_1Node.html" title="Represents a single posable node in the scene graph.">Node</a> in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a node is managed by this scene </dd></dl>

</div>
</div>
<a id="ab1c0a7a763fb453f205a5d895bac0507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c0a7a763fb453f205a5d895bac0507">&#9670;&nbsp;</a></span>HasNodeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasNodeId </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a given node with the given id is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the node in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a node is managed by this scene </dd></dl>

</div>
</div>
<a id="a8fc5d225da600b6a7b654239befbfa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc5d225da600b6a7b654239befbfa2d">&#9670;&nbsp;</a></span>HasNodeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasNodeName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a given node with the given name is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the node in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a node is managed by this scene </dd></dl>

</div>
</div>
<a id="adf51099d1d89e4ade0198faee86ed36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf51099d1d89e4ade0198faee86ed36f">&#9670;&nbsp;</a></span>HasSensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasSensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#ad51570a6b8de80c8c413e29aaee29bc2">ConstSensorPtr</a>&#160;</td>
          <td class="paramname"><em>_sensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the given sensor is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_sensor</td><td><a class="el" href="classgz_1_1rendering_1_1Sensor.html" title="Represents a scene sensor. The most obvious example is a camera, but it can be anything that generate...">Sensor</a> in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a sensor is managed by this scene </dd></dl>

</div>
</div>
<a id="a4bdf4a9e46d3552995b65d6024abdf73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdf4a9e46d3552995b65d6024abdf73">&#9670;&nbsp;</a></span>HasSensorId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasSensorId </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a given sensor with the given id is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the sensor in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a sensor is managed by this scene </dd></dl>

</div>
</div>
<a id="a9e628691675e93d6d9a9011fba9b9095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e628691675e93d6d9a9011fba9b9095">&#9670;&nbsp;</a></span>HasSensorName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasSensorName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a given sensor with the given name is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the sensor in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a sensor is managed by this scene </dd></dl>

</div>
</div>
<a id="aba97ccee81ecb5989124d36cb30b54f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba97ccee81ecb5989124d36cb30b54f8">&#9670;&nbsp;</a></span>HasVisual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasVisual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#a14e3ea7e4edce7d80dae5346640eedce">ConstVisualPtr</a>&#160;</td>
          <td class="paramname"><em>_node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the given node is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_node</td><td><a class="el" href="classgz_1_1rendering_1_1Visual.html" title="Represents a visual node in a scene graph. A Visual is the only node that can have Geometry and other...">Visual</a> in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a node is managed by this scene </dd></dl>

</div>
</div>
<a id="a7d263e865330fb4f132acf3738dcbc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d263e865330fb4f132acf3738dcbc53">&#9670;&nbsp;</a></span>HasVisualId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasVisualId </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a given node with the given id is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the node in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a node is managed by this scene </dd></dl>

</div>
</div>
<a id="a64d462fe3126c8f11b78d194ab811f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d462fe3126c8f11b78d194ab811f47">&#9670;&nbsp;</a></span>HasVisualName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool HasVisualName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a given node with the given name is managed by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the node in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a node is managed by this scene </dd></dl>

</div>
</div>
<a id="af440fd9edb16553775262ac2c5fcd315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af440fd9edb16553775262ac2c5fcd315">&#9670;&nbsp;</a></span>Id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int Id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID of the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>The scene ID </dd></dl>

</div>
</div>
<a id="a5368a4a3fff770682cf257e81707d9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5368a4a3fff770682cf257e81707d9f0">&#9670;&nbsp;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the scene. </p>

</div>
</div>
<a id="aafccfdffdda0b6336799b8d1750de1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafccfdffdda0b6336799b8d1750de1a9">&#9670;&nbsp;</a></span>IsGradientBackgroundColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IsGradientBackgroundColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the scene has a gradient background or not (solid) </p>
<dl class="section return"><dt>Returns</dt><dd>True if the scene has a gradient background or false otherwise </dd></dl>

</div>
</div>
<a id="a56855f48547c7b7bb51324f6dc1fc6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56855f48547c7b7bb51324f6dc1fc6cd">&#9670;&nbsp;</a></span>IsInitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IsInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the scene is initialized. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the scene is initialized </dd></dl>

</div>
</div>
<a id="a8e91d08c010b57accde3d5fb1e656768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e91d08c010b57accde3d5fb1e656768">&#9670;&nbsp;</a></span>LegacyAutoGpuFlush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool LegacyAutoGpuFlush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if SetCameraPassCountPerGpuFlush is 0. </p>
<dl class="section return"><dt>Returns</dt><dd>True if Gazebo is using the old method (i.e. 0). ALWAYS returns true for plugins that ignore SetCameraPassCountPerGpuFlush </dd></dl>

</div>
</div>
<a id="acc9bad601997a4f5337737719e2be0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9bad601997a4f5337737719e2be0ea">&#9670;&nbsp;</a></span>LightById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aab8d92ebc05d82a9ae908385584c142d">LightPtr</a> LightById </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get light with the given id. If no light exists with the given id, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the desired light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired light </dd></dl>

</div>
</div>
<a id="a04a9cd0a3f2aafbeb8319e3c4ea4e64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a9cd0a3f2aafbeb8319e3c4ea4e64e">&#9670;&nbsp;</a></span>LightByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aab8d92ebc05d82a9ae908385584c142d">LightPtr</a> LightByIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get light at the given index. If no light exists at the given index, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_index</td><td>Index of the desired light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired light </dd></dl>

</div>
</div>
<a id="aaad08acf97da684c3150f41c58368658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad08acf97da684c3150f41c58368658">&#9670;&nbsp;</a></span>LightByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aab8d92ebc05d82a9ae908385584c142d">LightPtr</a> LightByName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get light with the given name. If no light exists with the given name, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the desired light </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired light </dd></dl>

</div>
</div>
<a id="a2fba8dba1107788658743b1e2e5301a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fba8dba1107788658743b1e2e5301a8">&#9670;&nbsp;</a></span>LightCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int LightCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of lights managed by this scene. Note these lights may not be directly or indirectly attached to the root light. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of lights managed by this scene </dd></dl>

</div>
</div>
<a id="a580ff46616b0657d8c1abc021a53f134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580ff46616b0657d8c1abc021a53f134">&#9670;&nbsp;</a></span>Load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Load </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load scene-specific resources. </p>

</div>
</div>
<a id="a2832fb86f24ded5d2291acfcbd2e513f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2832fb86f24ded5d2291acfcbd2e513f">&#9670;&nbsp;</a></span>Material()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a> <a class="el" href="classgz_1_1rendering_1_1Material.html">Material</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get material registered under the given name. If no material is registered under the given name, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the desired material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The specified material </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseGizmoVisual.html#a1dc43a293d212b139df76ca7ea873c67">BaseGizmoVisual&lt; T &gt;::CreateMaterials()</a>, <a class="el" href="classgz_1_1rendering_1_1BaseGeometry.html#a377d95e5ea8b0de1472ef02a6a42b580">BaseGeometry&lt; T &gt;::SetMaterial()</a>, <a class="el" href="classgz_1_1rendering_1_1BaseMesh.html#a8fa6cc908e8753da060b76f09dd2f4d6">BaseMesh&lt; T &gt;::SetMaterial()</a>, <a class="el" href="classgz_1_1rendering_1_1BaseSubMesh.html#a8fa6cc908e8753da060b76f09dd2f4d6">BaseSubMesh&lt; T &gt;::SetMaterial()</a>, and <a class="el" href="classgz_1_1rendering_1_1BaseVisual.html#a8fa6cc908e8753da060b76f09dd2f4d6">BaseVisual&lt; T &gt;::SetMaterial()</a>.</p>

</div>
</div>
<a id="ac2ac4972557d384b86d5e21c27d32f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ac4972557d384b86d5e21c27d32f77">&#9670;&nbsp;</a></span>MaterialRegistered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MaterialRegistered </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a material is registered under the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the material in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a material is registered under the given name </dd></dl>

</div>
</div>
<a id="a70ee001ce76c53aebb215a9f51653ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ee001ce76c53aebb215a9f51653ab3">&#9670;&nbsp;</a></span>Name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> Name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>The scene name </dd></dl>

</div>
</div>
<a id="a5f3038ba5e196657508d349f4ae5a15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3038ba5e196657508d349f4ae5a15d">&#9670;&nbsp;</a></span>NodeById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> NodeById </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get node with the given id. If no node exists with the given id, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the desired node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired node </dd></dl>

</div>
</div>
<a id="ade313f435ba2b5d463b5e4e0ed76e329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade313f435ba2b5d463b5e4e0ed76e329">&#9670;&nbsp;</a></span>NodeByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> NodeByIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get node at the given index. If no node exists at the given index, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_index</td><td>Index of the desired node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired node </dd></dl>

</div>
</div>
<a id="a7f926d8692e658af01b1d5107d50108f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f926d8692e658af01b1d5107d50108f">&#9670;&nbsp;</a></span>NodeByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a055594f6830344331fa78ef1f50894b2">NodePtr</a> NodeByName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get node with the given name. If no node exists with the given name, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the desired node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired node </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseJointVisual.html#a5444c90c26804ca0b7440a87cd1793f3">BaseJointVisual&lt; T &gt;::CreateParentAxis()</a>.</p>

</div>
</div>
<a id="ad29f5ebe4ee90af164fb8ec8f827b00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29f5ebe4ee90af164fb8ec8f827b00c">&#9670;&nbsp;</a></span>NodeCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int NodeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of nodes managed by this scene. Note these nodes may not be directly or indirectly attached to the root node. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes managed by this scene </dd></dl>

</div>
</div>
<a id="aee73a4d9fd3bca2a941038e4a5a3879d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee73a4d9fd3bca2a941038e4a5a3879d">&#9670;&nbsp;</a></span>PostRender()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PostRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function after you're done updating ALL cameras. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Each PreRender must have a correspondent PostRender </dd>
<dd>
Particle FX simulation is moved forward after this call</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgz_1_1rendering_1_1Scene.html#a0701d6383a2039285eaf87544b695c35" title="The ideal render loop is as follows:">Scene::SetCameraPassCountPerGpuFlush</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#aafdddf2ff6454efa496f5a32b737dd10">BaseCamera&lt; T &gt;::Update()</a>.</p>

</div>
</div>
<a id="adffb56e0e545fefebf96b36f295396e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffb56e0e545fefebf96b36f295396e9">&#9670;&nbsp;</a></span>PreRender()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PreRender </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare scene for rendering. The scene will flushing any scene changes by traversing scene-graph, calling PreRender on all objects. </p>

<p class="reference">Referenced by <a class="el" href="classgz_1_1rendering_1_1BaseCamera.html#aafdddf2ff6454efa496f5a32b737dd10">BaseCamera&lt; T &gt;::Update()</a>.</p>

</div>
</div>
<a id="a4f4df8fff8d878964bebeeef399284de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4df8fff8d878964bebeeef399284de">&#9670;&nbsp;</a></span>RegisterMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RegisterMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a>&#160;</td>
          <td class="paramname"><em>_material</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a new material under the given name. If the name is already in use, no work will be done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name which the material will be registered under </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_material</td><td><a class="el" href="classgz_1_1rendering_1_1Material.html" title="Represents a surface material of a Geometry.">Material</a> to register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc623995984bdb89639154a81a2704af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc623995984bdb89639154a81a2704af">&#9670;&nbsp;</a></span>RemoveGradientBackgroundColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RemoveGradientBackgroundColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the scene gradient background color. </p>
<dl class="section see"><dt>See also</dt><dd>void <a class="el" href="classgz_1_1rendering_1_1Scene.html#ad32f5e69f2fe4904d7810f6175cd4a32" title="Set a custom gradient background color on top of the regular background. Default should be black.">SetGradientBackgroundColor</a>( const std::array&lt;math::Color, 4&gt; &amp;_colors) </dd></dl>

</div>
</div>
<a id="aa097e71abf425bf91e8f159e490d8f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa097e71abf425bf91e8f159e490d8f06">&#9670;&nbsp;</a></span>RootVisual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a> RootVisual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get root <a class="el" href="classgz_1_1rendering_1_1Visual.html" title="Represents a visual node in a scene graph. A Visual is the only node that can have Geometry and other...">Visual</a> node. All nodes that are desired to be rendered in a scene should be added to this <a class="el" href="classgz_1_1rendering_1_1Visual.html" title="Represents a visual node in a scene graph. A Visual is the only node that can have Geometry and other...">Visual</a> or one of its ancestors in the scene-graph. Nodes created by this <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a> will not be added to the scene by default. </p>
<dl class="section return"><dt>Returns</dt><dd>The root <a class="el" href="classgz_1_1rendering_1_1Visual.html" title="Represents a visual node in a scene graph. A Visual is the only node that can have Geometry and other...">Visual</a> node </dd></dl>

</div>
</div>
<a id="a06881da527f30f2f7fa458a644fb1827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06881da527f30f2f7fa458a644fb1827">&#9670;&nbsp;</a></span>SensorById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a77e555648cdbea32e9262a478a637202">SensorPtr</a> SensorById </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get sensor with the given id. If no sensor exists with the given id, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the desired sensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired sensor </dd></dl>

</div>
</div>
<a id="a390bc0bef45a73c3bee13a3a7f0461b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390bc0bef45a73c3bee13a3a7f0461b2">&#9670;&nbsp;</a></span>SensorByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a77e555648cdbea32e9262a478a637202">SensorPtr</a> SensorByIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get sensor at the given index. If no sensor exists at the given index, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_index</td><td>Index of the desired sensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired sensor </dd></dl>

</div>
</div>
<a id="a89203bdd8f37fdb48923f03cd1bd73a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89203bdd8f37fdb48923f03cd1bd73a3">&#9670;&nbsp;</a></span>SensorByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#a77e555648cdbea32e9262a478a637202">SensorPtr</a> SensorByName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get sensor with the given name. If no sensor exists with the given name, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the desired sensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired sensor </dd></dl>

</div>
</div>
<a id="abdad64499784fd46f2fd57b0d998b3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdad64499784fd46f2fd57b0d998b3f2">&#9670;&nbsp;</a></span>SensorCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int SensorCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of sensors managed by this scene. Note these sensors may not be directly or indirectly attached to the root sensor. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of sensors managed by this scene </dd></dl>

</div>
</div>
<a id="a29472d6456fd6e434f84ef2e9a929ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29472d6456fd6e434f84ef2e9a929ee5">&#9670;&nbsp;</a></span>SetActiveGlobalIllumination()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetActiveGlobalIllumination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#a23b8dead8c5aea88ea973f2c4cfb16e8">GlobalIlluminationBasePtr</a>&#160;</td>
          <td class="paramname"><em>_gi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given GI as the current new active GI solution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_gi</td><td>GI solution that should be active. Nullptr to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69e4b1578ed15a0bc16d4e0508ef0daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e4b1578ed15a0bc16d4e0508ef0daa">&#9670;&nbsp;</a></span>SetAmbientLight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetAmbientLight </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gazebosim.org/api/math/7/classgz_1_1math_1_1Color.html">math::Color</a> &amp;&#160;</td>
          <td class="paramname"><em>_color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scene ambient light color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_color</td><td>The scene ambient light color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f60348a73f4682a1cba96a0a25b8fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f60348a73f4682a1cba96a0a25b8fd1">&#9670;&nbsp;</a></span>SetAmbientLight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetAmbientLight </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_a</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scene ambient light color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_r</td><td>Red color </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_g</td><td>Green color </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_b</td><td>Blue color </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_a</td><td>Alpha color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0727c95811665e6f27dbce0d1d7f5426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0727c95811665e6f27dbce0d1d7f5426">&#9670;&nbsp;</a></span>SetBackgroundColor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetBackgroundColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://gazebosim.org/api/math/7/classgz_1_1math_1_1Color.html">math::Color</a> &amp;&#160;</td>
          <td class="paramname"><em>_color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scene background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_color</td><td>The scene background color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a202de0928fc8a2abe9f58f0c92e93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a202de0928fc8a2abe9f58f0c92e93a">&#9670;&nbsp;</a></span>SetBackgroundColor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetBackgroundColor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_a</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scene background color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_r</td><td>Red color </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_g</td><td>Green color </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_b</td><td>Blue color </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_a</td><td>Alpha color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69d9d2c4346f6bf952debbe486ecad35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d9d2c4346f6bf952debbe486ecad35">&#9670;&nbsp;</a></span>SetBackgroundMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetBackgroundMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1rendering.html#aad685ec324d6250d01ec1c0c092ecde3">MaterialPtr</a>&#160;</td>
          <td class="paramname"><em>_material</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scene background material e.g. a material with skybox cubemap texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_material</td><td><a class="el" href="classgz_1_1rendering_1_1Material.html" title="Represents a surface material of a Geometry.">Material</a> to set the background to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0701d6383a2039285eaf87544b695c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0701d6383a2039285eaf87544b695c35">&#9670;&nbsp;</a></span>SetCameraPassCountPerGpuFlush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetCameraPassCountPerGpuFlush </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>_numPass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The ideal render loop is as follows: </p>
<div class="fragment"><div class="line">scene-&gt;PreRender();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;camera in cameras)</div>
<div class="line">  camera-&gt;Render();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;camera in cameras)</div>
<div class="line">  camera-&gt;PostRender();</div>
<div class="line">scene-&gt;PostRender();</div>
</div><!-- fragment --><p>Now... <a class="el" href="classgz_1_1rendering_1_1Camera.html" title="Posable camera used for rendering the scene graph.">Camera</a> Render calls MUST happen between <a class="el" href="classgz_1_1rendering_1_1Scene.html#adffb56e0e545fefebf96b36f295396e9" title="Prepare scene for rendering. The scene will flushing any scene changes by traversing scene-graph,...">Scene::PreRender</a> and <a class="el" href="classgz_1_1rendering_1_1Scene.html#aee73a4d9fd3bca2a941038e4a5a3879d" title="Call this function after you&#39;re done updating ALL cameras.">Scene::PostRender</a>.</p>
<p>The scene must not be modified (e.g. add/remove objects, lights, etc) while inside <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a> PreRender/PostRender</p>
<h1><a class="anchor" id="autotoc_md62"></a>
Legacy mode: Set this value to 0.</h1>
<p>Old projects migrating to newer gz versions may break these rules (e.g. not calling Render between <a class="el" href="classgz_1_1rendering_1_1Scene.html" title="Manages a single scene-graph. This class updates scene-wide properties and holds the root scene node....">Scene</a>'s Pre/PostRender).</p>
<p>Setting this value to 0 forces Gazebo to flush commands for every camera; thus avoiding the need to call PostRender at all</p>
<p>This is much slower but will ease porting, specially if it's not easy to adapt your code to call PostRender for some reason (in non-legacy mode each call <em>must</em> correspond to a previous PreRender call)</p>
<p>Legacy mode forces Particle FX simulations to move forward after each camera render, which can cause inconsistencies when Cameras are supposed to be rendering the same frame from different angles</p>
<h1><a class="anchor" id="autotoc_md63"></a>
New mode i.e. values greater than 0:</h1>
<p>The CPU normally queues up of rendering commands from each <a class="el" href="classgz_1_1rendering_1_1Camera.html" title="Posable camera used for rendering the scene graph.">Camera</a> and then waits for the GPU to finish up.</p>
<ol type="1">
<li>If we flush too often, the CPU will often have to wait for the GPU to finish.</li>
<li>If we flush infrequently, RAM consumption will rise due to queueing up too much unsubmitted work.</li>
</ol>
<p>Larger values values queue up more work; lower values flush more frequently.</p>
<p>Note that work may be submitted earlier if required by a specific operation (e.g. reading GPU -&gt; CPU)</p>
<p>A sensible value in the range of [2; 6] is probably the best ratio between parallel performance / RAM cost.</p>
<p>Actual value depends on scene complexity and number of shadow casting lights</p>
<p>If you're too tight on RAM consumption, try setting this value to 1.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
Example:</h2>
<p>Cubemap rendering w/ 3 probes and 5 shadowmaps can cause a blow up of passes:</p>
<p>(5 shadow maps per face + 1 regular render) x 6 faces x 3 probes = 108 render_scene passes. 108 is way too much, causing out of memory situations;</p>
<p>so setting the value to 6 (1 cubemap face = 1 pass) will force one flush per cubemap face, flushing a total of 3 times (one per cubemap).</p>
<h2><a class="anchor" id="autotoc_md65"></a>
Upper bound</h2>
<p>Once <a class="el" href="classgz_1_1rendering_1_1Scene.html#aee73a4d9fd3bca2a941038e4a5a3879d" title="Call this function after you&#39;re done updating ALL cameras.">Scene::PostRender</a> is called, a flush is always forced.</p>
<p>If you set a value of e.g. 6, but you have a single camera, it will be flushed after <a class="el" href="classgz_1_1rendering_1_1Scene.html#aee73a4d9fd3bca2a941038e4a5a3879d" title="Call this function after you&#39;re done updating ALL cameras.">Scene::PostRender</a>, thus having a value of 1 or 6 won't matter as the result will be exactly the same (in every term: performance, memory consumption)</p>
<p>A value of 6 is like an upper bound. We may queue <em>up to</em> 6 render passes or less; but never more.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Not all rendering engines care about this. ogre2 plugin does.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_numPass</td><td>0 for old projects who can't or don't know when to call PostRender and prefer to penalize rendering performance Value in range [1; 255] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac80bc8c3242a5c91a6ccc979a5d0f43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80bc8c3242a5c91a6ccc979a5d0f43a">&#9670;&nbsp;</a></span>SetExtension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgz_1_1rendering_1_1SceneExt.html">SceneExt</a> *&#160;</td>
          <td class="paramname"><em>_ext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scene extention API This is called by underlying render engines. </p>

</div>
</div>
<a id="ad32f5e69f2fe4904d7810f6175cd4a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32f5e69f2fe4904d7810f6175cd4a32">&#9670;&nbsp;</a></span>SetGradientBackgroundColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetGradientBackgroundColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="https://gazebosim.org/api/math/7/classgz_1_1math_1_1Color.html">math::Color</a>, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_colors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a custom gradient background color on top of the regular background. Default should be black. </p>
<p>Important note: Keep in mind that this object will always be rendered on top of any existing scene or camera background.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_colors</td><td>The scene gradient background color. Next is the description of how to interpret each value of the array: 0: Top left corner color. 1: Bottom left corner color. 2: Top right corner color. 3: Bottom right corner color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>void <a class="el" href="classgz_1_1rendering_1_1Scene.html#adc623995984bdb89639154a81a2704af" title="Remove the scene gradient background color.">RemoveGradientBackgroundColor()</a> </dd></dl>

</div>
</div>
<a id="ae13e23dca28e9e302925ab65662255c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13e23dca28e9e302925ab65662255c1">&#9670;&nbsp;</a></span>SetSkyEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetSkyEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable sky in the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_enabled</td><td>True to enable sky </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a43ce3c44418e9f947b4d0eb0db0199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a43ce3c44418e9f947b4d0eb0db0199">&#9670;&nbsp;</a></span>SetTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetTime </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::steady_clock::duration &amp;&#160;</td>
          <td class="paramname"><em>_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the last simulation update time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_time</td><td>Latest simulation update time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a058e2249f693d1b69ec98c2be23093b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058e2249f693d1b69ec98c2be23093b5">&#9670;&nbsp;</a></span>SkyEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkyEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether the sky is enabled in the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>true to sky is enabled, false otherwise </dd></dl>

</div>
</div>
<a id="a8a19be4c4ee7fd7c1bc80b4e545ffbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a19be4c4ee7fd7c1bc80b4e545ffbcc">&#9670;&nbsp;</a></span>Time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::chrono::steady_clock::duration Time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last simulation update time. </p>
<dl class="section return"><dt>Returns</dt><dd>The last simulation update time </dd></dl>

</div>
</div>
<a id="a33f730dc187e79e16da3d44fe908151f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f730dc187e79e16da3d44fe908151f">&#9670;&nbsp;</a></span>UnregisterMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void UnregisterMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister material registered under the given name. If no material is registered under this name, no work will be done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the material to unregistered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8088acf3b369ac32d6c5d9ee5b08c696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8088acf3b369ac32d6c5d9ee5b08c696">&#9670;&nbsp;</a></span>UnregisterMaterials()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void UnregisterMaterials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister all registered materials. </p>

</div>
</div>
<a id="a9601bb7b20f4c35fc3e4f1f1d1fb2177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9601bb7b20f4c35fc3e4f1f1d1fb2177">&#9670;&nbsp;</a></span>VisualAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a> VisualAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1rendering.html#afc9577975b8c7e847de55c43bd5798c0">CameraPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>_camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://gazebosim.org/api/math/7/namespacegz_1_1math.html#aa83d444bd6cbecb112158663c2e0c213">math::Vector2i</a> &amp;&#160;</td>
          <td class="paramname"><em>_mousePos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a visual at a mouse position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_camera</td><td><a class="el" href="classgz_1_1rendering_1_1Camera.html" title="Posable camera used for rendering the scene graph.">Camera</a> pointer being used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_mousePos</td><td>position of the mouse in pixels </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the visual, NULL if none found. </dd></dl>

</div>
</div>
<a id="ad26f4ffd95711ec7ad2a3f88628e1263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26f4ffd95711ec7ad2a3f88628e1263">&#9670;&nbsp;</a></span>VisualById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a> VisualById </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get node with the given id. If no node exists with the given id, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_id</td><td>ID of the desired node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired node </dd></dl>

</div>
</div>
<a id="aef00ef77d31095ad8721d54f9dfa0a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef00ef77d31095ad8721d54f9dfa0a39">&#9670;&nbsp;</a></span>VisualByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a> VisualByIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get node at the given index. If no node exists at the given index, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_index</td><td>Index of the desired node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired node </dd></dl>

</div>
</div>
<a id="a74a59b54760d857f55e47395a88781c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a59b54760d857f55e47395a88781c1">&#9670;&nbsp;</a></span>VisualByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegz_1_1rendering.html#ade5c89d5a76252eccf0d1036e1d1f462">VisualPtr</a> VisualByName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get node with the given name. If no node exists with the given name, NULL will be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the desired node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired node </dd></dl>

</div>
</div>
<a id="abde82125babccfb3d6572980b7b40ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde82125babccfb3d6572980b7b40ce5">&#9670;&nbsp;</a></span>VisualCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int VisualCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of nodes managed by this scene. Note these nodes may not be directly or indirectly attached to the root node. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes managed by this scene </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Scene_8hh_source.html">Scene.hh</a></li>
</ul>
</div><!-- contents -->
      </div>
    </main>
  </div>
</body>
