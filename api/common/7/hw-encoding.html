<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Common">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Common: Hardware-accelerated Video Encoding</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Common</h1>
        <h2>API Reference</h2>
        <div class="version">
        7.0.0~pre2
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Hardware-accelerated Video Encoding</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>When recording video using the <code><a class="el" href="classgz_1_1common_1_1VideoEncoder.html" title="The VideoEncoder class supports encoding a series of images to a video format, and then writing the v...">gz::common::VideoEncoder</a></code> class, you can opt-in to use hardware (HW) acceleration for the encoding process. By default, only software encoders are used. This tutorial will show how to configure the encoder for HW acceleration and will present ready-made commandlines for some typical use-cases.</p>
<p>You can either use the <code>VideoEncoder</code> class directly, or you can "meet it" in the video recorder plugin in Gazebo. In both cases, HW-accelerated encoding can be set up.</p>
<p>HW acceleration should provide you with higher encoding performance, potentially leaving more CPU power to the rest of your program/simulation, while taking a bit of GPU memory (video encoding uses different chips than 3D graphics or CUDA computations, so performance-wise, the rest of the GPU should be unaffected).</p>
<h1><a class="anchor" id="configuring-hardware-acceleration"></a>
Configuring hardware acceleration</h1>
<h2><a class="anchor" id="what-needs-to-be-configured"></a>
What needs to be configured</h2>
<p>In order to get HW accelerated encoding working, you need to get 3 things right:</p>
<ol type="1">
<li>The encoder type</li>
<li>The HW device to be used</li>
<li>Whether to use a specialized HW surface</li>
</ol>
<h2><a class="anchor" id="autotoc_md1-encoder-types"></a>
1. Encoder types</h2>
<p>The support for HW-accelerated encoding is based on what the local installation of <code>libavcodec</code> (and your hardware) offers. If the libavcodec/FFMpeg your system has doesn't support HW acceleration, you're out of luck until you get a version that supports some. Some information about various aspects of the acceleration support by FFMpeg can be found on their <a href="https://trac.ffmpeg.org/wiki/HWAccelIntro">HWAccelIntro wiki page</a>.</p>
<p>If FFMpeg is correctly installed, you can see the available HW encoders by calling <code>ffmpeg -hide_banner -encoders | grep 264</code>.</p>
<p>Here are some sample outputs:</p>
<div class="fragment"><div class="line">(Windows) $ ffmpeg -hide_banner -encoders | grep 264</div>
<div class="line"> V..... libx264              libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264)</div>
<div class="line"> V..... libx264rgb           libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264)</div>
<div class="line"> V..... h264_amf             AMD AMF H.264 Encoder (codec h264)</div>
<div class="line"> V..... h264_nvenc           NVIDIA NVENC H.264 encoder (codec h264)</div>
<div class="line"> V..... h264_qsv             H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (Intel Quick Sync Video acceleration) (codec h264)</div>
<div class="line"> V..... nvenc                NVIDIA NVENC H.264 encoder (codec h264)</div>
<div class="line"> V..... nvenc_h264           NVIDIA NVENC H.264 encoder (codec h264)</div>
</div><!-- fragment --><div class="fragment"><div class="line">(Linux) $ ffmpeg -hide_banner -encoders | grep 264</div>
<div class="line"> V..... libx264              libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264)</div>
<div class="line"> V..... libx264rgb           libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264)</div>
<div class="line"> V..... h264_nvenc           NVIDIA NVENC H.264 encoder (codec h264)</div>
<div class="line"> V..... h264_omx             OpenMAX IL H.264 video encoder (codec h264)</div>
<div class="line"> V..... h264_v4l2m2m         V4L2 mem2mem H.264 encoder wrapper (codec h264)</div>
<div class="line"> V..... h264_vaapi           H.264/AVC (VAAPI) (codec h264)</div>
<div class="line"> V..... nvenc                NVIDIA NVENC H.264 encoder (codec h264)</div>
<div class="line"> V..... nvenc_h264           NVIDIA NVENC H.264 encoder (codec h264)</div>
</div><!-- fragment --><p>Gazebo Common so far supports:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Encoder   </th><th class="markdownTableHeadNone">Technology   </th><th class="markdownTableHeadNone">Platforms   </th><th class="markdownTableHeadNone">GPU vendors   </th><th class="markdownTableHeadNone">Gazebo Common name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>h264_nvenc</code>   </td><td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Nvidia_NVENC">NVidia NVEnc</a>   </td><td class="markdownTableBodyNone">Windows + x86 Linux   </td><td class="markdownTableBodyNone">NVidia GPUs   </td><td class="markdownTableBodyNone">NVENC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>h264_qsv</code>   </td><td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Intel_Quick_Sync_Video">Intel QuickSync</a>   </td><td class="markdownTableBodyNone">Windows + x86 Linux   </td><td class="markdownTableBodyNone">Intel GPUs   </td><td class="markdownTableBodyNone">QSV    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>h264_vaapi</code>   </td><td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Video_Acceleration_API">VA-API</a>   </td><td class="markdownTableBodyNone">x86 Linux   </td><td class="markdownTableBodyNone">most GPUs   </td><td class="markdownTableBodyNone">VAAPI   </td></tr>
</table>
<p>Adding support for more is possible and should not be a big problem, but needs someone with the right hardware to verify the implementation.</p>
<p>The acceleration libraries may also need some drivers for them to work:</p>
<ul>
<li>NVEnc: <code>libnvidia-encode-*</code> or just CUDA runtime</li>
<li>VA-API: <code>libva-glx2</code>, <code>libva-drm2</code>, maybe also <code>libglvnd0</code></li>
<li>QSV: Unclear, usually works out of the box</li>
</ul>
<h2><a class="anchor" id="autotoc_md2-device-names"></a>
2. Device names</h2>
<p>If your computer has more GPUs, it is important to specify which one to use. Here are some basic naming rules:</p>
<ul>
<li>NVEnc<ul>
<li>Linux: Devices <code>/dev/nvidia0</code>, <code>/dev/nvidia1</code> etc. Beware that the numbers in names of these devices can differ from the numbers CUDA assigns the GPUs (CUDA orders the GPUs according to their compute capability, whereas numbering of these devices is probably by the order on PCI bus).</li>
<li>Windows: Devices are called the same as on Linux, even though such files do not exist in the system.</li>
</ul>
</li>
<li>QSV<ul>
<li>Windows: The devices are called just <code>0</code>, <code>1</code> and so on.</li>
<li>Linux: When using QSV on Linux, you can use VA-API device names.</li>
</ul>
</li>
<li>VA-API<ul>
<li>Linux:<ul>
<li>DRM: The devices are called <code>/dev/dri/renderD128</code>, <code>/dev/dri/renderD129</code> etc. DRM stands for Direct Rendering Manager, not Digital Rights Management To use these devices, make sure your user has write permissions to the device files. Ubuntu usually doesn't give write access to everybody, but just to members of the <code>video</code> group.</li>
<li>GLX: You can also pass an X-server string like <code>:0</code>, which means the encoder should use the GPU on which this X server is running (it needs to support the GLX extension). On headless machines, you should use DRM.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md3-using-hw-surface"></a>
3. Using HW surface</h2>
<p>The last thing you need to decide is whether the selected encoder should use a HW surface (pixel buffer) or the default CPU-located one. With most encoders, this is just a performance issue and they will work both with CPU and GPU surfaces.</p>
<p>It is best if you perform experiments with HW surface used and not used and compare the performance. Select the one that suits your use case better.</p>
<h2><a class="anchor" id="putting-it-together---configuration-via-environment-variables"></a>
Putting it together - configuration via environment variables</h2>
<p>To ease configuration of the HW-accelerated encoding, there doesn't have to be explicit support for it in the code using <code>VideoEncoder</code>. The code may concentrate on implementing the recording procedure itself, and completely ignore any HW acceleration of the recording process. Users of the code can then enable the HW acceleration just using these 3 environment variables:</p>
<h3><a class="anchor" id="gz_video_allowed_encoders"></a>
GZ_VIDEO_ALLOWED_ENCODERS</h3>
<p>This is the main variable that allows the <code>VideoEncoder</code> to probe for supported HW-accelerated encoders. It is a colon-separated list of names described in the table above. Example: <code>GZ_VIDEO_ALLOWED_ENCODERS=NVENC:QSV</code>. Special value <code>ALL</code> means that all encoders should be tried. Special value <code>NONE</code> (or empty value) means that a SW encoder should be used.</p>
<p>If more values are specified, the system will probe all the allowed encoders trying to start them up (if device is specified, then only with the given device). The first allowed encoder that successfully finishes the probe will be used.</p>
<p>The probing mechanism isn't 100% reliable. But it does what's reasonable to do in such an autodetection loop - it checks whether the required/supported device files exist, and if they do (or if there are no device files, as on Windows), the library tries to create an encoding context. If the context is successfully created, the encoder is considered working. Sometimes, something can go wrong in a later stage (e.g. insufficient GPU memory), and that is a kind of thing you have to handle yourself.</p>
<h3><a class="anchor" id="gz_video_encoder_device"></a>
GZ_VIDEO_ENCODER_DEVICE</h3>
<p>This is a name of the encoder device as specified in the "Device Names" section. If empty, first working device will be used. This auto detection should suffice on single-GPU systems or if you don't care which GPU will be used. If a device is specified, only encoders accepting this device name as an argument will be probed.</p>
<h3><a class="anchor" id="gz_video_use_hw_surface"></a>
GZ_VIDEO_USE_HW_SURFACE</h3>
<p>This variable has three possible values:</p>
<ul>
<li><code>1</code>: Explicitly tell the encoder to use a GPU-located buffer.</li>
<li><code>0</code>: Explicitly tell the encoder to use a CPU-located buffer.</li>
<li>empty: Let the library guess based on some pre-compiled hints.</li>
</ul>
<p>Refer to section "Using HW surface" for more in-depth description of the meaning of this variable. Usually, leaving it empty should be just fine.</p>
<h2><a class="anchor" id="configuration-in-code"></a>
Configuration in code</h2>
<p>These values can also be configured in code.</p>
<p>As stated earlier, if you use the standard 6-argument signature of <code>VideoEncoder::Start()</code>, configuration via the above described environment variables will be performed.</p>
<p>There are two more signatures:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span>: <span class="keywordtype">bool</span> Start(_format, _filename, _width, _height, _fps, _bitRate,</div>
<div class="line">                   <span class="keywordtype">bool</span> _allowHwAccel);</div>
</div><!-- fragment --><p>This signature added the <code>_allowHwAccel</code> boolean argument with which you can explicitly allow/disallow the configuration via environment variables.</p>
<p>Then there is the full signature:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span>: <span class="keywordtype">bool</span> Start(_format, _filename, _width, _height, _fps, _bitRate,</div>
<div class="line">                   <span class="keyword">const</span> FlagSet&lt;HWEncoderType&gt;&amp; _allowedHwAccel,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; _hwAccelDevice = <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">                   std::optional&lt;bool&gt; _useHwSurface = {})</div>
</div><!-- fragment --><p>The three added arguments correspond to the environment variables, but with this signature you can set their values from code (and environment variables will have no effect then). This would be useful if you want to e.g. implement a GUI chooser for the acceleration.</p>
<p>The <code>FlagSet&lt;HWEncoderType&gt;</code> captures a set of allowed encoders. Its value may be e.g. <code>gz::Common::HWEncoderType::QSV | gz::common::HWEncoderType::NVENC</code>.</p>
<h2><a class="anchor" id="how-do-i-know-its-working"></a>
How do I know it's working</h2>
<p>To make sure you configured the HW acceleration right, you may look at info-level messages where <code>VideoEncoder</code> documents the detected encoder. It may look like:</p>
<div class="fragment"><div class="line">[Msg] Recording started: 3078s (sim time), 42088s (real time)</div>
<div class="line">[GUI] [Msg] Recording video using sim time.</div>
<div class="line">[GUI] [Msg] Recording video in lockstep mode</div>
<div class="line">[GUI] [Msg] Recording video using bitrate: 8000000</div>
<div class="line">[GUI] [Msg] Found known HW encoder: h264_nvenc</div>
<div class="line">[GUI] [Msg] Initialized NVENC on device /dev/nvidia1</div>
<div class="line">[GUI] [Msg] Using encoder h264_nvenc</div>
<div class="line">[Msg] Recording stopped: 120s (sim time), 42413s (real time)</div>
</div><!-- fragment --><p>There you can see a NVEnc encoder was successfully used on card <code>/dev/nvidia1</code> to encode a 2-minute video clip.</p>
<p>If something goes wrong, you'll see a lot of error messages in the console. Sometimes they are helpful, sometimes they are not. In the very worst case, wrong configuration may lead to a segfault or any other kind of faulty behavior. This is also the reason why HW-acceleration isn't turned on by default.</p>
<p>This is what it looks like when the system cannot use any of the found devices, so it falls back to SW encoder:</p>
<div class="fragment"><div class="line">[Msg] Recording started: 2950s (sim time), 52132s (real time)</div>
<div class="line">[GUI] [Msg] Recording video using sim time.</div>
<div class="line">[GUI] [Msg] Recording video in lockstep mode</div>
<div class="line">[GUI] [Msg] Recording video using bitrate: 8000000</div>
<div class="line">[GUI] [Msg] Found known HW encoder: h264_nvenc</div>
<div class="line">[GUI] [Err] [Util.cc:58] ffmpeg [AVHWDeviceContext] Could not initialize the CUDA driver API</div>
<div class="line"> </div>
<div class="line">[GUI] [Err] [HWEncoder.cc:159] Could not initialize device /dev/nvidia3 for NVENC, skipping.</div>
<div class="line">[GUI] [Msg] Found known HW encoder: h264_omx</div>
<div class="line">[GUI] [Msg] Encoder h264_omx is not allowed, skipping.</div>
<div class="line">[GUI] [Msg] Found known HW encoder: h264_v4l2m2m</div>
<div class="line">[GUI] [Msg] Encoder h264_v4l2m2m is not allowed, skipping.</div>
<div class="line">[GUI] [Msg] Found known HW encoder: h264_vaapi</div>
<div class="line">[GUI] [Msg] Encoder h264_vaapi is not allowed, skipping.</div>
<div class="line">[GUI] [Msg] Found known HW encoder: nvenc</div>
<div class="line">[GUI] [Err] [Util.cc:58] ffmpeg [AVHWDeviceContext] Could not initialize the CUDA driver API</div>
<div class="line"> </div>
<div class="line">[GUI] [Err] [HWEncoder.cc:159] Could not initialize device /dev/nvidia3 for NVENC, skipping.</div>
<div class="line">[GUI] [Msg] Found known HW encoder: nvenc_h264</div>
<div class="line">[GUI] [Err] [Util.cc:58] ffmpeg [AVHWDeviceContext] Could not initialize the CUDA driver API</div>
<div class="line"> </div>
<div class="line">[GUI] [Err] [HWEncoder.cc:159] Could not initialize device /dev/nvidia3 for NVENC, skipping.</div>
<div class="line">[GUI] [Wrn] [HWEncoder.cc:384] No hardware-accelerated encoder found, falling back to software encoders</div>
<div class="line">[GUI] [Msg] Compatible SW encoder: libx264</div>
<div class="line">[GUI] [Msg] Using encoder libx264</div>
</div><!-- fragment --><h1><a class="anchor" id="examples"></a>
Examples</h1>
<p>Here are a few ready-made examples which might or might not work for you right-away. Just give them a try and dig deeper in the configuration if something is wrong.</p>
<h2><a class="anchor" id="linuxwin--intel-gpu"></a>
Linux/Win + Intel GPU</h2>
<pre class="fragment">GZ_VIDEO_ALLOWED_ENCODERS=QSV
</pre> <h2><a class="anchor" id="linuxwin--nvidia-gpu"></a>
Linux/Win + NVidia GPU</h2>
<pre class="fragment">GZ_VIDEO_ALLOWED_ENCODERS=NVENC
</pre> <h2><a class="anchor" id="linux--intelnvidia-gpu"></a>
Linux + Intel/NVidia GPU</h2>
<pre class="fragment">GZ_VIDEO_ALLOWED_ENCODERS=VAAPI
</pre> <h2><a class="anchor" id="linux-nvidia-multi-gpu-machine"></a>
Linux NVidia Multi-GPU machine</h2>
<pre class="fragment">GZ_VIDEO_ALLOWED_ENCODERS=NVENC GZ_VIDEO_ENCODER_DEVICE=/dev/nvidia2
</pre> <h1><a class="anchor" id="caveats"></a>
Caveats</h1>
<h2><a class="anchor" id="ffmpeg-on-windows-via-conda"></a>
FFMpeg on Windows via Conda</h2>
<p>The current distribution of FFMpeg via Conda for Windows does not include the h264_qsv encoder. It only has h264_nvenc. This means that using Intel GPUs for HW acceleration is not possible out of the box. A possible solution would be to build a custom build of ffmpeg in the workspace with gz-common. Pull requests with the relevant tutorial are welcome.</p>
<h2><a class="anchor" id="nvenc-per-machine-limit"></a>
NVEnc per-machine limit</h2>
<p>If you have a multi-GPU station with desktop-class (not server-class) GPUs, you will run into an artificial limitation from NVidia. You can only run 3 concurrent encoding sessions on one computer, no matter how many GPUs you have. The computer can even have 8 GPUs, but you will only be able to encode 3 videos at a time. The exact maxima of encoding sessions are described in <a href="https://developer.nvidia.com/video-encode-and-decode-gpu-support-matrix-new">this NVidia support page</a>.</p>
<p>To make things worse, there is no API that would tell you the number of currently running NVEnc sessions. The only way to find out you're launching the fourth is trying to start encoding and getting a memory allocation error. This library catches this error and writes a lengthy description of what might have just happened (either really low memory or this artificial limit). Unfortunately, when you start the doomed fourth encoding session, all the three "legal" sessions will crash. This might be really troublesome on e.g. multi-user systems when you don't even know which jobs of the other users are using NVEnc.</p>
<p>There is a workaround removing this artificial limit - patching the binary blob drivers using <a href="https://github.com/keylase/nvidia-patch">https://github.com/keylase/nvidia-patch</a> . This is an unofficial patch that is not supported by NVidia or the Gazebo developers. It is up to you if you can and want to do that. And there is no guarantee it will work forever. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
      </div>
    </main>
  </div>
</body>
