<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Common">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Common: SpecializedPlugin&lt; SpecInterface &gt; Class Template Reference</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Common</h1>
        <h2>API Reference</h2>
        <div class="version">
        3.17.0
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 IgnCreateDocs.cmake -->
      <nav class="ign-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.8.17 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceignition.html">ignition</a></li><li class="navelem"><a class="el" href="namespaceignition_1_1common.html">common</a></li><li class="navelem"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html">SpecializedPlugin&lt; SpecInterface &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">SpecializedPlugin&lt; SpecInterface &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class allows <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> instances to have high-speed access to interfaces that can be anticipated at compile time. The plugin does not have to actually offer the specialized interface in order to get this performance improvement. This template is variadic, so it can support arbitrarily many interfaces.  
 <a href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gz_2common_2SpecializedPlugin_8hh_source.html">SpecializedPlugin.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#af00a56f400aaf960349d00e50d8effd5">HasInterface</a> () const</td></tr>
<tr class="memdesc:af00a56f400aaf960349d00e50d8effd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> has the specified type of interface. Note that this function only works when the Interface type is specialized using the macro IGN_COMMON_SPECIALIZE_INTERFACE. For more general interfaces which do not meet this condition, use QueryInterface&lt;Interface&gt;(_interfaceName).  <a href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#af00a56f400aaf960349d00e50d8effd5">More...</a><br /></td></tr>
<tr class="separator:af00a56f400aaf960349d00e50d8effd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#af00a56f400aaf960349d00e50d8effd5">HasInterface</a> () const</td></tr>
<tr class="separator:af00a56f400aaf960349d00e50d8effd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2347b34b02cc7f61a8940dd31e9fb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#abb2347b34b02cc7f61a8940dd31e9fb7">HasInterface</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_interfaceName) const</td></tr>
<tr class="memdesc:abb2347b34b02cc7f61a8940dd31e9fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> has the specified type of interface, otherwise returns false.  <a href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#abb2347b34b02cc7f61a8940dd31e9fb7">More...</a><br /></td></tr>
<tr class="separator:abb2347b34b02cc7f61a8940dd31e9fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a5071a558207e3853ee0de5f5bcf66"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:aa5a5071a558207e3853ee0de5f5bcf66"><td class="memTemplItemLeft" align="right" valign="top">Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aa5a5071a558207e3853ee0de5f5bcf66">QueryInterface</a> ()</td></tr>
<tr class="memdesc:aa5a5071a558207e3853ee0de5f5bcf66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an interface of the specified type. Note that this function only works when the Interface type is specialized using the macro IGN_COMMON_SPECIALIZE_INTERFACE. For more general interfaces which do not meet this condition, use QueryInterface&lt;Interface&gt;(_interfaceName).  <a href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aa5a5071a558207e3853ee0de5f5bcf66">More...</a><br /></td></tr>
<tr class="separator:aa5a5071a558207e3853ee0de5f5bcf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a5071a558207e3853ee0de5f5bcf66"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:aa5a5071a558207e3853ee0de5f5bcf66"><td class="memTemplItemLeft" align="right" valign="top">Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aa5a5071a558207e3853ee0de5f5bcf66">QueryInterface</a> ()</td></tr>
<tr class="separator:aa5a5071a558207e3853ee0de5f5bcf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5dc9dd27c987508c981e6758901977"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:aed5dc9dd27c987508c981e6758901977"><td class="memTemplItemLeft" align="right" valign="top">const Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aed5dc9dd27c987508c981e6758901977">QueryInterface</a> () const</td></tr>
<tr class="memdesc:aed5dc9dd27c987508c981e6758901977"><td class="mdescLeft">&#160;</td><td class="mdescRight">const-qualified version of <a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aa5a5071a558207e3853ee0de5f5bcf66">QueryInterface&lt;Interface&gt;()</a>  <a href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aed5dc9dd27c987508c981e6758901977">More...</a><br /></td></tr>
<tr class="separator:aed5dc9dd27c987508c981e6758901977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5dc9dd27c987508c981e6758901977"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:aed5dc9dd27c987508c981e6758901977"><td class="memTemplItemLeft" align="right" valign="top">const Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aed5dc9dd27c987508c981e6758901977">QueryInterface</a> () const</td></tr>
<tr class="separator:aed5dc9dd27c987508c981e6758901977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a0e33d55983c48dc9dacfc249c181c"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:ab5a0e33d55983c48dc9dacfc249c181c"><td class="memTemplItemLeft" align="right" valign="top">Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#ab5a0e33d55983c48dc9dacfc249c181c">QueryInterface</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_interfaceName)</td></tr>
<tr class="memdesc:ab5a0e33d55983c48dc9dacfc249c181c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an interface with the given name, casted to the specified class type. The template argument Interface must exactly match the underlying type associated with _interfaceName, or else the behavior of this function is undefined.  <a href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#ab5a0e33d55983c48dc9dacfc249c181c">More...</a><br /></td></tr>
<tr class="separator:ab5a0e33d55983c48dc9dacfc249c181c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bb7779db1da9739a1939573fd86ce9"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a22bb7779db1da9739a1939573fd86ce9"><td class="memTemplItemLeft" align="right" valign="top">const Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a22bb7779db1da9739a1939573fd86ce9">QueryInterface</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_interfaceName) const</td></tr>
<tr class="memdesc:a22bb7779db1da9739a1939573fd86ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">const-qualified version of QueryInterface&lt;Interface&gt;(std::string)  <a href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a22bb7779db1da9739a1939573fd86ce9">More...</a><br /></td></tr>
<tr class="separator:a22bb7779db1da9739a1939573fd86ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7fa223a00dd4318c553261a71f7667"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a2d7fa223a00dd4318c553261a71f7667"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a2d7fa223a00dd4318c553261a71f7667">QueryInterfaceSharedPtr</a> ()</td></tr>
<tr class="memdesc:a2d7fa223a00dd4318c553261a71f7667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the requested interface as a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a>. Note that this function only works when the Interface type is specialized using the macro IGN_COMMON_SPECIALIZE_INTERFACE. For more general interfaces which do not meet this condition, use <a class="el" href="classignition_1_1common_1_1Plugin.html#ac73627617d3057442432c253685e7e1e" title="Get the requested interface as a std::shared_ptr. The template argument Interface must exactly match ...">QueryInterfaceSharedPtr&lt;Interface&gt;(const std::string&amp;)</a>.  <a href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a2d7fa223a00dd4318c553261a71f7667">More...</a><br /></td></tr>
<tr class="separator:a2d7fa223a00dd4318c553261a71f7667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7fa223a00dd4318c553261a71f7667"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a2d7fa223a00dd4318c553261a71f7667"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a2d7fa223a00dd4318c553261a71f7667">QueryInterfaceSharedPtr</a> ()</td></tr>
<tr class="separator:a2d7fa223a00dd4318c553261a71f7667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afffd600bbbea21b4cdc35180e0ded3"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a8afffd600bbbea21b4cdc35180e0ded3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; const Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a8afffd600bbbea21b4cdc35180e0ded3">QueryInterfaceSharedPtr</a> () const</td></tr>
<tr class="memdesc:a8afffd600bbbea21b4cdc35180e0ded3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a2d7fa223a00dd4318c553261a71f7667">QueryInterfaceSharedPtr&lt;Interface&gt;()</a>, but it returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a> to a const-qualified Interface.  <a href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a8afffd600bbbea21b4cdc35180e0ded3">More...</a><br /></td></tr>
<tr class="separator:a8afffd600bbbea21b4cdc35180e0ded3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afffd600bbbea21b4cdc35180e0ded3"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a8afffd600bbbea21b4cdc35180e0ded3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; const Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a8afffd600bbbea21b4cdc35180e0ded3">QueryInterfaceSharedPtr</a> () const</td></tr>
<tr class="separator:a8afffd600bbbea21b4cdc35180e0ded3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73627617d3057442432c253685e7e1e"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:ac73627617d3057442432c253685e7e1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#ac73627617d3057442432c253685e7e1e">QueryInterfaceSharedPtr</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_interfaceName)</td></tr>
<tr class="memdesc:ac73627617d3057442432c253685e7e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the requested interface as a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a>. The template argument Interface must exactly match the underlying type associated with _interfaceName, or else the behavior of this function is undefined.  <a href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#ac73627617d3057442432c253685e7e1e">More...</a><br /></td></tr>
<tr class="separator:ac73627617d3057442432c253685e7e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86802de77c6ec4d0fab4ff15e1497358"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a86802de77c6ec4d0fab4ff15e1497358"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; const Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a86802de77c6ec4d0fab4ff15e1497358">QueryInterfaceSharedPtr</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_interfaceName) const</td></tr>
<tr class="memdesc:a86802de77c6ec4d0fab4ff15e1497358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as QueryInterfaceSharedPtr&lt;Interface&gt;(std::string), but it returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a> to a const-qualified Interface.  <a href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a86802de77c6ec4d0fab4ff15e1497358">More...</a><br /></td></tr>
<tr class="separator:a86802de77c6ec4d0fab4ff15e1497358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classignition_1_1common_1_1Plugin"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classignition_1_1common_1_1Plugin')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a></td></tr>
<tr class="memitem:a96cbafa7a127c08d0b97e147f129f5a7 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1Plugin.html#a96cbafa7a127c08d0b97e147f129f5a7">~Plugin</a> ()</td></tr>
<tr class="memdesc:a96cbafa7a127c08d0b97e147f129f5a7 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="classignition_1_1common_1_1Plugin.html#a96cbafa7a127c08d0b97e147f129f5a7">More...</a><br /></td></tr>
<tr class="separator:a96cbafa7a127c08d0b97e147f129f5a7 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1Plugin.html#af00a56f400aaf960349d00e50d8effd5">HasInterface</a> () const</td></tr>
<tr class="memdesc:af00a56f400aaf960349d00e50d8effd5 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> has the specified type of interface. Note that this function only works when the Interface type is specialized using the macro IGN_COMMON_SPECIALIZE_INTERFACE. For more general interfaces which do not meet this condition, use QueryInterface&lt;Interface&gt;(_interfaceName).  <a href="classignition_1_1common_1_1Plugin.html#af00a56f400aaf960349d00e50d8effd5">More...</a><br /></td></tr>
<tr class="separator:af00a56f400aaf960349d00e50d8effd5 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2347b34b02cc7f61a8940dd31e9fb7 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1Plugin.html#abb2347b34b02cc7f61a8940dd31e9fb7">HasInterface</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_interfaceName) const</td></tr>
<tr class="memdesc:abb2347b34b02cc7f61a8940dd31e9fb7 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> has the specified type of interface, otherwise returns false.  <a href="classignition_1_1common_1_1Plugin.html#abb2347b34b02cc7f61a8940dd31e9fb7">More...</a><br /></td></tr>
<tr class="separator:abb2347b34b02cc7f61a8940dd31e9fb7 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a5071a558207e3853ee0de5f5bcf66 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:aa5a5071a558207e3853ee0de5f5bcf66 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top">Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1Plugin.html#aa5a5071a558207e3853ee0de5f5bcf66">QueryInterface</a> ()</td></tr>
<tr class="memdesc:aa5a5071a558207e3853ee0de5f5bcf66 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an interface of the specified type. Note that this function only works when the Interface type is specialized using the macro IGN_COMMON_SPECIALIZE_INTERFACE. For more general interfaces which do not meet this condition, use QueryInterface&lt;Interface&gt;(_interfaceName).  <a href="classignition_1_1common_1_1Plugin.html#aa5a5071a558207e3853ee0de5f5bcf66">More...</a><br /></td></tr>
<tr class="separator:aa5a5071a558207e3853ee0de5f5bcf66 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5dc9dd27c987508c981e6758901977 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:aed5dc9dd27c987508c981e6758901977 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top">const Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1Plugin.html#aed5dc9dd27c987508c981e6758901977">QueryInterface</a> () const</td></tr>
<tr class="memdesc:aed5dc9dd27c987508c981e6758901977 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">const-qualified version of <a class="el" href="classignition_1_1common_1_1Plugin.html#aa5a5071a558207e3853ee0de5f5bcf66" title="Get an interface of the specified type. Note that this function only works when the Interface type is...">QueryInterface&lt;Interface&gt;()</a>  <a href="classignition_1_1common_1_1Plugin.html#aed5dc9dd27c987508c981e6758901977">More...</a><br /></td></tr>
<tr class="separator:aed5dc9dd27c987508c981e6758901977 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a0e33d55983c48dc9dacfc249c181c inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:ab5a0e33d55983c48dc9dacfc249c181c inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top">Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1Plugin.html#ab5a0e33d55983c48dc9dacfc249c181c">QueryInterface</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_interfaceName)</td></tr>
<tr class="memdesc:ab5a0e33d55983c48dc9dacfc249c181c inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an interface with the given name, casted to the specified class type. The template argument Interface must exactly match the underlying type associated with _interfaceName, or else the behavior of this function is undefined.  <a href="classignition_1_1common_1_1Plugin.html#ab5a0e33d55983c48dc9dacfc249c181c">More...</a><br /></td></tr>
<tr class="separator:ab5a0e33d55983c48dc9dacfc249c181c inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bb7779db1da9739a1939573fd86ce9 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a22bb7779db1da9739a1939573fd86ce9 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top">const Interface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1Plugin.html#a22bb7779db1da9739a1939573fd86ce9">QueryInterface</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_interfaceName) const</td></tr>
<tr class="memdesc:a22bb7779db1da9739a1939573fd86ce9 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">const-qualified version of QueryInterface&lt;Interface&gt;(std::string)  <a href="classignition_1_1common_1_1Plugin.html#a22bb7779db1da9739a1939573fd86ce9">More...</a><br /></td></tr>
<tr class="separator:a22bb7779db1da9739a1939573fd86ce9 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7fa223a00dd4318c553261a71f7667 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a2d7fa223a00dd4318c553261a71f7667 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1Plugin.html#a2d7fa223a00dd4318c553261a71f7667">QueryInterfaceSharedPtr</a> ()</td></tr>
<tr class="memdesc:a2d7fa223a00dd4318c553261a71f7667 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the requested interface as a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a>. Note that this function only works when the Interface type is specialized using the macro IGN_COMMON_SPECIALIZE_INTERFACE. For more general interfaces which do not meet this condition, use <a class="el" href="classignition_1_1common_1_1Plugin.html#ac73627617d3057442432c253685e7e1e" title="Get the requested interface as a std::shared_ptr. The template argument Interface must exactly match ...">QueryInterfaceSharedPtr&lt;Interface&gt;(const std::string&amp;)</a>.  <a href="classignition_1_1common_1_1Plugin.html#a2d7fa223a00dd4318c553261a71f7667">More...</a><br /></td></tr>
<tr class="separator:a2d7fa223a00dd4318c553261a71f7667 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afffd600bbbea21b4cdc35180e0ded3 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a8afffd600bbbea21b4cdc35180e0ded3 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; const Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1Plugin.html#a8afffd600bbbea21b4cdc35180e0ded3">QueryInterfaceSharedPtr</a> () const</td></tr>
<tr class="memdesc:a8afffd600bbbea21b4cdc35180e0ded3 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classignition_1_1common_1_1Plugin.html#a2d7fa223a00dd4318c553261a71f7667" title="Get the requested interface as a std::shared_ptr. Note that this function only works when the Interfa...">QueryInterfaceSharedPtr&lt;Interface&gt;()</a>, but it returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a> to a const-qualified Interface.  <a href="classignition_1_1common_1_1Plugin.html#a8afffd600bbbea21b4cdc35180e0ded3">More...</a><br /></td></tr>
<tr class="separator:a8afffd600bbbea21b4cdc35180e0ded3 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73627617d3057442432c253685e7e1e inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:ac73627617d3057442432c253685e7e1e inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1Plugin.html#ac73627617d3057442432c253685e7e1e">QueryInterfaceSharedPtr</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_interfaceName)</td></tr>
<tr class="memdesc:ac73627617d3057442432c253685e7e1e inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the requested interface as a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a>. The template argument Interface must exactly match the underlying type associated with _interfaceName, or else the behavior of this function is undefined.  <a href="classignition_1_1common_1_1Plugin.html#ac73627617d3057442432c253685e7e1e">More...</a><br /></td></tr>
<tr class="separator:ac73627617d3057442432c253685e7e1e inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86802de77c6ec4d0fab4ff15e1497358 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplParams" colspan="2">template&lt;class Interface &gt; </td></tr>
<tr class="memitem:a86802de77c6ec4d0fab4ff15e1497358 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; const Interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1Plugin.html#a86802de77c6ec4d0fab4ff15e1497358">QueryInterfaceSharedPtr</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_interfaceName) const</td></tr>
<tr class="memdesc:a86802de77c6ec4d0fab4ff15e1497358 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as QueryInterfaceSharedPtr&lt;Interface&gt;(std::string), but it returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a> to a const-qualified Interface.  <a href="classignition_1_1common_1_1Plugin.html#a86802de77c6ec4d0fab4ff15e1497358">More...</a><br /></td></tr>
<tr class="separator:a86802de77c6ec4d0fab4ff15e1497358 inherit pub_methods_classignition_1_1common_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classignition_1_1common_1_1Plugin"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classignition_1_1common_1_1Plugin')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a></td></tr>
<tr class="memitem:ad29972cd94d07457a34e116440b6a7fd inherit pub_types_classignition_1_1common_1_1Plugin"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1common_1_1Plugin.html#ad29972cd94d07457a34e116440b6a7fd">InterfaceMap</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, void * &gt;</td></tr>
<tr class="memdesc:ad29972cd94d07457a34e116440b6a7fd inherit pub_types_classignition_1_1common_1_1Plugin"><td class="mdescLeft">&#160;</td><td class="mdescRight">The InterfaceMap type needs to get used in several places, like PluginPrivate and SpecializedPlugin&lt;T&gt;. We make the typedef public so that those other classes can use it without needing to be friends of <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a>. End-users should not have any need for this typedef.  <a href="classignition_1_1common_1_1Plugin.html#ad29972cd94d07457a34e116440b6a7fd">More...</a><br /></td></tr>
<tr class="separator:ad29972cd94d07457a34e116440b6a7fd inherit pub_types_classignition_1_1common_1_1Plugin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class SpecInterface&gt;<br />
class ignition::common::SpecializedPlugin&lt; SpecInterface &gt;</h3>

<p>This class allows <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> instances to have high-speed access to interfaces that can be anticipated at compile time. The plugin does not have to actually offer the specialized interface in order to get this performance improvement. This template is variadic, so it can support arbitrarily many interfaces. </p>
<p>Usage example:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> MySpecialPluginPtr = <a class="code" href="namespaceignition_1_1common.html#a71ecee778dbdcaee4977cedd7341ef55">SpecializedPluginPtr</a>&lt;</div>
<div class="line">    MyInterface1, FooInterface, MyInterface2, BarInterface&gt;;</div>
<div class="line"> </div>
<div class="line">MySpecialPluginPtr plugin = loader-&gt;Instantiate(pluginName);</div>
</div><!-- fragment --><p>Then, calling the function</p>
<div class="fragment"><div class="line">plugin-&gt;QueryInterface&lt;FooInterface&gt;();</div>
</div><!-- fragment --><p>will have extremely high-speed associated with it. It will provide direct access to the the <code>FooInterface*</code> of <code>plugin</code>. If <code>plugin</code> does not actually offer <code>FooInterface</code>, then it will return a nullptr, still at extremely high speed.</p>
<p>Only interfaces that have been "specialized" can be passed as arguments to the <a class="el" href="classignition_1_1common_1_1SpecializedPlugin.html">SpecializedPlugin</a> template. To specialize an interface, simply put the macro IGN_COMMON_SPECIALIZE_INTERFACE(~) from <a class="el" href="ignition_2common_2PluginMacros_8hh.html">ignition/common/PluginMacros.hh</a> into a public location of its class definition. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af00a56f400aaf960349d00e50d8effd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00a56f400aaf960349d00e50d8effd5">&#9670;&nbsp;</a></span>HasInterface() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasInterface </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> has the specified type of interface. Note that this function only works when the Interface type is specialized using the macro IGN_COMMON_SPECIALIZE_INTERFACE. For more general interfaces which do not meet this condition, use QueryInterface&lt;Interface&gt;(_interfaceName). </p>

</div>
</div>
<a id="af00a56f400aaf960349d00e50d8effd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00a56f400aaf960349d00e50d8effd5">&#9670;&nbsp;</a></span>HasInterface() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb2347b34b02cc7f61a8940dd31e9fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2347b34b02cc7f61a8940dd31e9fb7">&#9670;&nbsp;</a></span>HasInterface() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasInterface</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> has the specified type of interface, otherwise returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_interfaceName</td><td>The name of the desired interface, as a string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5a5071a558207e3853ee0de5f5bcf66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a5071a558207e3853ee0de5f5bcf66">&#9670;&nbsp;</a></span>QueryInterface() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Interface* QueryInterface </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an interface of the specified type. Note that this function only works when the Interface type is specialized using the macro IGN_COMMON_SPECIALIZE_INTERFACE. For more general interfaces which do not meet this condition, use QueryInterface&lt;Interface&gt;(_interfaceName). </p>
<p>Note that the interface pointer you receive is owned by the <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> object. You MUST NOT ever try to deallocate it yourself. Moreover, the pointer will be invalidated once all <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> objects that refer to the same <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> instance are destructed. Use the QueryInterfaceSharedPtr function in order to get a reference-counting pointer to an interface of this <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> object. The pointer will remain valid as long as the <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a> provided by QueryInterfaceSharedPtr is alive. </p>

</div>
</div>
<a id="aa5a5071a558207e3853ee0de5f5bcf66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a5071a558207e3853ee0de5f5bcf66">&#9670;&nbsp;</a></span>QueryInterface() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Interface* QueryInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed5dc9dd27c987508c981e6758901977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5dc9dd27c987508c981e6758901977">&#9670;&nbsp;</a></span>QueryInterface() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Interface* QueryInterface </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const-qualified version of <a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#aa5a5071a558207e3853ee0de5f5bcf66">QueryInterface&lt;Interface&gt;()</a> </p>

</div>
</div>
<a id="aed5dc9dd27c987508c981e6758901977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5dc9dd27c987508c981e6758901977">&#9670;&nbsp;</a></span>QueryInterface() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Interface* QueryInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5a0e33d55983c48dc9dacfc249c181c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a0e33d55983c48dc9dacfc249c181c">&#9670;&nbsp;</a></span>QueryInterface() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Interface* QueryInterface </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an interface with the given name, casted to the specified class type. The template argument Interface must exactly match the underlying type associated with _interfaceName, or else the behavior of this function is undefined. </p>
<p>Note that the interface pointer you receive is owned by the <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> object. You MUST NOT ever try to deallocate it yourself. Moreover, the pointer will be invalidated once all <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> objects that refer to the same <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> instance are destructed. Use the QueryInterfaceSharedPtr function in order to get a reference-counting pointer to an interface of this <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> object. The pointer will remain valid as long as the <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a> provided by QueryInterfaceSharedPtr is alive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_interfaceName</td><td>The name of the desired interface, as a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A raw pointer to the specified interface. If the requested _interfaceName is not provided by this <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a>, this returns a nullptr. This pointer is invalidated when the reference count of the plugin instance drops to zero. </dd></dl>

</div>
</div>
<a id="a22bb7779db1da9739a1939573fd86ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bb7779db1da9739a1939573fd86ce9">&#9670;&nbsp;</a></span>QueryInterface() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Interface* QueryInterface </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const-qualified version of QueryInterface&lt;Interface&gt;(std::string) </p>

</div>
</div>
<a id="a2d7fa223a00dd4318c553261a71f7667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7fa223a00dd4318c553261a71f7667">&#9670;&nbsp;</a></span>QueryInterfaceSharedPtr() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;Interface&gt; QueryInterfaceSharedPtr </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the requested interface as a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a>. Note that this function only works when the Interface type is specialized using the macro IGN_COMMON_SPECIALIZE_INTERFACE. For more general interfaces which do not meet this condition, use <a class="el" href="classignition_1_1common_1_1Plugin.html#ac73627617d3057442432c253685e7e1e" title="Get the requested interface as a std::shared_ptr. The template argument Interface must exactly match ...">QueryInterfaceSharedPtr&lt;Interface&gt;(const std::string&amp;)</a>. </p>

</div>
</div>
<a id="a2d7fa223a00dd4318c553261a71f7667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7fa223a00dd4318c553261a71f7667">&#9670;&nbsp;</a></span>QueryInterfaceSharedPtr() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;Interface&gt; QueryInterfaceSharedPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8afffd600bbbea21b4cdc35180e0ded3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afffd600bbbea21b4cdc35180e0ded3">&#9670;&nbsp;</a></span>QueryInterfaceSharedPtr() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;const Interface&gt; QueryInterfaceSharedPtr </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classignition_1_1common_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#a2d7fa223a00dd4318c553261a71f7667">QueryInterfaceSharedPtr&lt;Interface&gt;()</a>, but it returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a> to a const-qualified Interface. </p>

</div>
</div>
<a id="a8afffd600bbbea21b4cdc35180e0ded3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afffd600bbbea21b4cdc35180e0ded3">&#9670;&nbsp;</a></span>QueryInterfaceSharedPtr() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;const Interface&gt; QueryInterfaceSharedPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac73627617d3057442432c253685e7e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73627617d3057442432c253685e7e1e">&#9670;&nbsp;</a></span>QueryInterfaceSharedPtr() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;Interface&gt; QueryInterfaceSharedPtr </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the requested interface as a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a>. The template argument Interface must exactly match the underlying type associated with _interfaceName, or else the behavior of this function is undefined. </p>
<p>This <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a> and the interface+plugin that it refers to will remain valid, even if all <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> objects which refer to the plugin instance are destructed.</p>
<p>You MUST NOT attempt to pass a QueryInterface pointer into a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a> yourself; that will result in double-delete memory errors. You must always call QueryInterfaceSharedPtr for a reference- counting pointer to an interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_interfaceName</td><td>The name of the desired interface, as a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference-counting pointer to the specified interface. This will keep the interface valid and the plugin instance alive, even if all <a class="el" href="classignition_1_1common_1_1Plugin.html">Plugin</a> objects that refer to this plugin instance are destructed. </dd></dl>

</div>
</div>
<a id="a86802de77c6ec4d0fab4ff15e1497358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86802de77c6ec4d0fab4ff15e1497358">&#9670;&nbsp;</a></span>QueryInterfaceSharedPtr() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;const Interface&gt; QueryInterfaceSharedPtr </td>
          <td>(</td>
          <td class="paramtype">class Interface&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as QueryInterfaceSharedPtr&lt;Interface&gt;(std::string), but it returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html" title="STL class.">std::shared_ptr</a> to a const-qualified Interface. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="gz_2common_2SpecializedPlugin_8hh_source.html">gz/common/SpecializedPlugin.hh</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="anamespaceignition_1_1common_html_a71ecee778dbdcaee4977cedd7341ef55"><div class="ttname"><a href="namespaceignition_1_1common.html#a71ecee778dbdcaee4977cedd7341ef55">ignition::common::SpecializedPluginPtr</a></div><div class="ttdeci">TemplatePluginPtr&lt; SpecializedPlugin&lt; SpecInterfaces... &gt; &gt; SpecializedPluginPtr</div><div class="ttdoc">This alias allows PluginPtr instances to have high-speed access to interfaces that can be anticipated...</div><div class="ttdef"><b>Definition:</b> gz/common/SpecializedPluginPtr.hh:71</div></div>
      </div>
    </main>
  </div>
</body>
