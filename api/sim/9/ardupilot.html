<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Sim">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Sim: Case study: migrating the ArduPilot ModelPlugin from Gazebo classic to Gazebo</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Sim</h1>
        <h2>API Reference</h2>
        <div class="version">
        9.0.0
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Case study: migrating the ArduPilot ModelPlugin from Gazebo classic to Gazebo</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A variety of changes are required when migrating a plugin from Gazebo classic to Gazebo. In this tutorial we offer as a case study the migration of one particular <code>ModelPlugin</code>, <a href="https://github.com/khancyr/ardupilot_gazebo">ardupilot_gazebo</a>. We hope that this example provides useful tips to others who are migrating their existing plugins from classic to Gazebo.</p>
<p>The complete, migrated version of the <code>ardupilot_gazebo</code> plugin covered in this tutorial can be found in <a href="https://github.com/gerkey/ardupilot_gazebo/tree/ignition">this fork</a>.</p>
<h2><a class="anchor" id="autotoc_md178"></a>
Background</h2>
<p>The <code>ardupilot_gazebo</code> plugin is used with Gazebo to assist with simulating aerial vehicles (aka drones). For more information on how to use it, check the <a href="https://ardupilot.org/dev/docs/using-gazebo-simulator-with-sitl.html">ArduPilot documentation</a>.</p>
<p>As context to understand what we're migrating, here's a system diagram for how the ArduPilot Gazebo plugin works is used:</p>
<p><img src="https://raw.githubusercontent.com/gazebosim/gz-sim/main/tutorials/files/ardupilot_diagram.png" alt="" class="inline"/></p>
<p><em>UAV icon credit: By Julian Herzog, CC BY 4.0, <a href="https://commons.wikimedia.org/w/index.php?curid=60965475">https://commons.wikimedia.org/w/index.php?curid=60965475</a></em></p>
<p>For each UAV model in simulation, there is one instance of ArduPilotPlugin loaded into the simulation process. That plugin uses internal simulation APIs to retrieve the UAV's current state, which it sends to an external ArduPilot process via a custom UDP protocol (it's called Flight Dynamics Model, or FDM). The ArduPilot process in turn makes the vehicle state available via the MAVLink protocol to other processes, such as QGroundControl (QGC). The user can issue commands in QGC like "take off" or "goto waypoint", which are sent via MAVLink to ArduPilot, which computes motor commands and sends them to the plugin, which passes them onto the vehicle via internal simulation APIs.</p>
<p>To be clear, this structure is pre-existing and widely used in UAV simulation. Our contribution in this tutorial is port the plugin from Gazebo classic to Gazebo, preserving the rest of the setup.</p>
<h2><a class="anchor" id="autotoc_md179"></a>
Structure of the migration</h2>
<p>Migration of this plugin involves modifications to multiple parts of the associated code:</p>
<ol type="1">
<li>The plugin header file, <code>ArduPilotPlugin.hh</code></li>
<li>The plugin source file, <code>ArduPilotPlugin.cc</code></li>
<li>The plugin's CMake build recipe, <code>CMakeLists.txt</code></li>
<li>The custom model in which the plugin is used</li>
</ol>
<p>We'll take them each in turn in the following sections.</p>
<h2><a class="anchor" id="autotoc_md180"></a>
Plugin header file (ArduPilotPlugin.hh)</h2>
<h3><a class="anchor" id="autotoc_md181"></a>
Headers</h3>
<p>The old code includes these Gazebo classic headers:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="preprocessor">#include &lt;sdf/sdf.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/common/common.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/physics/physics.hh&gt;</span></div>
</div><!-- fragment --><p>In the new code, we still need <code>&lt;sdf/sdf.hh&gt;</code>, because the underlying <a href="http://sdformat.org/">SDFormat library</a> is used by both classic and Gazebo. But in place of the <code>&lt;gazebo/...&gt;</code> headers, we'll pull in one from Gazebo:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="System_8hh.html">gz/sim/System.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sdf/sdf.hh&gt;</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md182"></a>
Class declaration</h3>
<p>In the old code, the plugin class <code>ArduPilotPlugin</code> is declared in the <code>gazebo</code> namespace: </p><div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">namespace </span>sim</div>
<div class="line">{</div>
</div><!-- fragment --><p>In the new code we declare the class in the <code><a class="el" href="namespacegz_1_1sim_1_1systems.html" title="Namespace for all System plugins. Refer to the System class for more information about systems.">gz::sim::systems</a></code> namespace:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacegz.html" title="This library is part of the Gazebo project.">gz</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">namespace </span>sim</div>
<div class="line">{</div>
<div class="line"><span class="keyword">namespace </span>systems</div>
<div class="line">{</div>
</div><!-- fragment --><p>In the old code, the plugin class inherits from <code>ModelPlugin</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">class </span>GAZEBO_VISIBLE ArduPilotPlugin : <span class="keyword">public</span> ModelPlugin</div>
</div><!-- fragment --><p>In the new code, we use multiple inheritance to declare that our plugin will act as a <em>system</em> (in the entity-component-system, or ECS, pattern used by Gazebo), and further which interfaces of a system it will use (we also update the symbol visibility macro):</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keyword">class </span>GZ_SIM_VISIBLE ArduPilotPlugin:</div>
<div class="line">       <span class="keyword">public</span> <a class="code hl_class" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">gz::sim::System</a>,</div>
<div class="line">       <span class="keyword">public</span> <a class="code hl_class" href="classgz_1_1sim_1_1ISystemConfigure.html" title="Interface for a system that implements optional configuration.">gz::sim::ISystemConfigure</a>,</div>
<div class="line">       <span class="keyword">public</span> <a class="code hl_class" href="classgz_1_1sim_1_1ISystemPostUpdate.html" title="Interface for a system that uses the PostUpdate phase.">gz::sim::ISystemPostUpdate</a>,</div>
<div class="line">       <span class="keyword">public</span> <a class="code hl_class" href="classgz_1_1sim_1_1ISystemPreUpdate.html" title="Interface for a system that uses the PreUpdate phase.">gz::sim::ISystemPreUpdate</a></div>
</div><!-- fragment --><p>With this declaration we're indicating that our plugin will supply implementation of the <code>Configure()</code>, <code>PreUpdate()</code>, and <code>PostUpdate()</code> methods.</p>
<p>In the old code, the <code>Load()</code> method is called once for each instance of the plugin that is loaded, allowing for startup configuration, like pulling parameters out of the plugin's SDF configuration:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> Load(physics::ModelPtr _model, sdf::ElementPtr _sdf);</div>
</div><!-- fragment --><p>In the new code, we use <code>Configure()</code> for the same purpose (if a different signature):</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordtype">void</span> Configure(<span class="keyword">const</span> <a class="code hl_typedef" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d" title="An Entity identifies a single object in simulation such as a model, link, or light....">gz::sim::Entity</a> &amp;_entity,</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr&lt;const sdf::Element&gt;</a> &amp;_sdf,</div>
<div class="line">  <a class="code hl_class" href="classgz_1_1sim_1_1EntityComponentManager.html" title="The EntityComponentManager constructs, deletes, and returns components and entities....">gz::sim::EntityComponentManager</a> &amp;_ecm,</div>
<div class="line">  <a class="code hl_class" href="classgz_1_1sim_1_1EventManager.html" title="The EventManager is used to send/receive notifications of simulator events.">gz::sim::EventManager</a> &amp;_eventMgr);</div>
</div><!-- fragment --><p>Similarly, the old code provides <code>OnUpdate()</code>, which is called once per time step while simulation is running:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keywordtype">void</span> OnUpdate();</div>
</div><!-- fragment --><p>In the new code, this method is replaced by two methods, <code>PreUpdate()</code> and <code>PostUpdate()</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordtype">void</span> PreUpdate(<span class="keyword">const</span> <a class="code hl_struct" href="structgz_1_1sim_1_1UpdateInfo.html" title="Information passed to systems on the update callback.">gz::sim::UpdateInfo</a> &amp;_info,</div>
<div class="line">  <a class="code hl_class" href="classgz_1_1sim_1_1EntityComponentManager.html" title="The EntityComponentManager constructs, deletes, and returns components and entities....">gz::sim::EntityComponentManager</a> &amp;_ecm);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PostUpdate(<span class="keyword">const</span> <a class="code hl_struct" href="structgz_1_1sim_1_1UpdateInfo.html" title="Information passed to systems on the update callback.">gz::sim::UpdateInfo</a> &amp;_info,</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classgz_1_1sim_1_1EntityComponentManager.html" title="The EntityComponentManager constructs, deletes, and returns components and entities....">gz::sim::EntityComponentManager</a> &amp;_ecm);</div>
</div><!-- fragment --><p>As the names suggest, the former is called before each time step, while the latter is called after each time step. Note the subtle difference in signature: <code>PreUpdate()</code> takes a non-<code>const</code> reference to the <code>EntityComponentManager</code>, while <code>PostUpdate()</code> takes a <code>const</code> reference to it. We'll make any changes to the state of simulation (e.g., setting torques on joints) in <code>PreUpdate()</code> and we'll read out results from simulation (e.g., getting the pose of a link) in <code>PostUpdate()</code>.</p>
<p>The remaining changes in the header are just bookkeeping, to allow us to have access to the right objects with the right types in other class methods. These three helpers:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keywordtype">void</span> ApplyMotorForces(<span class="keyword">const</span> <span class="keywordtype">double</span> _dt);</div>
<div class="line"><span class="keywordtype">void</span> SendState();</div>
<div class="line"><span class="keywordtype">bool</span> InitArduPilotSockets(sdf::ElementPtr _sdf);</div>
</div><!-- fragment --><p>become:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordtype">void</span> ApplyMotorForces(<span class="keyword">const</span> <span class="keywordtype">double</span> _dt,</div>
<div class="line">  <a class="code hl_class" href="classgz_1_1sim_1_1EntityComponentManager.html" title="The EntityComponentManager constructs, deletes, and returns components and entities....">gz::sim::EntityComponentManager</a> &amp;_ecm);</div>
<div class="line"><span class="keywordtype">void</span> SendState(<span class="keywordtype">double</span> _simTime,</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classgz_1_1sim_1_1EntityComponentManager.html" title="The EntityComponentManager constructs, deletes, and returns components and entities....">gz::sim::EntityComponentManager</a> &amp;_ecm);</div>
<div class="line"><span class="keywordtype">bool</span> InitArduPilotSockets(<span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr&lt;const sdf::Element&gt;</a> &amp;_sdf);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md183"></a>
Plugin source file (ArduPilotPlugin.cc)</h2>
<h3><a class="anchor" id="autotoc_md184"></a>
Headers</h3>
<p>The old code includes these Gazebo-related headers:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="preprocessor">#include &lt;sdf/sdf.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="https://gazebosim.org/api/math/8/Filter_8hh.html">gz/math/Filter.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/common/Assert.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/common/Plugin.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/msgs/msgs.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/sensors/sensors.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/transport/transport.hh&gt;</span></div>
</div><!-- fragment --><p>Like we did in <code>ArduPilotPlugin.hh</code>, we'll keep <code>&lt;sdf/sdf.hh&gt;</code>. The others are replaced with Gazebo equivalents, and where possible we narrow the inclusion to exactly what we need. We start by enumerating those <em>components</em> (part of the ECS pattern used by Gazebo) that we're using:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="AngularVelocity_8hh.html">gz/sim/components/AngularVelocity.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2gz_2sim_2components_2Imu_8hh.html">gz/sim/components/Imu.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="JointForceCmd_8hh.html">gz/sim/components/JointForceCmd.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="JointPosition_8hh.html">gz/sim/components/JointPosition.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="JointVelocity_8hh.html">gz/sim/components/JointVelocity.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="JointVelocityCmd_8hh.html">gz/sim/components/JointVelocityCmd.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="LinearVelocity_8hh.html">gz/sim/components/LinearVelocity.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Name_8hh.html">gz/sim/components/Name.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Pose_8hh.html">gz/sim/components/Pose.hh</a>&gt;</span></div>
</div><!-- fragment --><p>To better understand the ECS pattern as it is used in Gazebo, it's helpful to learn about the EntityComponentManager (ECM), which is responsible for managing the ECS graph. A great resource to understand the logic under the hood of the ECM is the <code>SdfEntityCreator</code> class (<a href="https://github.com/gazebosim/gz-sim/blob/main/include/gz/sim/SdfEntityCreator.hh">header</a>, <a href="https://github.com/gazebosim/gz-sim/blob/main/src/SdfEntityCreator.cc">source</a>). This class is responsible for mapping the content of an SDF file to the entities and components that form the graph handled by the ECM. For example, if you wonder which components can be accessed by default from the plugin, this class is the best entry point.</p>
<p>Next we include the parts of <code>gz-sim</code> itself that we're using:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Model_8hh.html">gz/sim/Model.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Util_8hh.html">gz/sim/Util.hh</a>&gt;</span></div>
</div><!-- fragment --><p>We need a few things from <code>gz-math</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="https://gazebosim.org/api/math/8/Helpers_8hh.html">gz/math/Helpers.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="https://gazebosim.org/api/math/8/Pose3_8hh.html">gz/math/Pose3.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="https://gazebosim.org/api/math/8/PID_8hh.html">gz/math/PID.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="https://gazebosim.org/api/math/8/Vector3_8hh.html">gz/math/Vector3.hh</a>&gt;</span></div>
</div><!-- fragment --><p>To use the <code><a class="elRef" href="https://gazebosim.org/api/plugin/3/Register_8hh.html#a80cacf59ebf9a4726bb47860ff177542">GZ_ADD_PLUGIN()</a></code> and <code><a class="elRef" href="https://gazebosim.org/api/plugin/3/Register_8hh.html#a899a1e669cb535c9fe01012cff323b49">GZ_ADD_PLUGIN_ALIAS()</a></code> macros, we need a header from <code>gz-plugin</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="https://gazebosim.org/api/plugin/3/Register_8hh.html">gz/plugin/Register.hh</a>&gt;</span></div>
</div><!-- fragment --><p>Because we'll be subscribing to data published by a sensor, we need a header from <code>gz-transport</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="https://gazebosim.org/api/transport/14/Node_8hh.html">gz/transport/Node.hh</a>&gt;</span></div>
</div><!-- fragment --><p>And we keep the SDFormat header:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;sdf/sdf.hh&gt;</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md185"></a>
Class members</h3>
<p>Now let's get into the class member declarations. The <code>PID</code> class has moved from <code>common</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">common::PID pid;</div>
</div><!-- fragment --><p>to <code><a class="elRef" href="https://gazebosim.org/api/math/8/namespacegz_1_1math.html">gz::math</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><a class="code hl_classRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1PID.html">gz::math::PID</a> pid;</div>
</div><!-- fragment --><p>In the old code we store a <code>physics::JointPtr</code> for each propeller joint we're controlling:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">physics::JointPtr joint;</div>
</div><!-- fragment --><p>In the new code we store an <code><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d" title="An Entity identifies a single object in simulation such as a model, link, or light....">gz::sim::Entity</a></code> instead:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><a class="code hl_typedef" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d" title="An Entity identifies a single object in simulation such as a model, link, or light....">gz::sim::Entity</a> joint;</div>
</div><!-- fragment --><p>In the old code we store an <code>event::ConnectionPtr</code> to manage periodic calls to the <code>OnUpdate()</code> method:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">event::ConnectionPtr updateConnection;</div>
</div><!-- fragment --><p>There's no equivalent class member in the new code. Instead we declared our intent to have this class's update methods called via its inheritance.</p>
<p>In the old code we store a <code>physics::ModelPtr</code> for the model we're acting on:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">physics::ModelPtr model;</div>
</div><!-- fragment --><p>In the new code we instead store references to the model, the entity underlying the model, and the entity underyling one of the links in the model:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><a class="code hl_typedef" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d" title="An Entity identifies a single object in simulation such as a model, link, or light....">gz::sim::Entity</a> entity{<a class="code hl_variable" href="namespacegz_1_1sim.html#a03d78dd6f322345283506c2005476e79" title="Indicates a non-existant or invalid Entity.">gz::sim::kNullEntity</a>};</div>
<div class="line"><a class="code hl_class" href="classgz_1_1sim_1_1Model.html" title="This class provides wrappers around entities and components which are more convenient and straight-fo...">gz::sim::Model</a> model{<a class="code hl_variable" href="namespacegz_1_1sim.html#a03d78dd6f322345283506c2005476e79" title="Indicates a non-existant or invalid Entity.">gz::sim::kNullEntity</a>};</div>
<div class="line"><a class="code hl_typedef" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d" title="An Entity identifies a single object in simulation such as a model, link, or light....">gz::sim::Entity</a> modelLink{<a class="code hl_variable" href="namespacegz_1_1sim.html#a03d78dd6f322345283506c2005476e79" title="Indicates a non-existant or invalid Entity.">gz::sim::kNullEntity</a>};</div>
</div><!-- fragment --><p>The old code uses a custom time class:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">sim::common::Time lastControllerUpdateTime;</div>
</div><!-- fragment --><p>while the new code uses <code><a class="elRef" href="http://en.cppreference.com/w/namespacestd_1_1chrono.html">std::chrono</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">std::chrono::steady_clock::duration lastControllerUpdateTime{0};</div>
</div><!-- fragment --><p>In this plugin we need to read data from an IMU sensor attached to the UAV. In the old code we store a pointer to the sensor:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">sensors::ImuSensorPtr imuSensor;</div>
</div><!-- fragment --><p>In the new code, instead of accessing the sensor object directly we must subscribe to a topic published by the sensor (you might be tempted to try retrieving the sensor data via components attached to the IMU entity, but that won't work because the logic to produce the data lives in the IMU system and its output can only be consumed via subscription). So we need a few more variables to track the state of subscription, data receipt via subscription, and so on:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> imuName;</div>
<div class="line"><span class="keywordtype">bool</span> imuInitialized;</div>
<div class="line"><a class="code hl_classRef" href="https://gazebosim.org/api/transport/14/classgz_1_1transport_1_1Node.html">gz::transport::Node</a> node;</div>
<div class="line">gz::msgs::IMU imuMsg;</div>
<div class="line"><span class="keywordtype">bool</span> imuMsgValid;</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/thread/mutex.html">std::mutex</a> imuMsgMutex;</div>
</div><!-- fragment --><p>We also need a callback function that will be invoked upon receipt of newly published data from the IMU sensor. The callback just latches the latest message in a mutex-controlled fashion:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordtype">void</span> imuCb(<span class="keyword">const</span> gz::msgs::IMU &amp;_msg)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/thread/lock_guard.html">std::lock_guard&lt;std::mutex&gt;</a> lock(this-&gt;imuMsgMutex);</div>
<div class="line">  imuMsg = _msg;</div>
<div class="line">  imuMsgValid = <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md186"></a>
Plugin interface: Configure()</h3>
<p>Recall that <code>Configure()</code> replaces <code>Load()</code>.</p>
<p>In the old code, we store the model pointer and name:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">this-&gt;dataPtr-&gt;model = _model;</div>
<div class="line">this-&gt;dataPtr-&gt;modelName = this-&gt;dataPtr-&gt;model-&gt;GetName();</div>
</div><!-- fragment --><p>In the new code, we store the entity, model, and name a bit differently:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">this-&gt;dataPtr-&gt;entity = _entity;</div>
<div class="line">this-&gt;dataPtr-&gt;model = <a class="code hl_class" href="classgz_1_1sim_1_1Model.html" title="This class provides wrappers around entities and components which are more convenient and straight-fo...">gz::sim::Model</a>(_entity);</div>
<div class="line">this-&gt;dataPtr-&gt;modelName = this-&gt;dataPtr-&gt;model.Name(_ecm);</div>
</div><!-- fragment --><p>Also in the new code we need to make sure of the existence of the specific <em>components</em> that we need. In our case, we're going to access the <code>WorldPose</code> and <code>WorldLinearVelocity</code> components of the <em>entity</em> representing one of the UAV model's links. The data in those components will be periodically updated by the physics <em>system</em>. But the physics system will not necessarily create the components, so before accessing them later in our code, we need to ensure that the components exist:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordflow">if</span>(!_ecm.EntityHasComponentType(this-&gt;dataPtr-&gt;modelLink, components::WorldPose::typeId))</div>
<div class="line">{</div>
<div class="line">  _ecm.CreateComponent(this-&gt;dataPtr-&gt;modelLink, gz::sim::components::WorldPose());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span>(!_ecm.EntityHasComponentType(this-&gt;dataPtr-&gt;modelLink, components::WorldLinearVelocity::typeId))</div>
<div class="line">{</div>
<div class="line">  _ecm.CreateComponent(this-&gt;dataPtr-&gt;modelLink, gz::sim::components::WorldLinearVelocity());</div>
<div class="line">}</div>
</div><!-- fragment --><p>We'll see this pattern elsewhere in the new code: check for a component's existence, create it if necessary, then proceed with using it.</p>
<p>We also clone the <code>const sdf::Element</code> that we've passed so that we can call non-<code>const</code> methods on it:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">sdf::ElementPtr sdfClone = _sdf-&gt;Clone();</div>
</div><!-- fragment --><p>In the old code we retrieve a pointer to each joint that we're controlling:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">control.joint = _model-&gt;GetJoint(control.jointName);</div>
</div><!-- fragment --><p>In the new code we retrieve the entity that represents the joint:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">control.joint = this-&gt;dataPtr-&gt;model.JointByName(_ecm, control.jointName);</div>
</div><!-- fragment --><p>The accessor methods for members in the <code>PID</code> class have changed. The old code uses a <code>Get</code> prefix, e.g.:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">param = controlSDF-&gt;Get(<span class="stringliteral">&quot;vel_p_gain&quot;</span>, control.pid.GetPGain()).first;</div>
<div class="line">param = controlSDF-&gt;Get(<span class="stringliteral">&quot;vel_i_gain&quot;</span>, control.pid.GetIGain()).first;</div>
<div class="line">param = controlSDF-&gt;Get(<span class="stringliteral">&quot;vel_d_gain&quot;</span>, control.pid.GetDGain()).first;</div>
</div><!-- fragment --><p>In the new code, the <code>Get</code> prefix is gone:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">param = controlSDF-&gt;Get(<span class="stringliteral">&quot;vel_p_gain&quot;</span>, control.pid.PGain()).first;</div>
<div class="line">param = controlSDF-&gt;Get(<span class="stringliteral">&quot;vel_i_gain&quot;</span>, control.pid.IGain()).first;</div>
<div class="line">param = controlSDF-&gt;Get(<span class="stringliteral">&quot;vel_d_gain&quot;</span>, control.pid.DGain()).first;</div>
</div><!-- fragment --><p>The old code does a bunch of lookups to get a pointer to the IMU sensor. In the new code, we just store the name of the sensors from the user-supplied SDF configuration:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">this-&gt;dataPtr-&gt;imuName = _sdf-&gt;Get(<span class="stringliteral">&quot;imuName&quot;</span>, <span class="keyword">static_cast&lt;</span><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a><span class="keyword">&gt;</span>(<span class="stringliteral">&quot;imu_sensor&quot;</span>)).first;</div>
</div><!-- fragment --><p>and we do the equivalent lookup later, in <code>PreUpdate()</code>, which we'll cover next.</p>
<h3><a class="anchor" id="autotoc_md187"></a>
Plugin interface: OnUpdate() -&gt; PreUpdate() + PostUpdate()</h3>
<p>The old code does the following each time step in its <code>OnUpdate()</code> method:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">const</span> sim::common::Time curTime =</div>
<div class="line">  this-&gt;dataPtr-&gt;model-&gt;GetWorld()-&gt;SimTime();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (curTime &gt; this-&gt;dataPtr-&gt;lastControllerUpdateTime)</div>
<div class="line">{</div>
<div class="line">  this-&gt;ReceiveMotorCommand();</div>
<div class="line">  <span class="keywordflow">if</span> (this-&gt;dataPtr-&gt;arduPilotOnline)</div>
<div class="line">  {</div>
<div class="line">    this-&gt;ApplyMotorForces((curTime -</div>
<div class="line">      this-&gt;dataPtr-&gt;lastControllerUpdateTime).Double());</div>
<div class="line">    this-&gt;SendState();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">this-&gt;dataPtr-&gt;lastControllerUpdateTime = curTime;</div>
</div><!-- fragment --><p>As mentioned above, in the new code we're splitting that work into two halves: the "write" part should happen in <code>PreUpdate()</code> and the "read" part should happen in <code>PostUpdate()</code>.</p>
<p>In <code>PreUpdate()</code> we receive new commands from the external ArduPilot process and write the resulting forces to propeller joints in simulation:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordflow">if</span> (_info.simTime &gt; this-&gt;dataPtr-&gt;lastControllerUpdateTime)</div>
<div class="line">{</div>
<div class="line">  this-&gt;ReceiveMotorCommand();</div>
<div class="line">  <span class="keywordflow">if</span> (this-&gt;dataPtr-&gt;arduPilotOnline)</div>
<div class="line">  {</div>
<div class="line">    this-&gt;ApplyMotorForces(<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/chrono/duration/duration_cast.html">std::chrono::duration_cast</a>&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration&lt;double&gt;</a> &gt;(_info.simTime -</div>
<div class="line">      this-&gt;dataPtr-&gt;lastControllerUpdateTime).<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/chrono/duration/count.html">count</a>(), _ecm);</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Then in <code>PostUpdate()</code> we read the latest state (e.g., IMU sensor data, UAV pose and velocity) from simulation and send it out to ArduPilot:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordflow">if</span> (_info.simTime &gt; this-&gt;dataPtr-&gt;lastControllerUpdateTime)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (this-&gt;dataPtr-&gt;arduPilotOnline)</div>
<div class="line">  {</div>
<div class="line">    this-&gt;SendState(<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/chrono/duration/duration_cast.html">std::chrono::duration_cast</a>&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration&lt;double&gt;</a> &gt;(_info.simTime).<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/chrono/duration/count.html">count</a>(),</div>
<div class="line">            _ecm);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">this-&gt;dataPtr-&gt;lastControllerUpdateTime = _info.simTime;</div>
</div><!-- fragment --><p>Note the differences in both methods with regard to time-handling: (i) the current simulation time is passed in as part of an <code><a class="el" href="structgz_1_1sim_1_1UpdateInfo.html" title="Information passed to systems on the update callback.">gz::sim::UpdateInfo</a></code> object; and (ii) we operate on time values using <code><a class="elRef" href="http://en.cppreference.com/w/namespacestd_1_1chrono.html">std::chrono</a></code>.</p>
<h4><a class="anchor" id="autotoc_md188"></a>
One-time initialization in PreUpdate(): subscribing to sensor data</h4>
<p>Though it's not part of the regular update loop, we subscribe to the IMU sensor data in <code>PreUpdate()</code> because the information that we need for that subscription isn't available when we're in <code>Configure()</code>.</p>
<p>That one-time subscription logic looks like this, starting with determination of the right topic name and ending with registering our previously defined <code>imuCb()</code> method as the callback to receive new IMU data:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordflow">if</span>(!this-&gt;dataPtr-&gt;imuInitialized)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Set unconditionally because we&#39;re only going to try this once.</span></div>
<div class="line">  this-&gt;dataPtr-&gt;imuInitialized = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> imuEntity = _ecm.EntityByComponents(</div>
<div class="line">      components::Name(this-&gt;dataPtr-&gt;imuName),</div>
<div class="line">      components::Imu(),</div>
<div class="line">      components::ParentEntity(this-&gt;dataPtr-&gt;modelLink));</div>
<div class="line">  <span class="keyword">auto</span> imuTopicName = _ecm.ComponentData&lt;components::SensorTopic&gt;(imuEntity);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(imuTopicName.empty())</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_defineRef" href="https://gazebosim.org/api/common/6/Console_8hh.html#acf18c83e7419e002351f1eeceb6c2cf4">gzerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; this-&gt;dataPtr-&gt;modelName &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;imu_sensor [&quot;</span> &lt;&lt; this-&gt;dataPtr-&gt;imuName</div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;] not found, abort ArduPilot plugin.&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  this-&gt;dataPtr-&gt;node.Subscribe(imuTopicName, &amp;gz::sim::systems::ArduPilotPluginPrivate::imuCb, this-&gt;dataPtr.get());</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md189"></a>
Writing to simulation</h3>
<p>Based on commands received from ArduPilot, new forces are applied to the propeller joints in <code>ApplyMotorForces()</code>, using the joints' current velocities as feedback. In the old code that's done by calling <code>GetVelocity()</code> and <code>SetForce()</code> on each joint <code>i</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> vel = this-&gt;dataPtr-&gt;controls[i].joint-&gt;GetVelocity(0);</div>
<div class="line"><span class="comment">// ...do some feedback control math to compute force from vel...</span></div>
<div class="line">this-&gt;dataPtr-&gt;controls[i].joint-&gt;SetForce(0, force);</div>
</div><!-- fragment --><p>In the new code, for each joint <code>i</code> we read from the <code>JointVelocity</code> component attached to the corresponding entity, and we write to the <code>JointForceCmd</code> component attached to the same entity (creating it first in case it doesn't yet exist):</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> vel = _ecm.ComponentData&lt;<a class="code hl_class" href="classgz_1_1sim_1_1components_1_1Component.html" title="A component type that wraps any data type. The intention is for this class to be used to create simpl...">gz::sim::components::JointVelocity</a>&gt;(</div>
<div class="line">    this-&gt;dataPtr-&gt;controls[i].joint);</div>
<div class="line"><span class="comment">// ...do some feedback control math to compute force from vel...</span></div>
<div class="line">_ecm.SetComponentData(this-&gt;dataPtr-&gt;controls[i].joint,</div>
<div class="line">    <a class="code hl_class" href="classgz_1_1sim_1_1components_1_1Component.html" title="A component type that wraps any data type. The intention is for this class to be used to create simpl...">gz::sim::components::JointForceCmd</a>({force}));</div>
</div><!-- fragment --><p>A similar pattern is used for the case of setting a velocity on a joint; instead of calling <code>SetVelocity()</code> on the joint, we write to the <code>JointVelocityCmd</code> component of the joint entity.</p>
<h3><a class="anchor" id="autotoc_md190"></a>
Reading from simulation</h3>
<p>To prepare the data that will be sent to ArduPilot, in <code>SendState()</code> we need to read some information from simulation, specifically: linear acceleration and angular velocity from the IMU, and the UAV's pose and linear velocity in the world frame.</p>
<p>In the old code, we get the IMU data by calling methods on the sensor object and copying the result into the packet that we're going to send to ArduPilot:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_classRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector3.html">gz::math::Vector3d</a> linearAccel =</div>
<div class="line">  this-&gt;dataPtr-&gt;imuSensor-&gt;LinearAcceleration();</div>
<div class="line">pkt.imuLinearAccelerationXYZ[0] = linearAccel.<a class="code hl_functionRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector3.html#adf0759dc95ad2409e26a04c456059b96">X</a>();</div>
<div class="line">pkt.imuLinearAccelerationXYZ[1] = linearAccel.<a class="code hl_functionRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector3.html#a11ab7878747c03b64c70de6acf55f839">Y</a>();</div>
<div class="line">pkt.imuLinearAccelerationXYZ[2] = linearAccel.<a class="code hl_functionRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector3.html#a46624762afa9ad876ce4e71bc07e9fd0">Z</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_classRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector3.html">gz::math::Vector3d</a> angularVel =</div>
<div class="line">  this-&gt;dataPtr-&gt;imuSensor-&gt;AngularVelocity();</div>
<div class="line">pkt.imuAngularVelocityRPY[0] = angularVel.<a class="code hl_functionRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector3.html#adf0759dc95ad2409e26a04c456059b96">X</a>();</div>
<div class="line">pkt.imuAngularVelocityRPY[1] = angularVel.<a class="code hl_functionRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector3.html#a11ab7878747c03b64c70de6acf55f839">Y</a>();</div>
<div class="line">pkt.imuAngularVelocityRPY[2] = angularVel.<a class="code hl_functionRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector3.html#a46624762afa9ad876ce4e71bc07e9fd0">Z</a>();</div>
</div><!-- fragment --><p>In the new code, as previously mentioned, these data are accessed by subscribing to the sensor via gz-transport. In that subscription we registered a callback that just copies the latest IMU message to <code>imuMsg</code> and sets the flag <code>imuMsgValid</code>, using <code>imuMsgMutex</code> to exclude concurrent access to those variables. So we access the latest IMU sensor by copying and reading from that message:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">gz::msgs::IMU imuMsg;</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/thread/lock_guard.html">std::lock_guard&lt;std::mutex&gt;</a> lock(this-&gt;dataPtr-&gt;imuMsgMutex);</div>
<div class="line">  <span class="keywordflow">if</span>(!this-&gt;dataPtr-&gt;imuMsgValid)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">  imuMsg = this-&gt;dataPtr-&gt;imuMsg;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">pkt.imuLinearAccelerationXYZ[0] = imuMsg.linear_acceleration().x();</div>
<div class="line">pkt.imuLinearAccelerationXYZ[1] = imuMsg.linear_acceleration().y();</div>
<div class="line">pkt.imuLinearAccelerationXYZ[2] = imuMsg.linear_acceleration().z();</div>
<div class="line"> </div>
<div class="line">pkt.imuAngularVelocityRPY[0] = imuMsg.angular_velocity().x();</div>
<div class="line">pkt.imuAngularVelocityRPY[1] = imuMsg.angular_velocity().y();</div>
<div class="line">pkt.imuAngularVelocityRPY[2] = imuMsg.angular_velocity().z();</div>
</div><!-- fragment --><p>In the old code, we access the UAV's pose linear velocity in the world frame by calling <code>WorldPose()</code> and <code>WorldLinearVelocity()</code>, respectively, on the model object:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_classRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Pose3.html">gz::math::Pose3d</a> gazeboXYZToModelXForwardZDown =</div>
<div class="line">  this-&gt;modelXYZToAirplaneXForwardZDown +</div>
<div class="line">  this-&gt;dataPtr-&gt;model-&gt;WorldPose();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_classRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector3.html">gz::math::Vector3d</a> velGazeboWorldFrame =</div>
<div class="line">  this-&gt;dataPtr-&gt;model-&gt;GetLink()-&gt;WorldLinearVel();</div>
</div><!-- fragment --><p>In the new code we instead read from the <code>WorldPose</code> and <code>WorldLinearVelocity</code> components attached to the entity representing one of the UAV model's links:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keyword">const</span> gz::sim::components::WorldPose* pComp =</div>
<div class="line">    _ecm.Component&lt;gz::sim::components::WorldPose&gt;(this-&gt;dataPtr-&gt;modelLink);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_classRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Pose3.html">gz::math::Pose3d</a> gazeboXYZToModelXForwardZDown =</div>
<div class="line">  this-&gt;modelXYZToAirplaneXForwardZDown +</div>
<div class="line">  pComp-&gt;Data();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> gz::sim::components::WorldLinearVelocity* vComp =</div>
<div class="line">  _ecm.Component&lt;gz::sim::components::WorldLinearVelocity&gt;(this-&gt;dataPtr-&gt;modelLink);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_classRef" href="https://gazebosim.org/api/math/8/classgz_1_1math_1_1Vector3.html">gz::math::Vector3d</a> velGazeboWorldFrame = vComp-&gt;Data();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md191"></a>
Registering the plugin</h3>
<p>In the old code we register our plugin via the macro <code>GZ_REGISTER_PLUGIN()</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">GZ_REGISTER_MODEL_PLUGIN(ArduPilotPlugin)</div>
</div><!-- fragment --><p>In the new code we instead use two macros: <code><a class="elRef" href="https://gazebosim.org/api/plugin/3/Register_8hh.html#a80cacf59ebf9a4726bb47860ff177542">GZ_ADD_PLUGIN()</a></code> and <code><a class="elRef" href="https://gazebosim.org/api/plugin/3/Register_8hh.html#a899a1e669cb535c9fe01012cff323b49">GZ_ADD_PLUGIN_ALIAS()</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><a class="code hl_defineRef" href="https://gazebosim.org/api/plugin/3/Register_8hh.html#a80cacf59ebf9a4726bb47860ff177542">GZ_ADD_PLUGIN</a>(gz::sim::systems::ArduPilotPlugin,</div>
<div class="line">                    <a class="code hl_class" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">gz::sim::System</a>,</div>
<div class="line">                    gz::sim::systems::ArduPilotPlugin::ISystemConfigure,</div>
<div class="line">                    gz::sim::systems::ArduPilotPlugin::ISystemPostUpdate,</div>
<div class="line">                    gz::sim::systems::ArduPilotPlugin::ISystemPreUpdate)</div>
<div class="line"><a class="code hl_defineRef" href="https://gazebosim.org/api/plugin/3/Register_8hh.html#a899a1e669cb535c9fe01012cff323b49">GZ_ADD_PLUGIN_ALIAS</a>(gz::sim::systems::ArduPilotPlugin,<span class="stringliteral">&quot;ArduPilotPlugin&quot;</span>)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md192"></a>
Build recipe: &lt;tt&gt;CMakeLists.txt&lt;/tt&gt;</h2>
<p>Compared to the code changes, the updates in the CMake configuration are pretty minor and primarily result from the fact that the formerly monolithic Gazebo project is now a set of Gazebo libraries.</p>
<p>In the old code we retrieve all the required build configuration by finding the Gazebo package:</p>
<div class="fragment"><div class="line"># OLD</div>
<div class="line">find_package(gazebo REQUIRED)</div>
</div><!-- fragment --><p>In the new code we explicitly reference each Gazebo package that we use:</p>
<div class="fragment"><div class="line"># NEW</div>
<div class="line">find_package(sdformat15 REQUIRED)</div>
<div class="line">find_package(gz-common6-all REQUIRED)</div>
<div class="line">find_package(gz-sim9-all REQUIRED)</div>
<div class="line">find_package(gz-math8-all REQUIRED)</div>
<div class="line">find_package(gz-msgs11-all REQUIRED)</div>
<div class="line">find_package(gz-physics8-all REQUIRED)</div>
<div class="line">find_package(gz-sensors9-all REQUIRED)</div>
<div class="line">find_package(gz-transport14-all REQUIRED)</div>
</div><!-- fragment --><p>In the old code we need only refer to the build configuration retrieved from the Gazebo package:</p>
<div class="fragment"><div class="line">include_directories(</div>
<div class="line">        ${PROJECT_SOURCE_DIR}</div>
<div class="line">        include</div>
<div class="line">        ${GAZEBO_INCLUDE_DIRS})</div>
<div class="line"> </div>
<div class="line">link_libraries(</div>
<div class="line">        ${GAZEBO_LIBRARIES}</div>
<div class="line">)</div>
</div><!-- fragment --><p>Whereas in the new code we refer to build configuration from each Gazebo package:</p>
<div class="fragment"><div class="line">include_directories(</div>
<div class="line">        ${PROJECT_SOURCE_DIR}</div>
<div class="line">        include</div>
<div class="line">        ${SDFORMAT-INCLUDE_DIRS}</div>
<div class="line">        ${GZ-COMMON_INCLUDE_DIRS}</div>
<div class="line">        ${GZ-SIM_INCLUDE_DIRS}</div>
<div class="line">        ${GZ-MATH_INCLUDE_DIRS}</div>
<div class="line">        ${GZ-MSGS_INCLUDE_DIRS}</div>
<div class="line">        ${GZ-TRANSPORT_INCLUDE_DIRS}</div>
<div class="line">        )</div>
<div class="line"> </div>
<div class="line">link_libraries(</div>
<div class="line">        ${SDFORMAT-LIBRARIES}</div>
<div class="line">        ${GZ-COMMON_LIBRARIES}</div>
<div class="line">        ${GZ-SIM_LIBRARIES}</div>
<div class="line">        ${GZ-MATH_LIBRARIES}</div>
<div class="line">        ${GZ-MSGS_LIBRARIES}</div>
<div class="line">        ${GZ-TRANSPORT_LIBRARIES}</div>
<div class="line">        )</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md193"></a>
The model</h2>
<p>The old UAV is defined in two parts: (i) the <code>iris_with_standoffs</code> model, which defines the vehicle structure; and (ii) the <code>iris_with_ardupilot</code> model, which includes the extends the <code>iris_with_standoffs</code> model by adding plugins needed to fly it.</p>
<p>Because model inclusion is not (yet?) supported, the new model just combines the additional plugin configuration from <code>iris_with_ardupilot</code> into <code>iris_with_standoffs</code>. Along the way a few changes are made, as follows.</p>
<p>The <code>&lt;script&gt;</code> tag for visual material is not (yet?) supported, so in the model, instances of <code>&lt;script&gt;</code> are just commented out (which leaves the UAV visually untextured, but functional).</p>
<p>In the old model, loading an instance of the LiftDrag plugin for each half of each propeller looks like this:</p>
<div class="fragment"><div class="line"><span class="comment">&lt;!-- OLD --&gt;</span></div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">    <span class="keyword">name</span>=<span class="stringliteral">&quot;rotor_0_blade_1&quot;</span></div>
<div class="line">    <span class="keyword">filename</span>=<span class="stringliteral">&quot;LiftDragPlugin&quot;</span>&gt;</div>
<div class="line">  <span class="comment">&lt;!-- ...configuration goes here... --&gt;</span></div>
<div class="line">  &lt;<span class="keywordtype">link_name</span>&gt;<span class="keyword">iris::rotor_0</span>&lt;/<span class="keywordtype">link_name</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">plugin</span>&gt;</div>
</div><!-- fragment --><p>In the new model, we do this instead:</p>
<div class="fragment"><div class="line"><span class="comment">&lt;!-- NEW --&gt;</span></div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">    <span class="keyword">name</span>=<span class="stringliteral">&quot;gz::sim::systems::LiftDrag&quot;</span></div>
<div class="line">    <span class="keyword">filename</span>=<span class="stringliteral">&quot;gz-sim-lift-drag-system&quot;</span>&gt;</div>
<div class="line">  <span class="comment">&lt;!-- ...configuration goes here... --&gt;</span></div>
<div class="line">  &lt;<span class="keywordtype">link_name</span>&gt;<span class="keyword">rotor_0</span>&lt;/<span class="keywordtype">link_name</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">plugin</span>&gt;</div>
</div><!-- fragment --><p>In the old model, it's possible to read joint state and apply joint forces automatically. In the new model, we must instantiate the <code>JointStatePublisher</code> plugin once for the entire model and the <code>ApplyJointForce</code> plugin once for each propeller joint:</p>
<div class="fragment"><div class="line"><span class="comment">&lt;!-- NEW --&gt;</span></div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">  <span class="keyword">filename</span>=<span class="stringliteral">&quot;gz-sim-joint-state-publisher-system&quot;</span></div>
<div class="line">  <span class="keyword">name</span>=<span class="stringliteral">&quot;gz::sim::systems::JointStatePublisher&quot;</span>&gt;&lt;/<span class="keywordtype">plugin</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">  <span class="keyword">filename</span>=<span class="stringliteral">&quot;gz-sim-apply-joint-force-system&quot;</span></div>
<div class="line">  <span class="keyword">name</span>=<span class="stringliteral">&quot;gz::sim::systems::ApplyJointForce&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">joint_name</span>&gt;<span class="keyword">rotor_0_joint</span>&lt;/<span class="keywordtype">joint_name</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">plugin</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">  <span class="keyword">filename</span>=<span class="stringliteral">&quot;gz-sim-apply-joint-force-system&quot;</span></div>
<div class="line">  <span class="keyword">name</span>=<span class="stringliteral">&quot;gz::sim::systems::ApplyJointForce&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">joint_name</span>&gt;<span class="keyword">rotor_1_joint</span>&lt;/<span class="keywordtype">joint_name</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">plugin</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">  <span class="keyword">filename</span>=<span class="stringliteral">&quot;gz-sim-apply-joint-force-system&quot;</span></div>
<div class="line">  <span class="keyword">name</span>=<span class="stringliteral">&quot;gz::sim::systems::ApplyJointForce&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">joint_name</span>&gt;<span class="keyword">rotor_2_joint</span>&lt;/<span class="keywordtype">joint_name</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">plugin</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">  <span class="keyword">filename</span>=<span class="stringliteral">&quot;gz-sim-apply-joint-force-system&quot;</span></div>
<div class="line">  <span class="keyword">name</span>=<span class="stringliteral">&quot;gz::sim::systems::ApplyJointForce&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">joint_name</span>&gt;<span class="keyword">rotor_3_joint</span>&lt;/<span class="keywordtype">joint_name</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">plugin</span>&gt;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md194"></a>
What's next</h2>
<p>You should be able to apply the same general changes covered in this tutorial to your Gazebo plugins to migrate them to Gazebo.</p>
<p>Check out <a href="https://github.com/gerkey/ardupilot_gazebo/tree/ignition#using-with-ignition">these instructions</a> if you'd like to learn more about using ardupilot_gazebo with Gazebo. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
      </div>
    </main>
  </div>
</body>
