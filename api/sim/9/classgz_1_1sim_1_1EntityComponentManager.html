<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Sim">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Sim: EntityComponentManager Class Reference</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Sim</h1>
        <h2>API Reference</h2>
        <div class="version">
        9.4.0
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.8 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegz.html">gz</a></li><li class="navelem"><a class="el" href="namespacegz_1_1sim.html">sim</a></li><li class="navelem"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html">EntityComponentManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classgz_1_1sim_1_1EntityComponentManager-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle"><div class="title">EntityComponentManager Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html" title="The EntityComponentManager constructs, deletes, and returns components and entities....">EntityComponentManager</a> constructs, deletes, and returns components and entities. A component can be of any class which inherits from <code><a class="el" href="classgz_1_1sim_1_1components_1_1BaseComponent.html" title="Base class for all components.">components::BaseComponent</a></code>.  
 <a href="classgz_1_1sim_1_1EntityComponentManager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="EntityComponentManager_8hh_source.html">gz/sim/EntityComponentManager.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a04a598336398d804f77635a0bbde28ee" id="r_a04a598336398d804f77635a0bbde28ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a04a598336398d804f77635a0bbde28ee">EntityComponentManager</a> ()</td></tr>
<tr class="memdesc:a04a598336398d804f77635a0bbde28ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a04a598336398d804f77635a0bbde28ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f4d0bcf3173d568dedc1d0c852cc65" id="r_ae7f4d0bcf3173d568dedc1d0c852cc65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#ae7f4d0bcf3173d568dedc1d0c852cc65">~EntityComponentManager</a> ()</td></tr>
<tr class="memdesc:ae7f4d0bcf3173d568dedc1d0c852cc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:ae7f4d0bcf3173d568dedc1d0c852cc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4d4e3c44ffc8d2b429bafb0a256070" id="r_a7b4d4e3c44ffc8d2b429bafb0a256070"><td class="memItemLeft" align="right" valign="top">msgs::SerializedState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a7b4d4e3c44ffc8d2b429bafb0a256070">ChangedState</a> () const</td></tr>
<tr class="memdesc:a7b4d4e3c44ffc8d2b429bafb0a256070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a message with the serialized state of all entities and components that are changing in the current iteration.  <br /></td></tr>
<tr class="separator:a7b4d4e3c44ffc8d2b429bafb0a256070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be1caa481a36428b3d5fc7564aec51e" id="r_a3be1caa481a36428b3d5fc7564aec51e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a3be1caa481a36428b3d5fc7564aec51e">ChangedState</a> (msgs::SerializedStateMap &amp;_state) const</td></tr>
<tr class="memdesc:a3be1caa481a36428b3d5fc7564aec51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a message with the serialized state of all entities and components that are changing in the current iteration.  <br /></td></tr>
<tr class="separator:a3be1caa481a36428b3d5fc7564aec51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db14c92fc458960bea74a1c350aab39" id="r_a8db14c92fc458960bea74a1c350aab39"><td class="memTemplParams" colspan="2">template&lt;typename ... ComponentTypeTs&gt; </td></tr>
<tr class="memitem:a8db14c92fc458960bea74a1c350aab39"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a8db14c92fc458960bea74a1c350aab39">ChildrenByComponents</a> (<a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _parent, const ComponentTypeTs &amp;..._desiredComponents) const</td></tr>
<tr class="memdesc:a8db14c92fc458960bea74a1c350aab39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all entities which match the value of all the given components and are immediate children of a given parent entity. For example, the following will return a child of entity <code>parent</code> which has an int component equal to 123, and a string component equal to "name":  <br /></td></tr>
<tr class="separator:a8db14c92fc458960bea74a1c350aab39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0748493ec2b3c25a049e702e791f97" id="r_a7d0748493ec2b3c25a049e702e791f97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a7d0748493ec2b3c25a049e702e791f97">Clone</a> (<a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity, <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _parent, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name, bool _allowRename)</td></tr>
<tr class="memdesc:a7d0748493ec2b3c25a049e702e791f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone an entity and its components. If the entity has any child entities, they will also be cloned. When cloning entities, the following rules apply:  <br /></td></tr>
<tr class="separator:a7d0748493ec2b3c25a049e702e791f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c134e7116a28967f3f276d0ebdced16" id="r_a2c134e7116a28967f3f276d0ebdced16"><td class="memTemplParams" colspan="2">template&lt;typename ComponentTypeT &gt; </td></tr>
<tr class="memitem:a2c134e7116a28967f3f276d0ebdced16"><td class="memTemplItemLeft" align="right" valign="top">ComponentTypeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a2c134e7116a28967f3f276d0ebdced16">Component</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity)</td></tr>
<tr class="memdesc:a2c134e7116a28967f3f276d0ebdced16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable component assigned to an entity based on a component type.  <br /></td></tr>
<tr class="separator:a2c134e7116a28967f3f276d0ebdced16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c0607e1afe189a4e2c19a8941c1dd9" id="r_af1c0607e1afe189a4e2c19a8941c1dd9"><td class="memTemplParams" colspan="2">template&lt;typename ComponentTypeT &gt; </td></tr>
<tr class="memitem:af1c0607e1afe189a4e2c19a8941c1dd9"><td class="memTemplItemLeft" align="right" valign="top">const ComponentTypeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#af1c0607e1afe189a4e2c19a8941c1dd9">Component</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity) const</td></tr>
<tr class="memdesc:af1c0607e1afe189a4e2c19a8941c1dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a component assigned to an entity based on a component type.  <br /></td></tr>
<tr class="separator:af1c0607e1afe189a4e2c19a8941c1dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440843eb1b8ed844579e2667e1bd9b8f" id="r_a440843eb1b8ed844579e2667e1bd9b8f"><td class="memTemplParams" colspan="2">template&lt;typename ComponentTypeT &gt; </td></tr>
<tr class="memitem:a440843eb1b8ed844579e2667e1bd9b8f"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; typename ComponentTypeT::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a440843eb1b8ed844579e2667e1bd9b8f">ComponentData</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity) const</td></tr>
<tr class="memdesc:a440843eb1b8ed844579e2667e1bd9b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data from a component.  <br /></td></tr>
<tr class="separator:a440843eb1b8ed844579e2667e1bd9b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575a4405cd348dcc1f6813533cd68754" id="r_a575a4405cd348dcc1f6813533cd68754"><td class="memTemplParams" colspan="2">template&lt;typename ComponentTypeT &gt; </td></tr>
<tr class="memitem:a575a4405cd348dcc1f6813533cd68754"><td class="memTemplItemLeft" align="right" valign="top">ComponentTypeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a575a4405cd348dcc1f6813533cd68754">ComponentDefault</a> (<a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity, const typename ComponentTypeT::Type &amp;_default=typename ComponentTypeT::Type())</td></tr>
<tr class="memdesc:a575a4405cd348dcc1f6813533cd68754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable component assigned to an entity based on a component type. If the component doesn't exist, create it and initialize with the given default value.  <br /></td></tr>
<tr class="separator:a575a4405cd348dcc1f6813533cd68754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edcea6bdeca217dc087209b896368be" id="r_a1edcea6bdeca217dc087209b896368be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1sim.html#af8cb05dbaab6a7d39b05bf4366d4a782">sim::ComponentState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a1edcea6bdeca217dc087209b896368be">ComponentState</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity, const <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> _typeId) const</td></tr>
<tr class="memdesc:a1edcea6bdeca217dc087209b896368be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a component's state.  <br /></td></tr>
<tr class="separator:a1edcea6bdeca217dc087209b896368be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa71e60765ed385e14a17e02766356bc" id="r_aaa71e60765ed385e14a17e02766356bc"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#aaa71e60765ed385e14a17e02766356bc">ComponentTypes</a> (<a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity) const</td></tr>
<tr class="memdesc:aaa71e60765ed385e14a17e02766356bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type IDs of all components attached to an entity.  <br /></td></tr>
<tr class="separator:aaa71e60765ed385e14a17e02766356bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62b05a19c222db68770524c6911a1a2" id="r_ab62b05a19c222db68770524c6911a1a2"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#ab62b05a19c222db68770524c6911a1a2">ComponentTypesWithPeriodicChanges</a> () const</td></tr>
<tr class="memdesc:ab62b05a19c222db68770524c6911a1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the components types that are marked as periodic changes.  <br /></td></tr>
<tr class="separator:ab62b05a19c222db68770524c6911a1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5a50bb5dea520f481e1f2c4edb1c7e" id="r_add5a50bb5dea520f481e1f2c4edb1c7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#add5a50bb5dea520f481e1f2c4edb1c7e">CopyFrom</a> (const <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html">EntityComponentManager</a> &amp;_fromEcm)</td></tr>
<tr class="memdesc:add5a50bb5dea520f481e1f2c4edb1c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of <code>_from</code> into this object.  <br /></td></tr>
<tr class="separator:add5a50bb5dea520f481e1f2c4edb1c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa724e1b9672caf6ac87e56d12977ead" id="r_afa724e1b9672caf6ac87e56d12977ead"><td class="memTemplParams" colspan="2">template&lt;typename ComponentTypeT &gt; </td></tr>
<tr class="memitem:afa724e1b9672caf6ac87e56d12977ead"><td class="memTemplItemLeft" align="right" valign="top">ComponentTypeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#afa724e1b9672caf6ac87e56d12977ead">CreateComponent</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity, const ComponentTypeT &amp;_data)</td></tr>
<tr class="memdesc:afa724e1b9672caf6ac87e56d12977ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a component of a particular type. This will copy the _data parameter.  <br /></td></tr>
<tr class="separator:afa724e1b9672caf6ac87e56d12977ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6900700833b645619f720607e80df9e" id="r_ac6900700833b645619f720607e80df9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#ac6900700833b645619f720607e80df9e">CreateEntity</a> ()</td></tr>
<tr class="memdesc:ac6900700833b645619f720607e80df9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Entity.  <br /></td></tr>
<tr class="separator:ac6900700833b645619f720607e80df9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55180fc3e0bd3da10c97b85f8fb6702" id="r_aa55180fc3e0bd3da10c97b85f8fb6702"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#aa55180fc3e0bd3da10c97b85f8fb6702">Descendants</a> (<a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity) const</td></tr>
<tr class="memdesc:aa55180fc3e0bd3da10c97b85f8fb6702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all entities which are descendants of a given entity, including the entity itself.  <br /></td></tr>
<tr class="separator:aa55180fc3e0bd3da10c97b85f8fb6702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561e9f13958f10e3d296ddd9c56d8ee7" id="r_a561e9f13958f10e3d296ddd9c56d8ee7"><td class="memTemplParams" colspan="2">template&lt;typename ... ComponentTypeTs&gt; </td></tr>
<tr class="memitem:a561e9f13958f10e3d296ddd9c56d8ee7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a561e9f13958f10e3d296ddd9c56d8ee7">Each</a> (typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, ComponentTypeTs *...)&gt; &gt;::type _f)</td></tr>
<tr class="memdesc:a561e9f13958f10e3d296ddd9c56d8ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all entities which contain given component types, as well as the mutable components. Note that an entity marked for removal (but not processed yet) will be included in the list of entities iterated by this call.  <br /></td></tr>
<tr class="separator:a561e9f13958f10e3d296ddd9c56d8ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628ef4ea97906791363b9df030575524" id="r_a628ef4ea97906791363b9df030575524"><td class="memTemplParams" colspan="2">template&lt;typename ... ComponentTypeTs&gt; </td></tr>
<tr class="memitem:a628ef4ea97906791363b9df030575524"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a628ef4ea97906791363b9df030575524">Each</a> (typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, const ComponentTypeTs *...)&gt; &gt;::type _f) const</td></tr>
<tr class="memdesc:a628ef4ea97906791363b9df030575524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all entities which contain given component types, as well as the components. Note that an entity marked for removal (but not processed yet) will be included in the list of entities iterated by this call.  <br /></td></tr>
<tr class="separator:a628ef4ea97906791363b9df030575524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefabbc8810689e07ea9fdf21f4368f73" id="r_aefabbc8810689e07ea9fdf21f4368f73"><td class="memTemplParams" colspan="2">template&lt;typename... ComponentTypeTs&gt; </td></tr>
<tr class="memitem:aefabbc8810689e07ea9fdf21f4368f73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#aefabbc8810689e07ea9fdf21f4368f73">EachNew</a> (typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, ComponentTypeTs *...)&gt; &gt;::type _f)</td></tr>
<tr class="memdesc:aefabbc8810689e07ea9fdf21f4368f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all newly created entities which contain given component types, as well as the components. This "newness" is cleared at the end of a simulation step.  <br /></td></tr>
<tr class="separator:aefabbc8810689e07ea9fdf21f4368f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ceed1ba8963d32cf2e79bc599911073" id="r_a5ceed1ba8963d32cf2e79bc599911073"><td class="memTemplParams" colspan="2">template&lt;typename... ComponentTypeTs&gt; </td></tr>
<tr class="memitem:a5ceed1ba8963d32cf2e79bc599911073"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a5ceed1ba8963d32cf2e79bc599911073">EachNew</a> (typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, const ComponentTypeTs *...)&gt; &gt;::type _f) const</td></tr>
<tr class="memdesc:a5ceed1ba8963d32cf2e79bc599911073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all newly created entities which contain given component types, as well as the components. This "newness" is cleared at the end of a simulation step. This is the const version.  <br /></td></tr>
<tr class="separator:a5ceed1ba8963d32cf2e79bc599911073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc7e8b0be22214e7c94c96aa2d88757" id="r_a1dc7e8b0be22214e7c94c96aa2d88757"><td class="memTemplParams" colspan="2">template&lt;typename ... ComponentTypeTs&gt; </td></tr>
<tr class="memitem:a1dc7e8b0be22214e7c94c96aa2d88757"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a1dc7e8b0be22214e7c94c96aa2d88757">EachNoCache</a> (typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, ComponentTypeTs *...)&gt; &gt;::type _f)</td></tr>
<tr class="memdesc:a1dc7e8b0be22214e7c94c96aa2d88757"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a628ef4ea97906791363b9df030575524" title="Get all entities which contain given component types, as well as the components. Note that an entity ...">Each()</a> that doesn't use a cache. The cached version, <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a628ef4ea97906791363b9df030575524" title="Get all entities which contain given component types, as well as the components. Note that an entity ...">Each()</a>, is preferred. Get all entities which contain given component types, as well as the mutable components.  <br /></td></tr>
<tr class="separator:a1dc7e8b0be22214e7c94c96aa2d88757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9909c3cf7ee7fa3be581bc2d349424c" id="r_ad9909c3cf7ee7fa3be581bc2d349424c"><td class="memTemplParams" colspan="2">template&lt;typename ... ComponentTypeTs&gt; </td></tr>
<tr class="memitem:ad9909c3cf7ee7fa3be581bc2d349424c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#ad9909c3cf7ee7fa3be581bc2d349424c">EachNoCache</a> (typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, const ComponentTypeTs *...)&gt; &gt;::type _f) const</td></tr>
<tr class="memdesc:ad9909c3cf7ee7fa3be581bc2d349424c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a628ef4ea97906791363b9df030575524" title="Get all entities which contain given component types, as well as the components. Note that an entity ...">Each()</a> that doesn't use a cache. The cached version, <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a628ef4ea97906791363b9df030575524" title="Get all entities which contain given component types, as well as the components. Note that an entity ...">Each()</a>, is preferred. Get all entities which contain given component types, as well as the components.  <br /></td></tr>
<tr class="separator:ad9909c3cf7ee7fa3be581bc2d349424c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405b7a7edf725eecb881e40b7b122a99" id="r_a405b7a7edf725eecb881e40b7b122a99"><td class="memTemplParams" colspan="2">template&lt;typename ... ComponentTypeTs&gt; </td></tr>
<tr class="memitem:a405b7a7edf725eecb881e40b7b122a99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a405b7a7edf725eecb881e40b7b122a99">EachRemoved</a> (typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, const ComponentTypeTs *...)&gt; &gt;::type _f) const</td></tr>
<tr class="memdesc:a405b7a7edf725eecb881e40b7b122a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all entities which contain given component types and are about to be removed, as well as the components.  <br /></td></tr>
<tr class="separator:a405b7a7edf725eecb881e40b7b122a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93c41b7102b78b385e11f792fad9d3c" id="r_aa93c41b7102b78b385e11f792fad9d3c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacegz_1_1sim.html#a0942f69979f48cc25ec25ef91dce814f">EntityGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#aa93c41b7102b78b385e11f792fad9d3c">Entities</a> () const</td></tr>
<tr class="memdesc:aa93c41b7102b78b385e11f792fad9d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a graph with all the entities. Entities are vertices and edges point from parent to children.  <br /></td></tr>
<tr class="separator:aa93c41b7102b78b385e11f792fad9d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3bca25398e81e9fd8ff886b8f2e953" id="r_a4b3bca25398e81e9fd8ff886b8f2e953"><td class="memTemplParams" colspan="2">template&lt;typename ... ComponentTypeTs&gt; </td></tr>
<tr class="memitem:a4b3bca25398e81e9fd8ff886b8f2e953"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a4b3bca25398e81e9fd8ff886b8f2e953">EntitiesByComponents</a> (const ComponentTypeTs &amp;..._desiredComponents) const</td></tr>
<tr class="memdesc:a4b3bca25398e81e9fd8ff886b8f2e953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all entities which match the value of all the given components. For example, the following will return the entities which have a name component equal to "camera" and a sensor component:  <br /></td></tr>
<tr class="separator:a4b3bca25398e81e9fd8ff886b8f2e953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0086e69bf9b5deedf60068d5ab2473a9" id="r_a0086e69bf9b5deedf60068d5ab2473a9"><td class="memTemplParams" colspan="2">template&lt;typename ... ComponentTypeTs&gt; </td></tr>
<tr class="memitem:a0086e69bf9b5deedf60068d5ab2473a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a0086e69bf9b5deedf60068d5ab2473a9">EntityByComponents</a> (const ComponentTypeTs &amp;..._desiredComponents) const</td></tr>
<tr class="memdesc:a0086e69bf9b5deedf60068d5ab2473a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an entity which matches the value of all the given components. For example, the following will return the entity which has a name component equal to "name" and has a model component:  <br /></td></tr>
<tr class="separator:a0086e69bf9b5deedf60068d5ab2473a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a4bd7fb4a2e70b618c6683914f542d" id="r_a79a4bd7fb4a2e70b618c6683914f542d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a79a4bd7fb4a2e70b618c6683914f542d">EntityByName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name) const</td></tr>
<tr class="memdesc:a79a4bd7fb4a2e70b618c6683914f542d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an Entity based on a name component that is associated with the entity.  <br /></td></tr>
<tr class="separator:a79a4bd7fb4a2e70b618c6683914f542d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a34d566628f47ade9145d22a5c4947e" id="r_a4a34d566628f47ade9145d22a5c4947e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a4a34d566628f47ade9145d22a5c4947e">EntityCount</a> () const</td></tr>
<tr class="memdesc:a4a34d566628f47ade9145d22a5c4947e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of entities on the server.  <br /></td></tr>
<tr class="separator:a4a34d566628f47ade9145d22a5c4947e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0873d697c428473208cf78d771f0512" id="r_aa0873d697c428473208cf78d771f0512"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#aa0873d697c428473208cf78d771f0512">EntityHasComponentType</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity, const <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &amp;_typeId) const</td></tr>
<tr class="memdesc:aa0873d697c428473208cf78d771f0512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an entity has a specific component type.  <br /></td></tr>
<tr class="separator:aa0873d697c428473208cf78d771f0512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34412605b9d0e369e3db64fdd2136592" id="r_a34412605b9d0e369e3db64fdd2136592"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a34412605b9d0e369e3db64fdd2136592">EntityMatches</a> (<a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &gt; &amp;_types) const</td></tr>
<tr class="memdesc:a34412605b9d0e369e3db64fdd2136592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether an entity has all the given component types.  <br /></td></tr>
<tr class="separator:a34412605b9d0e369e3db64fdd2136592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1af2e05f485d5c03ad68ba0efaeaa9" id="r_a0b1af2e05f485d5c03ad68ba0efaeaa9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a0b1af2e05f485d5c03ad68ba0efaeaa9">HasComponentType</a> (const <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> _typeId) const</td></tr>
<tr class="memdesc:a0b1af2e05f485d5c03ad68ba0efaeaa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether a component type has ever been created.  <br /></td></tr>
<tr class="separator:a0b1af2e05f485d5c03ad68ba0efaeaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4aecf35b0ea8661ef18f6e675547cd" id="r_a2e4aecf35b0ea8661ef18f6e675547cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a2e4aecf35b0ea8661ef18f6e675547cd">HasEntitiesMarkedForRemoval</a> () const</td></tr>
<tr class="memdesc:a2e4aecf35b0ea8661ef18f6e675547cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether there are any entities marked to be removed.  <br /></td></tr>
<tr class="separator:a2e4aecf35b0ea8661ef18f6e675547cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1b1438fb57a11e5122fa536a10f031" id="r_a0f1b1438fb57a11e5122fa536a10f031"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a0f1b1438fb57a11e5122fa536a10f031">HasEntity</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity) const</td></tr>
<tr class="memdesc:a0f1b1438fb57a11e5122fa536a10f031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether an Entity exists.  <br /></td></tr>
<tr class="separator:a0f1b1438fb57a11e5122fa536a10f031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935d95e6f8eab23389a62d30050f0a0a" id="r_a935d95e6f8eab23389a62d30050f0a0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a935d95e6f8eab23389a62d30050f0a0a">HasNewEntities</a> () const</td></tr>
<tr class="memdesc:a935d95e6f8eab23389a62d30050f0a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether there are new entities.  <br /></td></tr>
<tr class="separator:a935d95e6f8eab23389a62d30050f0a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf642a116d7e3afdb1d4e62849f68ab8" id="r_abf642a116d7e3afdb1d4e62849f68ab8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#abf642a116d7e3afdb1d4e62849f68ab8">HasOneTimeComponentChanges</a> () const</td></tr>
<tr class="memdesc:abf642a116d7e3afdb1d4e62849f68ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether there are one-time component changes. These changes do not happen frequently and should be processed immediately.  <br /></td></tr>
<tr class="separator:abf642a116d7e3afdb1d4e62849f68ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897e2992c04baccc696f7149be4e284e" id="r_a897e2992c04baccc696f7149be4e284e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a897e2992c04baccc696f7149be4e284e">HasPeriodicComponentChanges</a> () const</td></tr>
<tr class="memdesc:a897e2992c04baccc696f7149be4e284e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether there are periodic component changes. These changes may happen frequently and are processed periodically.  <br /></td></tr>
<tr class="separator:a897e2992c04baccc696f7149be4e284e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1785c0d201b2f62452ad6210664f5364" id="r_a1785c0d201b2f62452ad6210664f5364"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a1785c0d201b2f62452ad6210664f5364">HasRemovedComponents</a> () const</td></tr>
<tr class="memdesc:a1785c0d201b2f62452ad6210664f5364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are components marked for removal.  <br /></td></tr>
<tr class="separator:a1785c0d201b2f62452ad6210664f5364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66857d225cebd7482dab36144bb2f3cb" id="r_a66857d225cebd7482dab36144bb2f3cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a66857d225cebd7482dab36144bb2f3cb">ParentEntity</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity) const</td></tr>
<tr class="memdesc:a66857d225cebd7482dab36144bb2f3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first parent of the given entity.  <br /></td></tr>
<tr class="separator:a66857d225cebd7482dab36144bb2f3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0315eb75fd6885729d98eddffd7fda17" id="r_a0315eb75fd6885729d98eddffd7fda17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a0315eb75fd6885729d98eddffd7fda17">PeriodicStateFromCache</a> (msgs::SerializedStateMap &amp;_state, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt; &gt; &amp;_cache) const</td></tr>
<tr class="memdesc:a0315eb75fd6885729d98eddffd7fda17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a message with relevant changes to the state given a periodic change cache.  <br /></td></tr>
<tr class="separator:a0315eb75fd6885729d98eddffd7fda17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2038db3fc414935074741f0a48b648b" id="r_ab2038db3fc414935074741f0a48b648b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#ab2038db3fc414935074741f0a48b648b">PinEntity</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity, bool _recursive=true)</td></tr>
<tr class="memdesc:ab2038db3fc414935074741f0a48b648b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent an entity and optionally its children from being removed.  <br /></td></tr>
<tr class="separator:ab2038db3fc414935074741f0a48b648b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44375162c6240103919dcd29ce2d374" id="r_aa44375162c6240103919dcd29ce2d374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#aa44375162c6240103919dcd29ce2d374">RebuildViews</a> ()</td></tr>
<tr class="memdesc:aa44375162c6240103919dcd29ce2d374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuild all the views. This could be an expensive operation.  <br /></td></tr>
<tr class="separator:aa44375162c6240103919dcd29ce2d374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9affd38fecd00cdf6b6884d46fa6a4e0" id="r_a9affd38fecd00cdf6b6884d46fa6a4e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a9affd38fecd00cdf6b6884d46fa6a4e0">RemoveComponent</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity, const <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &amp;_typeId)</td></tr>
<tr class="memdesc:a9affd38fecd00cdf6b6884d46fa6a4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a component from an entity based on a type id.  <br /></td></tr>
<tr class="separator:a9affd38fecd00cdf6b6884d46fa6a4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb60b40b5778b14ad707da543daaecf" id="r_a9cb60b40b5778b14ad707da543daaecf"><td class="memTemplParams" colspan="2">template&lt;typename ComponentTypeT &gt; </td></tr>
<tr class="memitem:a9cb60b40b5778b14ad707da543daaecf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a9cb60b40b5778b14ad707da543daaecf">RemoveComponent</a> (<a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity)</td></tr>
<tr class="memdesc:a9cb60b40b5778b14ad707da543daaecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a component from an entity based on a type.  <br /></td></tr>
<tr class="separator:a9cb60b40b5778b14ad707da543daaecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b02fd8d848b48388d1d8b51f7ad721f" id="r_a5b02fd8d848b48388d1d8b51f7ad721f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a5b02fd8d848b48388d1d8b51f7ad721f">RequestRemoveEntities</a> ()</td></tr>
<tr class="memdesc:a5b02fd8d848b48388d1d8b51f7ad721f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request to remove all entities. This will insert the request into a queue. The queue is processed toward the end of a simulation update step.  <br /></td></tr>
<tr class="separator:a5b02fd8d848b48388d1d8b51f7ad721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b6650a35dcfad315ced8cfc90429a3" id="r_a09b6650a35dcfad315ced8cfc90429a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a09b6650a35dcfad315ced8cfc90429a3">RequestRemoveEntity</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity, bool _recursive=true)</td></tr>
<tr class="memdesc:a09b6650a35dcfad315ced8cfc90429a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request an entity deletion. This will insert the request into a queue. The queue is processed toward the end of a simulation update step.  <br /></td></tr>
<tr class="separator:a09b6650a35dcfad315ced8cfc90429a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49e362ab68e472d9dc65d8eb7c79123" id="r_ac49e362ab68e472d9dc65d8eb7c79123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#ac49e362ab68e472d9dc65d8eb7c79123">ResetTo</a> (const <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html">EntityComponentManager</a> &amp;_other)</td></tr>
<tr class="memdesc:ac49e362ab68e472d9dc65d8eb7c79123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a diff, apply it to this ECM. Note that for removed entities, this would mark them for removal instead of actually removing the entities.  <br /></td></tr>
<tr class="separator:ac49e362ab68e472d9dc65d8eb7c79123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9fb828ad3327905b7a63d62ece41dc" id="r_a0f9fb828ad3327905b7a63d62ece41dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a0f9fb828ad3327905b7a63d62ece41dc">SetChanged</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity, const <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> _type, <a class="el" href="namespacegz_1_1sim.html#af8cb05dbaab6a7d39b05bf4366d4a782">sim::ComponentState</a> _c=<a class="el" href="namespacegz_1_1sim.html#af8cb05dbaab6a7d39b05bf4366d4a782a788dd38d4b17d40c57353d5a7a2e081c">ComponentState::OneTimeChange</a>)</td></tr>
<tr class="memdesc:a0f9fb828ad3327905b7a63d62ece41dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the changed state of a component.  <br /></td></tr>
<tr class="separator:a0f9fb828ad3327905b7a63d62ece41dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2c5008634545bbb5d9cb3a14a3aecf" id="r_ada2c5008634545bbb5d9cb3a14a3aecf"><td class="memTemplParams" colspan="2">template&lt;typename ComponentTypeT &gt; </td></tr>
<tr class="memitem:ada2c5008634545bbb5d9cb3a14a3aecf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#ada2c5008634545bbb5d9cb3a14a3aecf">SetComponentData</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity, const typename ComponentTypeT::Type &amp;_data)</td></tr>
<tr class="memdesc:ada2c5008634545bbb5d9cb3a14a3aecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the data from a component.  <br /></td></tr>
<tr class="separator:ada2c5008634545bbb5d9cb3a14a3aecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe7ef96866a8d666af13944fcaf0dfc" id="r_a1fe7ef96866a8d666af13944fcaf0dfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a1fe7ef96866a8d666af13944fcaf0dfc">SetEntityCreateOffset</a> (uint64_t _offset)</td></tr>
<tr class="memdesc:a1fe7ef96866a8d666af13944fcaf0dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">All future entities will have an id that starts at _offset. This can be used to avoid entity id collisions, such as during log playback.  <br /></td></tr>
<tr class="separator:a1fe7ef96866a8d666af13944fcaf0dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf43436bc3e47fc5544b80bd8c4c4b6" id="r_abaf43436bc3e47fc5544b80bd8c4c4b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#abaf43436bc3e47fc5544b80bd8c4c4b6">SetParentEntity</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _child, const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _parent)</td></tr>
<tr class="memdesc:abaf43436bc3e47fc5544b80bd8c4c4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the parent of an entity.  <br /></td></tr>
<tr class="separator:abaf43436bc3e47fc5544b80bd8c4c4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573b9551891a135bce602344e73a2a36" id="r_a573b9551891a135bce602344e73a2a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a573b9551891a135bce602344e73a2a36">SetState</a> (const msgs::SerializedState &amp;_stateMsg)</td></tr>
<tr class="memdesc:a573b9551891a135bce602344e73a2a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the absolute state of the ECM from a serialized message. Entities / components that are in the new state but not in the old one will be created. Entities / components that are marked as removed will be removed, but they won't be removed if they're not present in the state.  <br /></td></tr>
<tr class="separator:a573b9551891a135bce602344e73a2a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8814e7490aff65fa97b87beb25bff9" id="r_a6f8814e7490aff65fa97b87beb25bff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a6f8814e7490aff65fa97b87beb25bff9">SetState</a> (const msgs::SerializedStateMap &amp;_stateMsg)</td></tr>
<tr class="memdesc:a6f8814e7490aff65fa97b87beb25bff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the absolute state of the ECM from a serialized message. Entities / components that are in the new state but not in the old one will be created. Entities / components that are marked as removed will be removed, but they won't be removed if they're not present in the state.  <br /></td></tr>
<tr class="separator:a6f8814e7490aff65fa97b87beb25bff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbc9cf1c9eb4af335aebc178b6cb6f7" id="r_a8dbc9cf1c9eb4af335aebc178b6cb6f7"><td class="memItemLeft" align="right" valign="top">msgs::SerializedState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a8dbc9cf1c9eb4af335aebc178b6cb6f7">State</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt; &amp;_entities={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &gt; &amp;_types={}) const</td></tr>
<tr class="memdesc:a8dbc9cf1c9eb4af335aebc178b6cb6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a message with the serialized state of the given entities and components.  <br /></td></tr>
<tr class="separator:a8dbc9cf1c9eb4af335aebc178b6cb6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ac8ff529f6c2937938404a7bcc6729" id="r_aa2ac8ff529f6c2937938404a7bcc6729"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#aa2ac8ff529f6c2937938404a7bcc6729">State</a> (msgs::SerializedStateMap &amp;_state, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt; &amp;_entities={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &gt; &amp;_types={}, bool _full=false) const</td></tr>
<tr class="memdesc:aa2ac8ff529f6c2937938404a7bcc6729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a message with the serialized state of the given entities and components.  <br /></td></tr>
<tr class="separator:aa2ac8ff529f6c2937938404a7bcc6729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c852e52c49724fb71eadf32a0084a9c" id="r_a8c852e52c49724fb71eadf32a0084a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a8c852e52c49724fb71eadf32a0084a9c">UnpinAllEntities</a> ()</td></tr>
<tr class="memdesc:a8c852e52c49724fb71eadf32a0084a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow all previously pinned entities to be removed.  <br /></td></tr>
<tr class="separator:a8c852e52c49724fb71eadf32a0084a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33f978a8d2fff3cb3fa8dc6c3a0bb18" id="r_ab33f978a8d2fff3cb3fa8dc6c3a0bb18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#ab33f978a8d2fff3cb3fa8dc6c3a0bb18">UnpinEntity</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity, bool _recursive=true)</td></tr>
<tr class="memdesc:ab33f978a8d2fff3cb3fa8dc6c3a0bb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow an entity, and optionally its children, previously marked as pinned to be removed.  <br /></td></tr>
<tr class="separator:ab33f978a8d2fff3cb3fa8dc6c3a0bb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9399eeac5e1dbf371f9ada3b4c26928e" id="r_a9399eeac5e1dbf371f9ada3b4c26928e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a9399eeac5e1dbf371f9ada3b4c26928e">UpdatePeriodicChangeCache</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt; &gt; &amp;) const</td></tr>
<tr class="memdesc:a9399eeac5e1dbf371f9ada3b4c26928e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a cache of components with periodic changes.  <br /></td></tr>
<tr class="separator:a9399eeac5e1dbf371f9ada3b4c26928e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a90537d1e3cc92b8b3a99e1f369441e52" id="r_a90537d1e3cc92b8b3a99e1f369441e52"><td class="memTemplParams" colspan="2">template&lt;class Function , class... ComponentTypeTs&gt; </td></tr>
<tr class="memitem:a90537d1e3cc92b8b3a99e1f369441e52"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a90537d1e3cc92b8b3a99e1f369441e52">ForEach</a> (Function _f, const ComponentTypeTs &amp;... _components)</td></tr>
<tr class="memdesc:a90537d1e3cc92b8b3a99e1f369441e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function for each parameter in a pack.  <br /></td></tr>
<tr class="separator:a90537d1e3cc92b8b3a99e1f369441e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a088cb32a7b8cad294688a2eb66186e86" id="r_a088cb32a7b8cad294688a2eb66186e86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a088cb32a7b8cad294688a2eb66186e86">ApplyEntityDiff</a> (const <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html">EntityComponentManager</a> &amp;_other, const EntityComponentManagerDiff &amp;_diff)</td></tr>
<tr class="memdesc:a088cb32a7b8cad294688a2eb66186e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an entity diff, apply it to this ECM. Note that for removed entities, this would mark them for removal instead of actually removing the entities.  <br /></td></tr>
<tr class="separator:a088cb32a7b8cad294688a2eb66186e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867c61fd057eb843c1148b4a784b05c1" id="r_a867c61fd057eb843c1148b4a784b05c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a867c61fd057eb843c1148b4a784b05c1">ClearNewlyCreatedEntities</a> ()</td></tr>
<tr class="memdesc:a867c61fd057eb843c1148b4a784b05c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the list of newly added entities so that a call to EachAdded after this will have no entities to iterate. This function is protected to facilitate testing.  <br /></td></tr>
<tr class="separator:a867c61fd057eb843c1148b4a784b05c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64430d9798184c28ca389f69d31ac624" id="r_a64430d9798184c28ca389f69d31ac624"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a64430d9798184c28ca389f69d31ac624">ClearRemovedComponents</a> ()</td></tr>
<tr class="memdesc:a64430d9798184c28ca389f69d31ac624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the list of removed components so that a call to RemoveComponent doesn't make the list grow indefinitely.  <br /></td></tr>
<tr class="separator:a64430d9798184c28ca389f69d31ac624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ff9d43459daa58e976f68bb0a21b1d" id="r_ac4ff9d43459daa58e976f68bb0a21b1d"><td class="memItemLeft" align="right" valign="top">EntityComponentManagerDiff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#ac4ff9d43459daa58e976f68bb0a21b1d">ComputeEntityDiff</a> (const <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html">EntityComponentManager</a> &amp;_other) const</td></tr>
<tr class="separator:ac4ff9d43459daa58e976f68bb0a21b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ca781fb60cc7e626028af125269c46" id="r_a04ca781fb60cc7e626028af125269c46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a04ca781fb60cc7e626028af125269c46">ProcessRemoveEntityRequests</a> ()</td></tr>
<tr class="memdesc:a04ca781fb60cc7e626028af125269c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process all entity remove requests. This will remove entities and their components. This function is protected to facilitate testing.  <br /></td></tr>
<tr class="separator:a04ca781fb60cc7e626028af125269c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f812c07983a72d84430c96b7750da9" id="r_a46f812c07983a72d84430c96b7750da9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a46f812c07983a72d84430c96b7750da9">SetAllComponentsUnchanged</a> ()</td></tr>
<tr class="memdesc:a46f812c07983a72d84430c96b7750da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark all components as not changed.  <br /></td></tr>
<tr class="separator:a46f812c07983a72d84430c96b7750da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html" title="The EntityComponentManager constructs, deletes, and returns components and entities....">EntityComponentManager</a> constructs, deletes, and returns components and entities. A component can be of any class which inherits from <code><a class="el" href="classgz_1_1sim_1_1components_1_1BaseComponent.html" title="Base class for all components.">components::BaseComponent</a></code>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a04a598336398d804f77635a0bbde28ee" name="a04a598336398d804f77635a0bbde28ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a598336398d804f77635a0bbde28ee">&#9670;&#160;</a></span>EntityComponentManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html">EntityComponentManager</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="ae7f4d0bcf3173d568dedc1d0c852cc65" name="ae7f4d0bcf3173d568dedc1d0c852cc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f4d0bcf3173d568dedc1d0c852cc65">&#9670;&#160;</a></span>~EntityComponentManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html">EntityComponentManager</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a088cb32a7b8cad294688a2eb66186e86" name="a088cb32a7b8cad294688a2eb66186e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088cb32a7b8cad294688a2eb66186e86">&#9670;&#160;</a></span>ApplyEntityDiff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ApplyEntityDiff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html">EntityComponentManager</a> &amp;&#160;</td>
          <td class="paramname"><em>_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EntityComponentManagerDiff &amp;&#160;</td>
          <td class="paramname"><em>_diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an entity diff, apply it to this ECM. Note that for removed entities, this would mark them for removal instead of actually removing the entities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_other</td><td>Original <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html" title="The EntityComponentManager constructs, deletes, and returns components and entities....">EntityComponentManager</a> from which the diff was computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b4d4e3c44ffc8d2b429bafb0a256070" name="a7b4d4e3c44ffc8d2b429bafb0a256070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4d4e3c44ffc8d2b429bafb0a256070">&#9670;&#160;</a></span>ChangedState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">msgs::SerializedState ChangedState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a message with the serialized state of all entities and components that are changing in the current iteration. </p>
<p>This includes:</p><ul>
<li>New entities and all of their components</li>
<li>Removed entities and all of their components</li>
<li>Entities which had a component added</li>
<li>Entities which had a component removed</li>
<li><p class="startli">Entities which had a component modified</p>
<p class="startli">The header of the message will not be populated, it is the responsibility of the caller to timestamp it before use. </p>
</li>
</ul>

</div>
</div>
<a id="a3be1caa481a36428b3d5fc7564aec51e" name="a3be1caa481a36428b3d5fc7564aec51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be1caa481a36428b3d5fc7564aec51e">&#9670;&#160;</a></span>ChangedState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChangedState </td>
          <td>(</td>
          <td class="paramtype">msgs::SerializedStateMap &amp;&#160;</td>
          <td class="paramname"><em>_state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a message with the serialized state of all entities and components that are changing in the current iteration. </p>
<p>This includes:</p><ul>
<li>New entities and all of their components</li>
<li>Removed entities and all of their components</li>
<li>Entities which had a component added</li>
<li>Entities which had a component removed</li>
<li>Entities which had a component modified</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_state</td><td>New serialized state.</td></tr>
  </table>
  </dd>
</dl>
<p>The header of the message will not be populated, it is the responsibility of the caller to timestamp it before use. </p>

</div>
</div>
<a id="a8db14c92fc458960bea74a1c350aab39" name="a8db14c92fc458960bea74a1c350aab39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db14c92fc458960bea74a1c350aab39">&#9670;&#160;</a></span>ChildrenByComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... ComponentTypeTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt; ChildrenByComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ComponentTypeTs &amp;...&#160;</td>
          <td class="paramname"><em>_desiredComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all entities which match the value of all the given components and are immediate children of a given parent entity. For example, the following will return a child of entity <code>parent</code> which has an int component equal to 123, and a string component equal to "name": </p>
<p>auto entity = ChildrenByComponents(parent, 123, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>("name"));</p>
<p>Component type must have inequality operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_parent</td><td>Entity which should be an immediate parent of the returned entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_desiredComponents</td><td>All the components which must match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All matching entities, or an empty vector if no child entity has the exact components. </dd></dl>

</div>
</div>
<a id="a867c61fd057eb843c1148b4a784b05c1" name="a867c61fd057eb843c1148b4a784b05c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867c61fd057eb843c1148b4a784b05c1">&#9670;&#160;</a></span>ClearNewlyCreatedEntities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ClearNewlyCreatedEntities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the list of newly added entities so that a call to EachAdded after this will have no entities to iterate. This function is protected to facilitate testing. </p>

</div>
</div>
<a id="a64430d9798184c28ca389f69d31ac624" name="a64430d9798184c28ca389f69d31ac624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64430d9798184c28ca389f69d31ac624">&#9670;&#160;</a></span>ClearRemovedComponents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ClearRemovedComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the list of removed components so that a call to RemoveComponent doesn't make the list grow indefinitely. </p>

</div>
</div>
<a id="a7d0748493ec2b3c25a049e702e791f97" name="a7d0748493ec2b3c25a049e702e791f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0748493ec2b3c25a049e702e791f97">&#9670;&#160;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> Clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_allowRename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone an entity and its components. If the entity has any child entities, they will also be cloned. When cloning entities, the following rules apply: </p>
<ol type="1">
<li>The name component of a cloned entity will consist of a unique name, since all entities should have a unique name.</li>
<li>Cloned entities that have a canonical link will have their canonical link set to the cloned canonical link, not the original canonical link.</li>
<li>Child entities that are cloned will have their parent set to the cloned parent entity.</li>
<li>Cloned joints with parent/child links will have their parent and child links set to the cloned parent/child links.</li>
<li>Aside from the changes listed above, all other cloned components remain unchanged. Currently, cloning detachable joints is not supported. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>The entity to clone. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_parent</td><td>The parent of the cloned entity. Set this to kNullEntity if the cloned entity should not have a parent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>The name that should be given to the cloned entity. Set this to an empty string if the cloned entity name should be auto-generated to something unique. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_allowRename</td><td>True if _name can be modified to be a unique name if it isn't already a unique name. False if _name cannot be modified to be a unique name. If _allowRename is set to False, and _name is not unique, _entity will not be cloned. If _name is an empty string, _allowRename is ignored since the cloned entity will have an auto-generated unique name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cloned entity, which will have a unique name. kNullEntity is returned if cloning failed. Failure could occur if _entity does not exist, or if a unique name could not be generated for the entity to be cloned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a7d0748493ec2b3c25a049e702e791f97" title="Clone an entity and its components. If the entity has any child entities, they will also be cloned....">Clone</a> </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a2c134e7116a28967f3f276d0ebdced16" name="a2c134e7116a28967f3f276d0ebdced16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c134e7116a28967f3f276d0ebdced16">&#9670;&#160;</a></span>Component() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentTypeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ComponentTypeT * Component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a mutable component assigned to an entity based on a component type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>The entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The component of the specified type assigned to specified Entity, or nullptr if the component could not be found. </dd></dl>

</div>
</div>
<a id="af1c0607e1afe189a4e2c19a8941c1dd9" name="af1c0607e1afe189a4e2c19a8941c1dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c0607e1afe189a4e2c19a8941c1dd9">&#9670;&#160;</a></span>Component() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentTypeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ComponentTypeT * Component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a component assigned to an entity based on a component type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>The entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The component of the specified type assigned to specified Entity, or nullptr if the component could not be found. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegz_1_1sim.html#ab9e71e0a09027245f5afb2d8aa9989cb">gz::sim::enableComponent()</a>, and <a class="el" href="classgz_1_1sim_1_1inspector_1_1Pose3d.html#a4deb4a0fbc3720f97bff821d014c8255">Pose3d::UpdateView()</a>.</p>

</div>
</div>
<a id="a440843eb1b8ed844579e2667e1bd9b8f" name="a440843eb1b8ed844579e2667e1bd9b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440843eb1b8ed844579e2667e1bd9b8f">&#9670;&#160;</a></span>ComponentData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentTypeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; typename ComponentTypeT::Type &gt; ComponentData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data from a component. </p>
<ul>
<li>If the component type doesn't hold any data, this won't compile.</li>
<li>If the entity doesn't have that component, it will return nullopt.</li>
<li>If the entity has the component, return its data. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>The entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentTypeT</td><td>Component type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data of the component of the specified type assigned to specified Entity, or nullptr if the component could not be found. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a575a4405cd348dcc1f6813533cd68754" name="a575a4405cd348dcc1f6813533cd68754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575a4405cd348dcc1f6813533cd68754">&#9670;&#160;</a></span>ComponentDefault()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentTypeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ComponentTypeT * ComponentDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ComponentTypeT::Type &amp;&#160;</td>
          <td class="paramname"><em>_default</em> = <code>typename&#160;ComponentTypeT::Type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a mutable component assigned to an entity based on a component type. If the component doesn't exist, create it and initialize with the given default value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>The entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_default</td><td>The value that should be used to construct the component in case the component doesn't exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The component of the specified type assigned to the specified entity. If _entity does not exist, nullptr is returned. </dd></dl>

</div>
</div>
<a id="a1edcea6bdeca217dc087209b896368be" name="a1edcea6bdeca217dc087209b896368be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edcea6bdeca217dc087209b896368be">&#9670;&#160;</a></span>ComponentState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1sim.html#af8cb05dbaab6a7d39b05bf4366d4a782">sim::ComponentState</a> <a class="el" href="namespacegz_1_1sim.html#af8cb05dbaab6a7d39b05bf4366d4a782">ComponentState</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a>&#160;</td>
          <td class="paramname"><em>_typeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a component's state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>Entity that contains the component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_typeId</td><td>Component type ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Component's current state </dd></dl>

</div>
</div>
<a id="aaa71e60765ed385e14a17e02766356bc" name="aaa71e60765ed385e14a17e02766356bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa71e60765ed385e14a17e02766356bc">&#9670;&#160;</a></span>ComponentTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &gt; ComponentTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type IDs of all components attached to an entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>Entity to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All the component type IDs. </dd></dl>

</div>
</div>
<a id="ab62b05a19c222db68770524c6911a1a2" name="ab62b05a19c222db68770524c6911a1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62b05a19c222db68770524c6911a1a2">&#9670;&#160;</a></span>ComponentTypesWithPeriodicChanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &gt; ComponentTypesWithPeriodicChanges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the components types that are marked as periodic changes. </p>
<dl class="section return"><dt>Returns</dt><dd>All the components that at least one entity marked as periodic changes. </dd></dl>

</div>
</div>
<a id="ac4ff9d43459daa58e976f68bb0a21b1d" name="ac4ff9d43459daa58e976f68bb0a21b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ff9d43459daa58e976f68bb0a21b1d">&#9670;&#160;</a></span>ComputeEntityDiff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EntityComponentManagerDiff ComputeEntityDiff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html">EntityComponentManager</a> &amp;&#160;</td>
          <td class="paramname"><em>_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the diff between this <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html" title="The EntityComponentManager constructs, deletes, and returns components and entities....">EntityComponentManager</a> and _other at the entity level. This does not compute the diff between components of an entity.</p><ul>
<li>If an entity is in <code>_other</code>, but not in <code>this</code>, insert the entity as an "added" entity.</li>
<li>If an entity is in <code>this</code>, but not in <code>other</code>, insert the entity as a "removed" entity. <dl class="section return"><dt>Returns</dt><dd>Data structure containing the added and removed entities </dd></dl>
</li>
</ul>

</div>
</div>
<a id="add5a50bb5dea520f481e1f2c4edb1c7e" name="add5a50bb5dea520f481e1f2c4edb1c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5a50bb5dea520f481e1f2c4edb1c7e">&#9670;&#160;</a></span>CopyFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CopyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html">EntityComponentManager</a> &amp;&#160;</td>
          <td class="paramname"><em>_fromEcm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the contents of <code>_from</code> into this object. </p>
<dl class="section note"><dt>Note</dt><dd>This is a member function instead of a copy constructor so that it can have additional parameters if the need arises in the future. Additionally, not every data member is copied making its behavior different from what would be expected from a copy constructor. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_from</td><td>Object to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa724e1b9672caf6ac87e56d12977ead" name="afa724e1b9672caf6ac87e56d12977ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa724e1b9672caf6ac87e56d12977ead">&#9670;&#160;</a></span>CreateComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentTypeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ComponentTypeT * CreateComponent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ComponentTypeT &amp;&#160;</td>
          <td class="paramname"><em>_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a component of a particular type. This will copy the _data parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>The entity that will be associated with the component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_data</td><td>Data used to construct the component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the component that was created. nullptr is returned if the component was not able to be created. If _entity does not exist, nullptr will be returned. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegz_1_1sim.html#ab9e71e0a09027245f5afb2d8aa9989cb">gz::sim::enableComponent()</a>.</p>

</div>
</div>
<a id="ac6900700833b645619f720607e80df9e" name="ac6900700833b645619f720607e80df9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6900700833b645619f720607e80df9e">&#9670;&#160;</a></span>CreateEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> CreateEntity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new Entity. </p>
<dl class="section return"><dt>Returns</dt><dd>An id for the Entity, or kNullEntity on failure. </dd></dl>

</div>
</div>
<a id="aa55180fc3e0bd3da10c97b85f8fb6702" name="aa55180fc3e0bd3da10c97b85f8fb6702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55180fc3e0bd3da10c97b85f8fb6702">&#9670;&#160;</a></span>Descendants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt; Descendants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all entities which are descendants of a given entity, including the entity itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>Entity whose descendants we want. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All child entities recursively, including _entity. It will be empty if the entity doesn't exist. </dd></dl>

</div>
</div>
<a id="a561e9f13958f10e3d296ddd9c56d8ee7" name="a561e9f13958f10e3d296ddd9c56d8ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561e9f13958f10e3d296ddd9c56d8ee7">&#9670;&#160;</a></span>Each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... ComponentTypeTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Each </td>
          <td>(</td>
          <td class="paramtype">typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, ComponentTypeTs *...)&gt; &gt;::type&#160;</td>
          <td class="paramname"><em>_f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all entities which contain given component types, as well as the mutable components. Note that an entity marked for removal (but not processed yet) will be included in the list of entities iterated by this call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_f</td><td>Callback function to be called for each matching entity. The function parameter are all the desired component types, in the order they're listed on the template. The callback function can return false to stop subsequent calls to the callback, otherwise a true value should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentTypeTs</td><td>All the desired mutable component types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function should not be called outside of <a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">System</a>'s PreUpdate, Update, or PostUpdate callbacks. </dd></dl>

</div>
</div>
<a id="a628ef4ea97906791363b9df030575524" name="a628ef4ea97906791363b9df030575524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628ef4ea97906791363b9df030575524">&#9670;&#160;</a></span>Each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... ComponentTypeTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Each </td>
          <td>(</td>
          <td class="paramtype">typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, const ComponentTypeTs *...)&gt; &gt;::type&#160;</td>
          <td class="paramname"><em>_f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all entities which contain given component types, as well as the components. Note that an entity marked for removal (but not processed yet) will be included in the list of entities iterated by this call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_f</td><td>Callback function to be called for each matching entity. The function parameter are all the desired component types, in the order they're listed on the template. The callback function can return false to stop subsequent calls to the callback, otherwise a true value should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentTypeTs</td><td>All the desired component types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function should not be called outside of <a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">System</a>'s PreUpdate, Update, or PostUpdate callbacks. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1sim_1_1systems_1_1physics__system_1_1CanonicalLinkModelTracker.html#a7d5b20b1199bd27f0e8fcd26d1dfbb74">CanonicalLinkModelTracker::AddAllModels()</a>.</p>

</div>
</div>
<a id="aefabbc8810689e07ea9fdf21f4368f73" name="aefabbc8810689e07ea9fdf21f4368f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefabbc8810689e07ea9fdf21f4368f73">&#9670;&#160;</a></span>EachNew() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... ComponentTypeTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void EachNew </td>
          <td>(</td>
          <td class="paramtype">typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, ComponentTypeTs *...)&gt; &gt;::type&#160;</td>
          <td class="paramname"><em>_f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all newly created entities which contain given component types, as well as the components. This "newness" is cleared at the end of a simulation step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_f</td><td>Callback function to be called for each matching entity. The function parameter are all the desired component types, in the order they're listed on the template. The callback function can return false to stop subsequent calls to the callback, otherwise a true value should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentTypeTs</td><td>All the desired component types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Since entity creation occurs during PreUpdate, this function should not be called in a <a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">System</a>'s PreUpdate callback (it's okay to call this function in the Update callback). If you need to call this function in a system's PostUpdate callback, you should use the const version of this method. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgz_1_1sim_1_1systems_1_1physics__system_1_1CanonicalLinkModelTracker.html#ac706ef772ab315fd9745be6c17cd4e31">CanonicalLinkModelTracker::AddNewModels()</a>.</p>

</div>
</div>
<a id="a5ceed1ba8963d32cf2e79bc599911073" name="a5ceed1ba8963d32cf2e79bc599911073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ceed1ba8963d32cf2e79bc599911073">&#9670;&#160;</a></span>EachNew() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... ComponentTypeTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void EachNew </td>
          <td>(</td>
          <td class="paramtype">typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, const ComponentTypeTs *...)&gt; &gt;::type&#160;</td>
          <td class="paramname"><em>_f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all newly created entities which contain given component types, as well as the components. This "newness" is cleared at the end of a simulation step. This is the const version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_f</td><td>Callback function to be called for each matching entity. The function parameter are all the desired component types, in the order they're listed on the template. The callback function can return false to stop subsequent calls to the callback, otherwise a true value should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentTypeTs</td><td>All the desired component types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Since entity creation occurs during PreUpdate, this function should not be called in a <a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">System</a>'s PreUpdate callback (it's okay to call this function in the Update or PostUpdate callback). </dd></dl>

</div>
</div>
<a id="a1dc7e8b0be22214e7c94c96aa2d88757" name="a1dc7e8b0be22214e7c94c96aa2d88757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc7e8b0be22214e7c94c96aa2d88757">&#9670;&#160;</a></span>EachNoCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... ComponentTypeTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void EachNoCache </td>
          <td>(</td>
          <td class="paramtype">typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, ComponentTypeTs *...)&gt; &gt;::type&#160;</td>
          <td class="paramname"><em>_f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version of <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a628ef4ea97906791363b9df030575524" title="Get all entities which contain given component types, as well as the components. Note that an entity ...">Each()</a> that doesn't use a cache. The cached version, <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a628ef4ea97906791363b9df030575524" title="Get all entities which contain given component types, as well as the components. Note that an entity ...">Each()</a>, is preferred. Get all entities which contain given component types, as well as the mutable components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_f</td><td>Callback function to be called for each matching entity. The function parameter are all the desired component types, in the order they're listed on the template. The callback function can return false to stop subsequent calls to the callback, otherwise a true value should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentTypeTs</td><td>All the desired mutable component types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function should not be called outside of <a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">System</a>'s PreUpdate, Update, or PostUpdate callbacks. </dd></dl>

</div>
</div>
<a id="ad9909c3cf7ee7fa3be581bc2d349424c" name="ad9909c3cf7ee7fa3be581bc2d349424c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9909c3cf7ee7fa3be581bc2d349424c">&#9670;&#160;</a></span>EachNoCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... ComponentTypeTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void EachNoCache </td>
          <td>(</td>
          <td class="paramtype">typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, const ComponentTypeTs *...)&gt; &gt;::type&#160;</td>
          <td class="paramname"><em>_f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version of <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a628ef4ea97906791363b9df030575524" title="Get all entities which contain given component types, as well as the components. Note that an entity ...">Each()</a> that doesn't use a cache. The cached version, <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a628ef4ea97906791363b9df030575524" title="Get all entities which contain given component types, as well as the components. Note that an entity ...">Each()</a>, is preferred. Get all entities which contain given component types, as well as the components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_f</td><td>Callback function to be called for each matching entity. The function parameter are all the desired component types, in the order they're listed on the template. The callback function can return false to stop subsequent calls to the callback, otherwise a true value should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentTypeTs</td><td>All the desired component types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function should not be called outside of <a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">System</a>'s PreUpdate, Update, or PostUpdate callbacks. </dd></dl>

</div>
</div>
<a id="a405b7a7edf725eecb881e40b7b122a99" name="a405b7a7edf725eecb881e40b7b122a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405b7a7edf725eecb881e40b7b122a99">&#9670;&#160;</a></span>EachRemoved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... ComponentTypeTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void EachRemoved </td>
          <td>(</td>
          <td class="paramtype">typename identity&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt; bool(const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &amp;_entity, const ComponentTypeTs *...)&gt; &gt;::type&#160;</td>
          <td class="paramname"><em>_f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all entities which contain given component types and are about to be removed, as well as the components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_f</td><td>Callback function to be called for each matching entity. The function parameter are all the desired component types, in the order they're listed on the template. The callback function can return false to stop subsequent calls to the callback, otherwise a true value should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentTypeTs</td><td>All the desired component types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function should not be called outside of <a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">System</a>'s PostUpdate callback. </dd></dl>

</div>
</div>
<a id="aa93c41b7102b78b385e11f792fad9d3c" name="aa93c41b7102b78b385e11f792fad9d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93c41b7102b78b385e11f792fad9d3c">&#9670;&#160;</a></span>Entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacegz_1_1sim.html#a0942f69979f48cc25ec25ef91dce814f">EntityGraph</a> &amp; Entities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a graph with all the entities. Entities are vertices and edges point from parent to children. </p>
<dl class="section return"><dt>Returns</dt><dd>Entity graph. </dd></dl>

</div>
</div>
<a id="a4b3bca25398e81e9fd8ff886b8f2e953" name="a4b3bca25398e81e9fd8ff886b8f2e953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3bca25398e81e9fd8ff886b8f2e953">&#9670;&#160;</a></span>EntitiesByComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... ComponentTypeTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt; EntitiesByComponents </td>
          <td>(</td>
          <td class="paramtype">const ComponentTypeTs &amp;...&#160;</td>
          <td class="paramname"><em>_desiredComponents</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all entities which match the value of all the given components. For example, the following will return the entities which have a name component equal to "camera" and a sensor component: </p>
<p>auto entities = EntitiesByComponents(<a class="el" href="namespacegz_1_1sim_1_1components.html#a501c2b6aeb7302e017055ef1a442faab" title="This component holds an entity&#39;s name. The component has no concept of scoped names nor does it care ...">components::Name</a>("camera"), <a class="el" href="namespacegz_1_1sim_1_1components.html#ae2d25e3054c34c5737e140572d8db146" title="A component that identifies an entity as being a sensor.">components::Sensor()</a>);</p>
<p>Component type must have inequality operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_desiredComponents</td><td>All the components which must match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All matching entities, or an empty vector if no child entity has the exact components. </dd></dl>

</div>
</div>
<a id="a0086e69bf9b5deedf60068d5ab2473a9" name="a0086e69bf9b5deedf60068d5ab2473a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0086e69bf9b5deedf60068d5ab2473a9">&#9670;&#160;</a></span>EntityByComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... ComponentTypeTs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> EntityByComponents </td>
          <td>(</td>
          <td class="paramtype">const ComponentTypeTs &amp;...&#160;</td>
          <td class="paramname"><em>_desiredComponents</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an entity which matches the value of all the given components. For example, the following will return the entity which has a name component equal to "name" and has a model component: </p>
<p>auto entity = EntityByComponents(<a class="el" href="namespacegz_1_1sim_1_1components.html#a501c2b6aeb7302e017055ef1a442faab" title="This component holds an entity&#39;s name. The component has no concept of scoped names nor does it care ...">components::Name</a>("name"), <a class="el" href="namespacegz_1_1sim_1_1components.html#a81c45336dd134e03c5a29b34beb293db" title="A component that identifies an entity as being a model.">components::Model()</a>);</p>
<p>Component type must have inequality operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_desiredComponents</td><td>All the components which must match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Entity or kNullEntity if no entity has the exact components. </dd></dl>

</div>
</div>
<a id="a79a4bd7fb4a2e70b618c6683914f542d" name="a79a4bd7fb4a2e70b618c6683914f542d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a4bd7fb4a2e70b618c6683914f542d">&#9670;&#160;</a></span>EntityByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt; EntityByName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an Entity based on a name component that is associated with the entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name associated with the Entity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Entity, if an Entity with the given name exists, otherwise return std::nullopt. </dd></dl>

</div>
</div>
<a id="a4a34d566628f47ade9145d22a5c4947e" name="a4a34d566628f47ade9145d22a5c4947e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a34d566628f47ade9145d22a5c4947e">&#9670;&#160;</a></span>EntityCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t EntityCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of entities on the server. </p>
<dl class="section return"><dt>Returns</dt><dd>Entity count. </dd></dl>

</div>
</div>
<a id="aa0873d697c428473208cf78d771f0512" name="aa0873d697c428473208cf78d771f0512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0873d697c428473208cf78d771f0512">&#9670;&#160;</a></span>EntityHasComponentType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EntityHasComponentType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &amp;&#160;</td>
          <td class="paramname"><em>_typeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether an entity has a specific component type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>The entity to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_typeId</td><td>Component type id to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entity exists and has at least one component with the provided type. </dd></dl>

</div>
</div>
<a id="a34412605b9d0e369e3db64fdd2136592" name="a34412605b9d0e369e3db64fdd2136592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34412605b9d0e369e3db64fdd2136592">&#9670;&#160;</a></span>EntityMatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EntityMatches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether an entity has all the given component types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>The entity to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_types</td><td>Component types to check that the Entity has. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given entity has all the given types. </dd></dl>

</div>
</div>
<a id="a90537d1e3cc92b8b3a99e1f369441e52" name="a90537d1e3cc92b8b3a99e1f369441e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90537d1e3cc92b8b3a99e1f369441e52">&#9670;&#160;</a></span>ForEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function , class... ComponentTypeTs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ForEach </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ComponentTypeTs &amp;...&#160;</td>
          <td class="paramname"><em>_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function for each parameter in a pack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_f</td><td>Function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_components</td><td>Parameters which should be passed to the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b1af2e05f485d5c03ad68ba0efaeaa9" name="a0b1af2e05f485d5c03ad68ba0efaeaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1af2e05f485d5c03ad68ba0efaeaa9">&#9670;&#160;</a></span>HasComponentType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasComponentType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a>&#160;</td>
          <td class="paramname"><em>_typeId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether a component type has ever been created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_typeId</td><td>ID of the component type to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the provided _typeId has been created. </dd></dl>

</div>
</div>
<a id="a2e4aecf35b0ea8661ef18f6e675547cd" name="a2e4aecf35b0ea8661ef18f6e675547cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4aecf35b0ea8661ef18f6e675547cd">&#9670;&#160;</a></span>HasEntitiesMarkedForRemoval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasEntitiesMarkedForRemoval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether there are any entities marked to be removed. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there are entities marked to be removed. </dd></dl>

</div>
</div>
<a id="a0f1b1438fb57a11e5122fa536a10f031" name="a0f1b1438fb57a11e5122fa536a10f031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1b1438fb57a11e5122fa536a10f031">&#9670;&#160;</a></span>HasEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasEntity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether an Entity exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>Entity to confirm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the Entity exists. </dd></dl>

</div>
</div>
<a id="a935d95e6f8eab23389a62d30050f0a0a" name="a935d95e6f8eab23389a62d30050f0a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935d95e6f8eab23389a62d30050f0a0a">&#9670;&#160;</a></span>HasNewEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasNewEntities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether there are new entities. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there are new entities. </dd></dl>

</div>
</div>
<a id="abf642a116d7e3afdb1d4e62849f68ab8" name="abf642a116d7e3afdb1d4e62849f68ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf642a116d7e3afdb1d4e62849f68ab8">&#9670;&#160;</a></span>HasOneTimeComponentChanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasOneTimeComponentChanges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether there are one-time component changes. These changes do not happen frequently and should be processed immediately. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there are any components with one-time changes. </dd></dl>

</div>
</div>
<a id="a897e2992c04baccc696f7149be4e284e" name="a897e2992c04baccc696f7149be4e284e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897e2992c04baccc696f7149be4e284e">&#9670;&#160;</a></span>HasPeriodicComponentChanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasPeriodicComponentChanges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether there are periodic component changes. These changes may happen frequently and are processed periodically. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there are any components with periodic changes. </dd></dl>

</div>
</div>
<a id="a1785c0d201b2f62452ad6210664f5364" name="a1785c0d201b2f62452ad6210664f5364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1785c0d201b2f62452ad6210664f5364">&#9670;&#160;</a></span>HasRemovedComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasRemovedComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if there are components marked for removal. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there are components marked for removal. </dd></dl>

</div>
</div>
<a id="a66857d225cebd7482dab36144bb2f3cb" name="a66857d225cebd7482dab36144bb2f3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66857d225cebd7482dab36144bb2f3cb">&#9670;&#160;</a></span>ParentEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> ParentEntity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first parent of the given entity. </p>
<p>Entities are not expected to have multiple parents. TODO(louise) Either prevent multiple parents or provide full support for multiple parents. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>Entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parent entity or kNullEntity if there's none. </dd></dl>

</div>
</div>
<a id="a0315eb75fd6885729d98eddffd7fda17" name="a0315eb75fd6885729d98eddffd7fda17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0315eb75fd6885729d98eddffd7fda17">&#9670;&#160;</a></span>PeriodicStateFromCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PeriodicStateFromCache </td>
          <td>(</td>
          <td class="paramtype">msgs::SerializedStateMap &amp;&#160;</td>
          <td class="paramname"><em>_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>_cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate a message with relevant changes to the state given a periodic change cache. </p>
<p>The header of the message will not be populated, it is the responsibility of the caller to timestamp it before use. Additionally, changes such as addition or removal will not be populated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">_state</td><td>The serialized state message to populate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_cache</td><td>A map of entities and components to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>EntityComponenetManager::UpdatePeriodicChangeCache </dd></dl>

</div>
</div>
<a id="ab2038db3fc414935074741f0a48b648b" name="ab2038db3fc414935074741f0a48b648b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2038db3fc414935074741f0a48b648b">&#9670;&#160;</a></span>PinEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PinEntity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_recursive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevent an entity and optionally its children from being removed. </p>
<p>This function can be useful when seek operations during log playback are used in conjunction with spawned entities. For example, you may want to record a video based on a log file using a headless simulation instance. This requires a camera sensor which would be spawned during log playback. If a seek backward in time is performed during log playback, then the spawned camera would be removed. Use this function to prevent the camera from automatic removal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>Entity to be pinned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_recursive</td><td>Whether to recursively pin all child entities. True by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04ca781fb60cc7e626028af125269c46" name="a04ca781fb60cc7e626028af125269c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ca781fb60cc7e626028af125269c46">&#9670;&#160;</a></span>ProcessRemoveEntityRequests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProcessRemoveEntityRequests </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process all entity remove requests. This will remove entities and their components. This function is protected to facilitate testing. </p>

</div>
</div>
<a id="aa44375162c6240103919dcd29ce2d374" name="aa44375162c6240103919dcd29ce2d374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44375162c6240103919dcd29ce2d374">&#9670;&#160;</a></span>RebuildViews()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RebuildViews </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rebuild all the views. This could be an expensive operation. </p>

</div>
</div>
<a id="a9affd38fecd00cdf6b6884d46fa6a4e0" name="a9affd38fecd00cdf6b6884d46fa6a4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9affd38fecd00cdf6b6884d46fa6a4e0">&#9670;&#160;</a></span>RemoveComponent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RemoveComponent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &amp;&#160;</td>
          <td class="paramname"><em>_typeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a component from an entity based on a type id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>The entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_typeId</td><td>Component's type Id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entity and component existed and the component was removed. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegz_1_1sim.html#ab9e71e0a09027245f5afb2d8aa9989cb">gz::sim::enableComponent()</a>.</p>

</div>
</div>
<a id="a9cb60b40b5778b14ad707da543daaecf" name="a9cb60b40b5778b14ad707da543daaecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb60b40b5778b14ad707da543daaecf">&#9670;&#160;</a></span>RemoveComponent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentTypeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RemoveComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a component from an entity based on a type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>The entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Component</td><td>type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entity and component existed and the component was removed. </dd></dl>

</div>
</div>
<a id="a5b02fd8d848b48388d1d8b51f7ad721f" name="a5b02fd8d848b48388d1d8b51f7ad721f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b02fd8d848b48388d1d8b51f7ad721f">&#9670;&#160;</a></span>RequestRemoveEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RequestRemoveEntities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request to remove all entities. This will insert the request into a queue. The queue is processed toward the end of a simulation update step. </p>

</div>
</div>
<a id="a09b6650a35dcfad315ced8cfc90429a3" name="a09b6650a35dcfad315ced8cfc90429a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b6650a35dcfad315ced8cfc90429a3">&#9670;&#160;</a></span>RequestRemoveEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RequestRemoveEntity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_recursive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request an entity deletion. This will insert the request into a queue. The queue is processed toward the end of a simulation update step. </p>
<p>It is recommended that systems don't call this function directly, and instead use the <code><a class="el" href="classgz_1_1sim_1_1SdfEntityCreator.html" title="Provides convenient functions to spawn entities and load their plugins from SDF elements,...">sim::SdfEntityCreator</a></code> class to remove entities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>Entity to be removed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_recursive</td><td>Whether to recursively delete all child entities. True by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac49e362ab68e472d9dc65d8eb7c79123" name="ac49e362ab68e472d9dc65d8eb7c79123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49e362ab68e472d9dc65d8eb7c79123">&#9670;&#160;</a></span>ResetTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ResetTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html">EntityComponentManager</a> &amp;&#160;</td>
          <td class="paramname"><em>_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a diff, apply it to this ECM. Note that for removed entities, this would mark them for removal instead of actually removing the entities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_other</td><td>Original <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html" title="The EntityComponentManager constructs, deletes, and returns components and entities....">EntityComponentManager</a> from which the diff was computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46f812c07983a72d84430c96b7750da9" name="a46f812c07983a72d84430c96b7750da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f812c07983a72d84430c96b7750da9">&#9670;&#160;</a></span>SetAllComponentsUnchanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetAllComponentsUnchanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark all components as not changed. </p>

</div>
</div>
<a id="a0f9fb828ad3327905b7a63d62ece41dc" name="a0f9fb828ad3327905b7a63d62ece41dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9fb828ad3327905b7a63d62ece41dc">&#9670;&#160;</a></span>SetChanged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetChanged </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a>&#160;</td>
          <td class="paramname"><em>_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1sim.html#af8cb05dbaab6a7d39b05bf4366d4a782">sim::ComponentState</a>&#160;</td>
          <td class="paramname"><em>_c</em> = <code><a class="el" href="namespacegz_1_1sim.html#af8cb05dbaab6a7d39b05bf4366d4a782a788dd38d4b17d40c57353d5a7a2e081c">ComponentState::OneTimeChange</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the changed state of a component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>The entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_type</td><td>Type of the component. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_c</td><td>Changed state value, defaults to one-time-change. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada2c5008634545bbb5d9cb3a14a3aecf" name="ada2c5008634545bbb5d9cb3a14a3aecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2c5008634545bbb5d9cb3a14a3aecf">&#9670;&#160;</a></span>SetComponentData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ComponentTypeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool SetComponentData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ComponentTypeT::Type &amp;&#160;</td>
          <td class="paramname"><em>_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the data from a component. </p>
<ul>
<li>If the component type doesn't hold any data, this won't compile.</li>
<li>If the entity doesn't have that component, the component will be created.</li>
<li>If the entity has the component, its data will be updated. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>The entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_data</td><td>New component data </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ComponentTypeT</td><td>Component type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if data has changed. It will always be true if the data type doesn't have an equality operator. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a1fe7ef96866a8d666af13944fcaf0dfc" name="a1fe7ef96866a8d666af13944fcaf0dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe7ef96866a8d666af13944fcaf0dfc">&#9670;&#160;</a></span>SetEntityCreateOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetEntityCreateOffset </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All future entities will have an id that starts at _offset. This can be used to avoid entity id collisions, such as during log playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_offset</td><td>Offset value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaf43436bc3e47fc5544b80bd8c4c4b6" name="abaf43436bc3e47fc5544b80bd8c4c4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf43436bc3e47fc5544b80bd8c4c4b6">&#9670;&#160;</a></span>SetParentEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SetParentEntity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the parent of an entity. </p>
<p>It is recommended that systems don't call this function directly, and instead use the <code><a class="el" href="classgz_1_1sim_1_1SdfEntityCreator.html" title="Provides convenient functions to spawn entities and load their plugins from SDF elements,...">sim::SdfEntityCreator</a></code> class to create entities that have the correct parent-child relationship.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_child</td><td>Entity to set the parent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_parent</td><td>Entity which should be an immediate parent _child entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful. Will fail if entities don't exist. </dd></dl>

</div>
</div>
<a id="a573b9551891a135bce602344e73a2a36" name="a573b9551891a135bce602344e73a2a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573b9551891a135bce602344e73a2a36">&#9670;&#160;</a></span>SetState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetState </td>
          <td>(</td>
          <td class="paramtype">const msgs::SerializedState &amp;&#160;</td>
          <td class="paramname"><em>_stateMsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the absolute state of the ECM from a serialized message. Entities / components that are in the new state but not in the old one will be created. Entities / components that are marked as removed will be removed, but they won't be removed if they're not present in the state. </p>
<p>The header of the message will not be handled, it is the responsibility of the caller to use the timestamp. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_stateMsg</td><td>Message containing state to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f8814e7490aff65fa97b87beb25bff9" name="a6f8814e7490aff65fa97b87beb25bff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8814e7490aff65fa97b87beb25bff9">&#9670;&#160;</a></span>SetState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetState </td>
          <td>(</td>
          <td class="paramtype">const msgs::SerializedStateMap &amp;&#160;</td>
          <td class="paramname"><em>_stateMsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the absolute state of the ECM from a serialized message. Entities / components that are in the new state but not in the old one will be created. Entities / components that are marked as removed will be removed, but they won't be removed if they're not present in the state. </p>
<p>The header of the message will not be handled, it is the responsibility of the caller to use the timestamp. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_stateMsg</td><td>Message containing state to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dbc9cf1c9eb4af335aebc178b6cb6f7" name="a8dbc9cf1c9eb4af335aebc178b6cb6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbc9cf1c9eb4af335aebc178b6cb6f7">&#9670;&#160;</a></span>State() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">msgs::SerializedState State </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_entities</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_types</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a message with the serialized state of the given entities and components. </p>
<p>The header of the message will not be populated, it is the responsibility of the caller to timestamp it before use. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entities</td><td>Entities to be serialized. Leave empty to get all entities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_types</td><td>Type ID of components to be serialized. Leave empty to get all components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2ac8ff529f6c2937938404a7bcc6729" name="aa2ac8ff529f6c2937938404a7bcc6729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ac8ff529f6c2937938404a7bcc6729">&#9670;&#160;</a></span>State() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void State </td>
          <td>(</td>
          <td class="paramtype">msgs::SerializedStateMap &amp;&#160;</td>
          <td class="paramname"><em>_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_entities</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_types</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_full</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a message with the serialized state of the given entities and components. </p>
<p>The header of the message will not be populated, it is the responsibility of the caller to timestamp it before use. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_state</td><td>The serialized state message to populate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_entities</td><td>Entities to be serialized. Leave empty to get all entities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_types</td><td>Type ID of components to be serialized. Leave empty to get all components. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_full</td><td>True to get all the entities and components. False will get only components and entities that have changed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c852e52c49724fb71eadf32a0084a9c" name="a8c852e52c49724fb71eadf32a0084a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c852e52c49724fb71eadf32a0084a9c">&#9670;&#160;</a></span>UnpinAllEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UnpinAllEntities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow all previously pinned entities to be removed. </p>
<dl class="section see"><dt>See also</dt><dd>void <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#ab2038db3fc414935074741f0a48b648b" title="Prevent an entity and optionally its children from being removed.">PinEntity(const Entity, bool)</a> </dd></dl>

</div>
</div>
<a id="ab33f978a8d2fff3cb3fa8dc6c3a0bb18" name="ab33f978a8d2fff3cb3fa8dc6c3a0bb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33f978a8d2fff3cb3fa8dc6c3a0bb18">&#9670;&#160;</a></span>UnpinEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UnpinEntity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_recursive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow an entity, and optionally its children, previously marked as pinned to be removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>Entity to be unpinned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_recursive</td><td>Whether to recursively unpin all child entities. True by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>void <a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#ab2038db3fc414935074741f0a48b648b" title="Prevent an entity and optionally its children from being removed.">PinEntity(const Entity, bool)</a> </dd></dl>

</div>
</div>
<a id="a9399eeac5e1dbf371f9ada3b4c26928e" name="a9399eeac5e1dbf371f9ada3b4c26928e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9399eeac5e1dbf371f9ada3b4c26928e">&#9670;&#160;</a></span>UpdatePeriodicChangeCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UpdatePeriodicChangeCache </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="el" href="namespacegz_1_1sim.html#abab4b072dfb7fefac5d9a58df567162e">ComponentTypeId</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a cache of components with periodic changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">_changes</td><td>A list of components with the latest periodic changes. If a component has a periodic change, it is added to the hash map. It the component or entity was removed, it is removed from the hashmap. This way the hashmap stores a list of components and entities which have had periodic changes in the past and still exist within the ECM. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgz_1_1sim_1_1EntityComponentManager.html#a0315eb75fd6885729d98eddffd7fda17" title="Populate a message with relevant changes to the state given a periodic change cache.">EntityComponentManager::PeriodicStateFromCache</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="EntityComponentManager_8hh_source.html">EntityComponentManager.hh</a></li>
</ul>
</div><!-- contents -->
      </div>
    </main>
  </div>
</body>
