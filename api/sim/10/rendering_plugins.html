<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Sim">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Sim: Rendering plugins</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Sim</h1>
        <h2>API Reference</h2>
        <div class="version">
        10.0.0~pre2
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Rendering plugins</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial will go over how to write Gazebo plugins that alter the 3D scene's visual appearance using Gazebo Rendering APIs.</p>
<p>This is not to be confused with integrating a new rendering engine. See <a href="https://gazebosim.org/api/rendering/8/renderingplugin.html">How to write your own rendering engine plugin</a> for that.</p>
<p>This tutorial will go over a couple of example plugins that are located at <a href="https://github.com/gazebosim/gz-sim/tree/gz-sim10/examples/plugin/rendering_plugins">https://github.com/gazebosim/gz-sim/tree/gz-sim10/examples/plugin/rendering_plugins</a>.</p>
<h2><a class="anchor" id="scenes"></a>
Scenes</h2>
<p>During simulation, there are up to two 3D scenes being rendered by Gazebo, one on the server process and one on the client process.</p>
<p>The server-side scene will only be created when using the <code><a class="el" href="classgz_1_1sim_1_1systems_1_1Sensors.html" title="A system that manages sensors.">gz::sim::systems::Sensors</a></code> system plugin on the server. This is the scene that shows what the sensors see.</p>
<p>The client-side scene will only be created when using the <code>gz::gui::plugins::MinimalScene</code> GUI system plugin on the client. This is the scene that shows what the user sees.</p>
<p>For the user to see what the sensors see, they need to use other GUI plugins that display sensor data, such as <code>gz::gui::plugins::ImageDisplay</code> for camera images or <code><a class="el" href="classgz_1_1sim_1_1GZ__SIM__VERSION__NAMESPACE_1_1VisualizeLidar.html" title="Visualize the LaserScan message returned by the sensors. Use the checkbox to turn visualization of no...">gz::sim::VisualizeLidar</a></code> for lidar point clouds.</p>
<p>Gazebo keeps these scenes in sync by sending periodic state messages from the server to the client that contain entity and component data with the <code><a class="el" href="classgz_1_1sim_1_1systems_1_1SceneBroadcaster.html" title="System which periodically publishes a gz::msgs::Scene message with updated information.">gz::sim::systems::SceneBroadcaster</a></code> plugin. Any changes done to these scenes using Gazebo Rendering APIs directly, as described in this tutorial, will only affect one of the scenes and will not be synchronized. The examples below will show how to change the ambient light for each scene separately.</p>
<h2><a class="anchor" id="plugin-types"></a>
Plugin types</h2>
<p>Depending on the scene that you want to affect, you'll need to write a different plugin.</p>
<p>To interact with the server-side scene, you'll need to write an <code><a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">gz::sim::System</a></code>. See <a href="createsystemplugins.html">Create System Plugins</a>.</p>
<p>To interact with the client-side scene, you'll need to write an gz::gui::Plugin, or a more specialized <code><a class="el" href="classgz_1_1sim_1_1GuiSystem.html" title="Base class for a GUI System.">gz::sim::GuiSystem</a></code> if you need to access entities and components. See the <a href="https://github.com/gazebosim/gz-sim/tree/gz-sim10/examples/plugin/gui_system_plugin">GUI system plugin example</a>.</p>
<h2><a class="anchor" id="getting-the-scene"></a>
Getting the scene</h2>
<p>When writing either plugin type, the <code>gz::rendering::Scene</code> pointer can be conveniently found using the rendering engine's singleton. Both example plugins use the exact same logic to get the scene:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> RenderingServerPlugin::FindScene()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> loadedEngNames = gz::rendering::loadedEngines();</div>
<div class="line">  <span class="keywordflow">if</span> (loadedEngNames.empty())</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_defineRef" href="https://gazebosim.org/api/common/7/Console_8hh.html#a58c4a30f09cc339a21a6f92a75cd367a">gzdbg</a> &lt;&lt; <span class="stringliteral">&quot;No rendering engine is loaded yet&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// assume there is only one engine loaded</span></div>
<div class="line">  <span class="keyword">auto</span> engineName = loadedEngNames[0];</div>
<div class="line">  <span class="keywordflow">if</span> (loadedEngNames.size() &gt; 1)</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_defineRef" href="https://gazebosim.org/api/common/7/Console_8hh.html#a58c4a30f09cc339a21a6f92a75cd367a">gzdbg</a> &lt;&lt; <span class="stringliteral">&quot;More than one engine is available. &quot;</span></div>
<div class="line">      &lt;&lt; <span class="stringliteral">&quot;Using engine [&quot;</span> &lt;&lt; engineName &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">auto</span> engine = gz::rendering::engine(engineName);</div>
<div class="line">  <span class="keywordflow">if</span> (!engine)</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_defineRef" href="https://gazebosim.org/api/common/7/Console_8hh.html#acf18c83e7419e002351f1eeceb6c2cf4">gzerr</a> &lt;&lt; <span class="stringliteral">&quot;Internal error: failed to load engine [&quot;</span> &lt;&lt; engineName</div>
<div class="line">      &lt;&lt; <span class="stringliteral">&quot;]. Grid plugin won&#39;t work.&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (engine-&gt;SceneCount() == 0)</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_defineRef" href="https://gazebosim.org/api/common/7/Console_8hh.html#a58c4a30f09cc339a21a6f92a75cd367a">gzdbg</a> &lt;&lt; <span class="stringliteral">&quot;No scene has been created yet&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get first scene</span></div>
<div class="line">  <span class="keyword">auto</span> scenePtr = engine-&gt;SceneByIndex(0);</div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> == scenePtr)</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_defineRef" href="https://gazebosim.org/api/common/7/Console_8hh.html#acf18c83e7419e002351f1eeceb6c2cf4">gzerr</a> &lt;&lt; <span class="stringliteral">&quot;Internal error: scene is null.&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (engine-&gt;SceneCount() &gt; 1)</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_defineRef" href="https://gazebosim.org/api/common/7/Console_8hh.html#a58c4a30f09cc339a21a6f92a75cd367a">gzdbg</a> &lt;&lt; <span class="stringliteral">&quot;More than one scene is available. &quot;</span></div>
<div class="line">      &lt;&lt; <span class="stringliteral">&quot;Using scene [&quot;</span> &lt;&lt; scene-&gt;Name() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/io/manip/endl.html">std::endl</a>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!scenePtr-&gt;IsInitialized() || <span class="keyword">nullptr</span> == scenePtr-&gt;RootVisual())</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  this-&gt;scene = scenePtr;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The function above works for most cases, but you're welcome to customize it for your use case.</p>
<h2><a class="anchor" id="render-thread"></a>
Render thread</h2>
<p>Rendering operations aren't thread-safe. To make sure there are no race conditions, all rendering operations should happen in the same thread, the "render thread". In order to access that thread from a custom plugin, it's necessary to listen to events that the 3D scene is emitting. These are different for each plugin type.</p>
<h3><a class="anchor" id="render-events-on-the-gui"></a>
Render events on the GUI</h3>
<p>The GUI plugin will need to listen to gz::gui::events::Render events. Here's how to do it:</p>
<ol type="1">
<li><p class="startli">Include the GUI events header:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gz/gui/GuiEvents.hh&gt;</span></div>
</div><!-- fragment --></li>
<li><p class="startli">The 3D scene sends render events periodically to the <code>gz::gui::MainWindow</code>, not directly to every plugin. Therefore, your plugin will need to install a filter so that it receives all events coming from the <code>MainWindow</code>. In your plugin's <code>LoadConfig</code> call, install the filter as follows:</p>
<div class="fragment"><div class="line">  gz::gui::App()-&gt;findChild&lt;</div>
<div class="line">      gz::gui::MainWindow *&gt;()-&gt;installEventFilter(<span class="keyword">this</span>);</div>
</div><!-- fragment --></li>
<li><p class="startli">The filter will direct all of <code>MainWindow</code>'s events to the <code>eventFilter</code> callback. Add that function to your plugin as follows. Be sure to check for the event that you want, and end the <code>eventFilter</code> function by forwarding the event to the base class.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> RenderingGuiPlugin::eventFilter(QObject *_obj, QEvent *_event)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (_event-&gt;type() == gz::gui::events::Render::kType)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// This event is called in the render thread, so it&#39;s safe to make</span></div>
<div class="line">    <span class="comment">// rendering calls here</span></div>
<div class="line">    this-&gt;PerformRenderingOperations();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Standard event processing</span></div>
<div class="line">  <span class="keywordflow">return</span> QObject::eventFilter(_obj, _event);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><p class="startli">All your rendering operations should happen right there where <code>PerformRenderingOperations</code> is located. In this example plugin, it checks if the <code>dirty</code> flag is set, and if it is, it changes the scene's ambient light color randomly.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> RenderingGuiPlugin::PerformRenderingOperations()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!this-&gt;dirty)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> == this-&gt;scene)</div>
<div class="line">  {</div>
<div class="line">    this-&gt;FindScene();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> == this-&gt;scene)</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">  this-&gt;scene-&gt;SetAmbientLight({</div>
<div class="line">      <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(<a class="code hl_functionRef" href="https://gazebosim.org/api/math/9/classgz_1_1math_1_1Rand.html#ad349287c5fc5e9c115bbbb2fce72d727">gz::math::Rand::DblUniform</a>(0.0, 1.0)),</div>
<div class="line">      <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(<a class="code hl_functionRef" href="https://gazebosim.org/api/math/9/classgz_1_1math_1_1Rand.html#ad349287c5fc5e9c115bbbb2fce72d727">gz::math::Rand::DblUniform</a>(0.0, 1.0)),</div>
<div class="line">      <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(<a class="code hl_functionRef" href="https://gazebosim.org/api/math/9/classgz_1_1math_1_1Rand.html#ad349287c5fc5e9c115bbbb2fce72d727">gz::math::Rand::DblUniform</a>(0.0, 1.0)),</div>
<div class="line">      1.0});</div>
<div class="line"> </div>
<div class="line">  this-&gt;dirty = <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<h3><a class="anchor" id="render-events-on-the-server"></a>
Render events on the server</h3>
<p>The server plugin will need to listen <code><a class="el" href="namespacegz_1_1sim_1_1events.html#a051bf7c281935b87ac35a5b8ea69ffa8" title="The pre render event is emitted before rendering updates. The event is emitted in the rendering threa...">gz::sim::events::PreRender</a></code>, <code><a class="el" href="namespacegz_1_1sim_1_1events.html#af83ef380b3f14573f0c1c456e24b03ee" title="The render event is emitted during rendering updates. The event is emitted in the rendering thread so...">gz::sim::events::Render</a></code> or <code><a class="el" href="namespacegz_1_1sim_1_1events.html#aba8a4232e1e60007e01af781e0f20da1" title="The post render event is emitted after rendering updates. The event is emitted in the rendering threa...">gz::sim::events::PostRender</a></code> events.</p>
<p>Here's how to do it:</p>
<ol type="1">
<li><p class="startli">Include the rendering events header:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="rendering_2Events_8hh.html">gz/sim/rendering/Events.hh</a>&gt;</span></div>
</div><!-- fragment --></li>
<li><p class="startli">To receive <code>PreRender</code> events, connect to it as follows, and the <code>PerformRenderingOperations</code> function will be called periodically:</p>
<div class="fragment"><div class="line">  this-&gt;connection = _eventMgr.Connect&lt;<a class="code hl_classRef" href="https://gazebosim.org/api/common/7/classgz_1_1common_1_1EventT.html">gz::sim::events::PreRender</a>&gt;(</div>
<div class="line">    <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/functional/bind.html">std::bind</a>(&amp;RenderingServerPlugin::PerformRenderingOperations, <span class="keyword">this</span>));</div>
</div><!-- fragment --></li>
<li><p class="startli">All your rendering operations should happen at <code>PerformRenderingOperations</code> is located. In this example plugin, it checks if enough time has elapsed since the last color update, and updates the color if it's time:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> RenderingServerPlugin::PerformRenderingOperations()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> == this-&gt;scene)</div>
<div class="line">  {</div>
<div class="line">    this-&gt;FindScene();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">nullptr</span> == this-&gt;scene)</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (this-&gt;simTime - this-&gt;lastUpdate &lt; 2s)</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">  this-&gt;scene-&gt;SetAmbientLight({</div>
<div class="line">      <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(<a class="code hl_functionRef" href="https://gazebosim.org/api/math/9/classgz_1_1math_1_1Rand.html#ad349287c5fc5e9c115bbbb2fce72d727">gz::math::Rand::DblUniform</a>(0.0, 1.0)),</div>
<div class="line">      <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(<a class="code hl_functionRef" href="https://gazebosim.org/api/math/9/classgz_1_1math_1_1Rand.html#ad349287c5fc5e9c115bbbb2fce72d727">gz::math::Rand::DblUniform</a>(0.0, 1.0)),</div>
<div class="line">      <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(<a class="code hl_functionRef" href="https://gazebosim.org/api/math/9/classgz_1_1math_1_1Rand.html#ad349287c5fc5e9c115bbbb2fce72d727">gz::math::Rand::DblUniform</a>(0.0, 1.0)),</div>
<div class="line">      1.0});</div>
<div class="line"> </div>
<div class="line">  this-&gt;lastUpdate = this-&gt;simTime;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="running-examples"></a>
Running examples</h2>
<p>Follow the build instructions on the rendering plugins <a href="https://github.com/gazebosim/gz-sim/blob/gz-sim10/examples/plugin/rendering_plugins">README</a> and you'll generate both plugins:</p>
<ul>
<li><code>RenderingGuiPlugin</code>: GUI plugin that updates the GUI scene's ambient light with a random color at each click.</li>
<li><code>RenderingServerPlugin</code>: Server plugin that updates the server scene's ambient light every 2 simulation seconds.</li>
</ul>
<p>Run the example world that uses both plugins and observe how the scene seen by the camera sensor, displayed on the top-left camera image, is different from the one on the GUI. Try pausing simulation and pressing the <code>RANDOM GUI COLOR</code> button to see which scene gets updated.</p>
<div class="image">
<img src="rendering_plugins.gif" alt=""/>
</div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
      </div>
    </main>
  </div>
</body>
