<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Plugin">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Plugin: Loader Class Reference</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Plugin</h1>
        <h2>API Reference</h2>
        <div class="version">
        1.4.0
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 IgnCreateDocs.cmake -->
      <nav class="ign-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.8.17 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceignition.html">ignition</a></li><li class="navelem"><a class="el" href="namespaceignition_1_1plugin.html">plugin</a></li><li class="navelem"><a class="el" href="classignition_1_1plugin_1_1Loader.html">Loader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classignition_1_1plugin_1_1Loader-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Loader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for loading plugins.  
 <a href="classignition_1_1plugin_1_1Loader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gz_2plugin_2Loader_8hh_source.html">Loader.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac082256071478316a982894d4191a11a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#ac082256071478316a982894d4191a11a">Loader</a> ()</td></tr>
<tr class="memdesc:ac082256071478316a982894d4191a11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classignition_1_1plugin_1_1Loader.html#ac082256071478316a982894d4191a11a">More...</a><br /></td></tr>
<tr class="separator:ac082256071478316a982894d4191a11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd25dd3f34914f06852c2de2f9db737"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#a8bd25dd3f34914f06852c2de2f9db737">~Loader</a> ()</td></tr>
<tr class="memdesc:a8bd25dd3f34914f06852c2de2f9db737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classignition_1_1plugin_1_1Loader.html#a8bd25dd3f34914f06852c2de2f9db737">More...</a><br /></td></tr>
<tr class="separator:a8bd25dd3f34914f06852c2de2f9db737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63adae402936681f12414d0be742dbdf"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#a63adae402936681f12414d0be742dbdf">AliasesOfPlugin</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_pluginName) const</td></tr>
<tr class="memdesc:a63adae402936681f12414d0be742dbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the aliases of the plugin with the given name.  <a href="classignition_1_1plugin_1_1Loader.html#a63adae402936681f12414d0be742dbdf">More...</a><br /></td></tr>
<tr class="separator:a63adae402936681f12414d0be742dbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708b8b69e19c77f104d4cced7c4a350b"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#a708b8b69e19c77f104d4cced7c4a350b">AllPlugins</a> () const</td></tr>
<tr class="memdesc:a708b8b69e19c77f104d4cced7c4a350b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a set of the names of all plugins that are currently known to this <a class="el" href="classignition_1_1plugin_1_1Loader.html" title="Class for loading plugins.">Loader</a>.  <a href="classignition_1_1plugin_1_1Loader.html#a708b8b69e19c77f104d4cced7c4a350b">More...</a><br /></td></tr>
<tr class="separator:a708b8b69e19c77f104d4cced7c4a350b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28045a51462e60d0955755f550115826"><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr class="memitem:a28045a51462e60d0955755f550115826"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; InterfaceType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#a28045a51462e60d0955755f550115826">Factory</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_pluginNameOrAlias) const</td></tr>
<tr class="memdesc:a28045a51462e60d0955755f550115826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a plugin for the given plugin name, and then returns a reference-counting interface corresponding to InterfaceType.  <a href="classignition_1_1plugin_1_1Loader.html#a28045a51462e60d0955755f550115826">More...</a><br /></td></tr>
<tr class="separator:a28045a51462e60d0955755f550115826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ad4803246db3abd2c41430b6579d8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#ad1ad4803246db3abd2c41430b6579d8b">ForgetLibrary</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_pathToLibrary)</td></tr>
<tr class="memdesc:ad1ad4803246db3abd2c41430b6579d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This loader will forget about the library at the given path location. If you want to instantiate a plugin from this library using this loader, you will first need to call LoadLib again.  <a href="classignition_1_1plugin_1_1Loader.html#ad1ad4803246db3abd2c41430b6579d8b">More...</a><br /></td></tr>
<tr class="separator:ad1ad4803246db3abd2c41430b6579d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4973a35efe799c9050a0e67a3e79c555"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#a4973a35efe799c9050a0e67a3e79c555">ForgetLibraryOfPlugin</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_pluginNameOrAlias)</td></tr>
<tr class="memdesc:a4973a35efe799c9050a0e67a3e79c555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forget the library that provides the plugin with the given name. Note that this will also forget all other plugin types which are provided by that library.  <a href="classignition_1_1plugin_1_1Loader.html#a4973a35efe799c9050a0e67a3e79c555">More...</a><br /></td></tr>
<tr class="separator:a4973a35efe799c9050a0e67a3e79c555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38af38708f58ad09a98603ed08fdb33c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceignition_1_1plugin.html#a6bbdc54110be7821705e387b9312816c">PluginPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#a38af38708f58ad09a98603ed08fdb33c">Instantiate</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_pluginNameOrAlias) const</td></tr>
<tr class="memdesc:a38af38708f58ad09a98603ed08fdb33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a plugin for the given plugin name.  <a href="classignition_1_1plugin_1_1Loader.html#a38af38708f58ad09a98603ed08fdb33c">More...</a><br /></td></tr>
<tr class="separator:a38af38708f58ad09a98603ed08fdb33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834dd923de4f9014d50209eb08a6b66a"><td class="memTemplParams" colspan="2">template&lt;typename PluginPtrType &gt; </td></tr>
<tr class="memitem:a834dd923de4f9014d50209eb08a6b66a"><td class="memTemplItemLeft" align="right" valign="top">PluginPtrType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#a834dd923de4f9014d50209eb08a6b66a">Instantiate</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_pluginNameOrAlias) const</td></tr>
<tr class="memdesc:a834dd923de4f9014d50209eb08a6b66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a plugin of PluginType for the given plugin name. This can be used to create a specialized PluginPtr.  <a href="classignition_1_1plugin_1_1Loader.html#a834dd923de4f9014d50209eb08a6b66a">More...</a><br /></td></tr>
<tr class="separator:a834dd923de4f9014d50209eb08a6b66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936630b1c6234756e5bd4ab6fd6fc15b"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#a936630b1c6234756e5bd4ab6fd6fc15b">InterfacesImplemented</a> () const</td></tr>
<tr class="memdesc:a936630b1c6234756e5bd4ab6fd6fc15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get demangled names of interfaces that the loader has plugins for.  <a href="classignition_1_1plugin_1_1Loader.html#a936630b1c6234756e5bd4ab6fd6fc15b">More...</a><br /></td></tr>
<tr class="separator:a936630b1c6234756e5bd4ab6fd6fc15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b2ddd492810b5120ad19bc708aa137"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#a78b2ddd492810b5120ad19bc708aa137">LoadLib</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_pathToLibrary)</td></tr>
<tr class="memdesc:a78b2ddd492810b5120ad19bc708aa137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a library at the given path.  <a href="classignition_1_1plugin_1_1Loader.html#a78b2ddd492810b5120ad19bc708aa137">More...</a><br /></td></tr>
<tr class="separator:a78b2ddd492810b5120ad19bc708aa137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd57a8ad609cfe8f0274a50d5e8de43"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#accd57a8ad609cfe8f0274a50d5e8de43">LookupPlugin</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_nameOrAlias) const</td></tr>
<tr class="memdesc:accd57a8ad609cfe8f0274a50d5e8de43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve the plugin name or alias into the name of the plugin that it maps to. If this is a name or alias that does not uniquely map to a known plugin, then the return value will be an empty string.  <a href="classignition_1_1plugin_1_1Loader.html#accd57a8ad609cfe8f0274a50d5e8de43">More...</a><br /></td></tr>
<tr class="separator:accd57a8ad609cfe8f0274a50d5e8de43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9734aec914a1d8423e8421a64df490"><td class="memTemplParams" colspan="2">template&lt;typename Interface &gt; </td></tr>
<tr class="memitem:afa9734aec914a1d8423e8421a64df490"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#afa9734aec914a1d8423e8421a64df490">PluginsImplementing</a> () const</td></tr>
<tr class="memdesc:afa9734aec914a1d8423e8421a64df490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get plugin names that implement the specified interface.  <a href="classignition_1_1plugin_1_1Loader.html#afa9734aec914a1d8423e8421a64df490">More...</a><br /></td></tr>
<tr class="separator:afa9734aec914a1d8423e8421a64df490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2f60954097c6d61a0695e1c533f050"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#a5d2f60954097c6d61a0695e1c533f050">PluginsImplementing</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_interface, const bool _demangled=true) const</td></tr>
<tr class="memdesc:a5d2f60954097c6d61a0695e1c533f050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get plugin names that implement the specified interface string. Note that the templated version of this function is recommended instead of this version to avoid confusion about whether a mangled or demangled version of a string is being used. Note that the function <a class="el" href="classignition_1_1plugin_1_1Loader.html#a936630b1c6234756e5bd4ab6fd6fc15b" title="Get demangled names of interfaces that the loader has plugins for.">InterfacesImplemented()</a> returns demangled versions of the interface names.  <a href="classignition_1_1plugin_1_1Loader.html#a5d2f60954097c6d61a0695e1c533f050">More...</a><br /></td></tr>
<tr class="separator:a5d2f60954097c6d61a0695e1c533f050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f8f6c42599ba4e57310939b7839052"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#a69f8f6c42599ba4e57310939b7839052">PluginsWithAlias</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_alias) const</td></tr>
<tr class="memdesc:a69f8f6c42599ba4e57310939b7839052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get plugin names that correspond to the specified alias string.  <a href="classignition_1_1plugin_1_1Loader.html#a69f8f6c42599ba4e57310939b7839052">More...</a><br /></td></tr>
<tr class="separator:a69f8f6c42599ba4e57310939b7839052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8f4723ce0859efe2575bc120ba02dc"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classignition_1_1plugin_1_1Loader.html#aac8f4723ce0859efe2575bc120ba02dc">PrettyStr</a> () const</td></tr>
<tr class="memdesc:aac8f4723ce0859efe2575bc120ba02dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a printable string with info about plugins.  <a href="classignition_1_1plugin_1_1Loader.html#aac8f4723ce0859efe2575bc120ba02dc">More...</a><br /></td></tr>
<tr class="separator:aac8f4723ce0859efe2575bc120ba02dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for loading plugins. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac082256071478316a982894d4191a11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac082256071478316a982894d4191a11a">&#9670;&nbsp;</a></span>Loader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classignition_1_1plugin_1_1Loader.html">Loader</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="a8bd25dd3f34914f06852c2de2f9db737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd25dd3f34914f06852c2de2f9db737">&#9670;&nbsp;</a></span>~Loader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classignition_1_1plugin_1_1Loader.html">Loader</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a63adae402936681f12414d0be742dbdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63adae402936681f12414d0be742dbdf">&#9670;&nbsp;</a></span>AliasesOfPlugin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt; AliasesOfPlugin </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_pluginName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the aliases of the plugin with the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pluginName</td><td>The name of the desired plugin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of aliases corresponding to the desired plugin </dd></dl>

</div>
</div>
<a id="a708b8b69e19c77f104d4cced7c4a350b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708b8b69e19c77f104d4cced7c4a350b">&#9670;&nbsp;</a></span>AllPlugins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt; AllPlugins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a set of the names of all plugins that are currently known to this <a class="el" href="classignition_1_1plugin_1_1Loader.html" title="Class for loading plugins.">Loader</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A set of all plugin names known to this <a class="el" href="classignition_1_1plugin_1_1Loader.html" title="Class for loading plugins.">Loader</a>. </dd></dl>

</div>
</div>
<a id="a28045a51462e60d0955755f550115826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28045a51462e60d0955755f550115826">&#9670;&nbsp;</a></span>Factory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;InterfaceType&gt; <a class="el" href="classignition_1_1plugin_1_1Factory.html">Factory</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_pluginNameOrAlias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates a plugin for the given plugin name, and then returns a reference-counting interface corresponding to InterfaceType. </p>
<p>If you use this function to retrieve a <a class="el" href="classignition_1_1plugin_1_1Factory.html" title="The Factory class defines a plugin factory that can be used by the Loader class to produce products t...">Factory</a>, you can call Construct(...) on the returned interface, as long as the returned interface is not a nullptr.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This function is identical to:</dd></dl>
<div class="fragment"><div class="line">loader-&gt;Instantiate(_pluginNameOrAlias)</div>
<div class="line">  -&gt;QueryInterfaceSharedPtr&lt;InterfaceType&gt;();</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InterfaceType</td><td>The type of interface to look for. This function is meant for producing Factories, but any type of Interface can be requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pluginNameOrAlias</td><td>Name or alias of the plugin that you want to use for production.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to an InterfaceType if it can be provided by the requested plugin. </dd></dl>

</div>
</div>
<a id="ad1ad4803246db3abd2c41430b6579d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ad4803246db3abd2c41430b6579d8b">&#9670;&nbsp;</a></span>ForgetLibrary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ForgetLibrary </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_pathToLibrary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This loader will forget about the library at the given path location. If you want to instantiate a plugin from this library using this loader, you will first need to call LoadLib again. </p>
<p>After this function has been called, once all plugin instances that are tied to the library have been deleted, the library will automatically be unloaded from the executable. Note that when this <a class="el" href="classignition_1_1plugin_1_1Loader.html" title="Class for loading plugins.">Loader</a> leaves scope (or gets deleted), it will have the same effect as calling ForgetLibrary on all of the libraries that it loaded, so there is generally no need to call this function. However, it may be useful if you want to reduce clutter in the <a class="el" href="classignition_1_1plugin_1_1Loader.html" title="Class for loading plugins.">Loader</a> instance or let go of library resources that are no longer being used.</p>
<p>Note that even if you have released all references to a library, it is still up to the discretion of your operating system whether (or when) that library will be unloaded. In some cases, the operating system might not choose to unload it until the program exits completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pathToLibrary</td><td>Path to the library that you want to forget</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the library was actively loaded and is now successfully forgotten. If the library was not actively loaded, this returns false. </dd></dl>

</div>
</div>
<a id="a4973a35efe799c9050a0e67a3e79c555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4973a35efe799c9050a0e67a3e79c555">&#9670;&nbsp;</a></span>ForgetLibraryOfPlugin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ForgetLibraryOfPlugin </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_pluginNameOrAlias</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forget the library that provides the plugin with the given name. Note that this will also forget all other plugin types which are provided by that library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pluginNameOrAlias</td><td>Name or alias of the plugin whose library you want to forget.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>bool <a class="el" href="classignition_1_1plugin_1_1Loader.html#ad1ad4803246db3abd2c41430b6579d8b" title="This loader will forget about the library at the given path location. If you want to instantiate a pl...">ForgetLibrary(const std::string &amp;_pathToLibrary)</a> </dd></dl>

</div>
</div>
<a id="a38af38708f58ad09a98603ed08fdb33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38af38708f58ad09a98603ed08fdb33c">&#9670;&nbsp;</a></span>Instantiate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceignition_1_1plugin.html#a6bbdc54110be7821705e387b9312816c">PluginPtr</a> Instantiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_pluginNameOrAlias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates a plugin for the given plugin name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pluginNameOrAlias</td><td>Name or alias of the plugin to instantiate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to instantiated plugin </dd></dl>

</div>
</div>
<a id="a834dd923de4f9014d50209eb08a6b66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834dd923de4f9014d50209eb08a6b66a">&#9670;&nbsp;</a></span>Instantiate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PluginPtrType Instantiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_pluginNameOrAlias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates a plugin of PluginType for the given plugin name. This can be used to create a specialized PluginPtr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PluginPtrType</td><td>The specialized type of PluginPtrPtr that you want to construct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pluginNameOrAlias</td><td>Name or alias of the plugin that you want to instantiate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer for the instantiated PluginPtr </dd></dl>

</div>
</div>
<a id="a936630b1c6234756e5bd4ab6fd6fc15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936630b1c6234756e5bd4ab6fd6fc15b">&#9670;&nbsp;</a></span>InterfacesImplemented()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt; InterfacesImplemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get demangled names of interfaces that the loader has plugins for. </p>
<dl class="section return"><dt>Returns</dt><dd>Demangled names of the interfaces that are implemented </dd></dl>

</div>
</div>
<a id="a78b2ddd492810b5120ad19bc708aa137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b2ddd492810b5120ad19bc708aa137">&#9670;&nbsp;</a></span>LoadLib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt; LoadLib </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_pathToLibrary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a library at the given path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pathToLibrary</td><td>The path to a library</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of plugins that have been loaded from the library </dd></dl>

</div>
</div>
<a id="accd57a8ad609cfe8f0274a50d5e8de43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd57a8ad609cfe8f0274a50d5e8de43">&#9670;&nbsp;</a></span>LookupPlugin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> LookupPlugin </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_nameOrAlias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve the plugin name or alias into the name of the plugin that it maps to. If this is a name or alias that does not uniquely map to a known plugin, then the return value will be an empty string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_nameOrAlias</td><td>The name or alias of the plugin of interest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the plugin being referred to, or an empty string if no such plugin is known. </dd></dl>

</div>
</div>
<a id="afa9734aec914a1d8423e8421a64df490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9734aec914a1d8423e8421a64df490">&#9670;&nbsp;</a></span>PluginsImplementing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt; PluginsImplementing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get plugin names that implement the specified interface. </p>
<dl class="section return"><dt>Returns</dt><dd>names of plugins that implement the interface. </dd></dl>

</div>
</div>
<a id="a5d2f60954097c6d61a0695e1c533f050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2f60954097c6d61a0695e1c533f050">&#9670;&nbsp;</a></span>PluginsImplementing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt; PluginsImplementing </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>_demangled</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get plugin names that implement the specified interface string. Note that the templated version of this function is recommended instead of this version to avoid confusion about whether a mangled or demangled version of a string is being used. Note that the function <a class="el" href="classignition_1_1plugin_1_1Loader.html#a936630b1c6234756e5bd4ab6fd6fc15b" title="Get demangled names of interfaces that the loader has plugins for.">InterfacesImplemented()</a> returns demangled versions of the interface names. </p>
<p>If you want to pass in a mangled version of an interface name, e.g. the result that would be produced by typeid(T).name(), then set <code>demangled</code> to false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_interface</td><td>Name of an interface</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_demangled</td><td>Specify whether the _interface string is demangled (default, true) or mangled (false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Names of plugins that implement the interface </dd></dl>

</div>
</div>
<a id="a69f8f6c42599ba4e57310939b7839052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f8f6c42599ba4e57310939b7839052">&#9670;&nbsp;</a></span>PluginsWithAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt; PluginsWithAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_alias</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get plugin names that correspond to the specified alias string. </p>
<p>If there is more than one entry in this set, then the alias cannot be used to instantiate any of those plugins.</p>
<p>If the name of a plugin matches the alias string, then that plugin will be instantiated any time the string is used to instantiate a plugin, no matter how many other plugins use the alias.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_alias</td><td>The <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html" title="STL class.">std::string</a> of the alias</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of plugins that correspond to the desired alias </dd></dl>

</div>
</div>
<a id="aac8f4723ce0859efe2575bc120ba02dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8f4723ce0859efe2575bc120ba02dc">&#9670;&nbsp;</a></span>PrettyStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> PrettyStr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a printable string with info about plugins. </p>
<dl class="section return"><dt>Returns</dt><dd>A pretty string </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="gz_2plugin_2Loader_8hh_source.html">gz/plugin/Loader.hh</a></li>
</ul>
</div><!-- contents -->
      </div>
    </main>
  </div>
</body>
