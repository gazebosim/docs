<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Plugin">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Plugin: gz::plugin Namespace Reference</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Plugin</h1>
        <h2>API Reference</h2>
        <div class="version">
        4.0.0
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.9.8 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegz.html">gz</a></li><li class="navelem"><a class="el" href="namespacegz_1_1plugin.html">plugin</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">gz::plugin Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacegz_1_1plugin_1_1v1" id="r_namespacegz_1_1plugin_1_1v1"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1plugin_1_1v1.html">v1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1EnablePluginFromThis.html">EnablePluginFromThis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgz_1_1plugin_1_1EnablePluginFromThis.html" title="EnablePluginFromThis is an optional base class which can be inherited by Plugin classes....">EnablePluginFromThis</a> is an optional base class which can be inherited by <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> classes. When a <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> class inherits it and that <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> class is instantiated using the <a class="el" href="classgz_1_1plugin_1_1Loader.html" title="Class for loading plugins.">Loader</a> class, its instance will be able to access the PluginPtr that manages its lifecycle. This interface will also be available by calling <code>instance-&gt;QueryInterface&lt;<a class="el" href="classgz_1_1plugin_1_1EnablePluginFromThis.html" title="EnablePluginFromThis is an optional base class which can be inherited by Plugin classes....">EnablePluginFromThis</a>&gt;()</code>  <a href="classgz_1_1plugin_1_1EnablePluginFromThis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1Factory.html">Factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgz_1_1plugin_1_1Factory.html" title="The Factory class defines a plugin factory that can be used by the Loader class to produce products t...">Factory</a> class defines a plugin factory that can be used by the <a class="el" href="classgz_1_1plugin_1_1Loader.html" title="Class for loading plugins.">Loader</a> class to produce products that implement an interface.  <a href="classgz_1_1plugin_1_1Factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgz_1_1plugin_1_1v1_1_1Info.html">Info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds info required to construct a plugin.  <a href="structgz_1_1plugin_1_1v1_1_1Info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1Loader.html">Loader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for loading plugins.  <a href="classgz_1_1plugin_1_1Loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1ProductDeleter.html">ProductDeleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a unary operator for safely deleting pointers to plugin factory products with the type <code>Interface</code>. If it gets passed an <code>Interface</code> pointer that is not pointing to a factory plugin product, then this just performs a normal delete.  <a href="classgz_1_1plugin_1_1ProductDeleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin.html">SpecializedPlugin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html">SpecializedPlugin&lt; SpecInterface &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> instances to have high-speed access to interfaces that can be anticipated at compile time. The plugin does not have to actually offer the specialized interface in order to get this performance improvement. This template is variadic, so it can support arbitrarily many interfaces.  <a href="classgz_1_1plugin_1_1SpecializedPlugin_3_01SpecInterface_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1TemplatePluginPtr.html">TemplatePluginPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class manages the lifecycle of a plugin instance. It can receive a plugin instance from the <a class="el" href="classgz_1_1plugin_1_1Loader.html" title="Class for loading plugins.">Loader</a> class or by copy-construction or assignment from another PluginPtr instance.  <a href="classgz_1_1plugin_1_1TemplatePluginPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1plugin_1_1WeakPluginPtr.html">WeakPluginPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgz_1_1plugin_1_1WeakPluginPtr.html" title="WeakPluginPtr is a non-reference-holding smart pointer for a Plugin. WeakPluginPtr is analogous to st...">WeakPluginPtr</a> is a non-reference-holding smart pointer for a <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a>. <a class="el" href="classgz_1_1plugin_1_1WeakPluginPtr.html" title="WeakPluginPtr is a non-reference-holding smart pointer for a Plugin. WeakPluginPtr is analogous to st...">WeakPluginPtr</a> is analogous to <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/weak_ptr.html">std::weak_ptr</a> where PluginPtr is analogous to <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>.  <a href="classgz_1_1plugin_1_1WeakPluginPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3882c12f75ef6a08376e49eb26677033" id="r_a3882c12f75ef6a08376e49eb26677033"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">typename</a> <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">To</a> , <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">typename</a> <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">From</a> &gt; </td></tr>
<tr class="memitem:a3882c12f75ef6a08376e49eb26677033"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">ConstCompatible</a> = detail::ConstCompatible&lt; <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">To</a>, <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">From</a> &gt;</td></tr>
<tr class="memdesc:a3882c12f75ef6a08376e49eb26677033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a static constexpr field named <code>value</code> which will be true if the type <code>From</code> has a const-quality less than or equal to the type <code>To</code>.  <br /></td></tr>
<tr class="separator:a3882c12f75ef6a08376e49eb26677033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31a3fb90680b0a2ff48363847f68ac0" id="r_ab31a3fb90680b0a2ff48363847f68ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1plugin.html#ab31a3fb90680b0a2ff48363847f68ac0">ConstInfoPtr</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">const</a> <a class="el" href="structgz_1_1plugin_1_1v1_1_1Info.html">Info</a> &gt;</td></tr>
<tr class="separator:ab31a3fb90680b0a2ff48363847f68ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c78259418ddd2272e02aeb49811b4d2" id="r_a5c78259418ddd2272e02aeb49811b4d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1plugin.html#a5c78259418ddd2272e02aeb49811b4d2">ConstPluginPtr</a> = <a class="el" href="classgz_1_1plugin_1_1TemplatePluginPtr.html">TemplatePluginPtr</a>&lt; <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">const</a> <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> &gt;</td></tr>
<tr class="memdesc:a5c78259418ddd2272e02aeb49811b4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This produces a PluginPtr whose <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> wrapper only grants access to const-qualified interfaces of the plugin instance.  <br /></td></tr>
<tr class="separator:a5c78259418ddd2272e02aeb49811b4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99dd9977a712a35a1c3c1e569dacb2e" id="r_ad99dd9977a712a35a1c3c1e569dacb2e"><td class="memTemplParams" colspan="2">template&lt;typename... SpecInterfaces&gt; </td></tr>
<tr class="memitem:ad99dd9977a712a35a1c3c1e569dacb2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1plugin.html#ad99dd9977a712a35a1c3c1e569dacb2e">ConstSpecializedPluginPtr</a> = <a class="el" href="classgz_1_1plugin_1_1TemplatePluginPtr.html">TemplatePluginPtr</a>&lt; <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">const</a> <a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin.html">SpecializedPlugin</a>&lt; SpecInterfaces... &gt; &gt;</td></tr>
<tr class="memdesc:ad99dd9977a712a35a1c3c1e569dacb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This alias creates a specialized PluginPtr whose interfaces are all const-qualified.  <br /></td></tr>
<tr class="separator:ad99dd9977a712a35a1c3c1e569dacb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694e3f7a5775c792604a66742903cc21" id="r_a694e3f7a5775c792604a66742903cc21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1plugin.html#a694e3f7a5775c792604a66742903cc21">InfoMap</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="el" href="structgz_1_1plugin_1_1v1_1_1Info.html">Info</a> &gt;</td></tr>
<tr class="separator:a694e3f7a5775c792604a66742903cc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbdc54110be7821705e387b9312816c" id="r_a6bbdc54110be7821705e387b9312816c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1plugin.html#a6bbdc54110be7821705e387b9312816c">PluginPtr</a> = <a class="el" href="classgz_1_1plugin_1_1TemplatePluginPtr.html">TemplatePluginPtr</a>&lt; <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> &gt;</td></tr>
<tr class="memdesc:a6bbdc54110be7821705e387b9312816c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typical usage for <a class="el" href="classgz_1_1plugin_1_1TemplatePluginPtr.html" title="This class manages the lifecycle of a plugin instance. It can receive a plugin instance from the Load...">TemplatePluginPtr</a> is to just hold a generic <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> type.  <br /></td></tr>
<tr class="separator:a6bbdc54110be7821705e387b9312816c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2953d9d9b79271662f93df151945f52" id="r_af2953d9d9b79271662f93df151945f52"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">typename</a> <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">Interface</a> &gt; </td></tr>
<tr class="memitem:af2953d9d9b79271662f93df151945f52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1plugin.html#af2953d9d9b79271662f93df151945f52">ProductPtr</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">Interface</a>, <a class="el" href="classgz_1_1plugin_1_1ProductDeleter.html">ProductDeleter</a>&lt; <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">Interface</a> &gt; &gt;</td></tr>
<tr class="memdesc:af2953d9d9b79271662f93df151945f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">ProductPtr is a derivative of <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a> that can safely manage the products that come out of a plugin factory. It is strongly recommended that factory products use a ProductPtr to manage the lifecycle of a factory product.  <br /></td></tr>
<tr class="separator:af2953d9d9b79271662f93df151945f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ecee778dbdcaee4977cedd7341ef55" id="r_a71ecee778dbdcaee4977cedd7341ef55"><td class="memTemplParams" colspan="2">template&lt;typename... SpecInterfaces&gt; </td></tr>
<tr class="memitem:a71ecee778dbdcaee4977cedd7341ef55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegz_1_1plugin.html#a71ecee778dbdcaee4977cedd7341ef55">SpecializedPluginPtr</a> = <a class="el" href="classgz_1_1plugin_1_1TemplatePluginPtr.html">TemplatePluginPtr</a>&lt; <a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin.html">SpecializedPlugin</a>&lt; SpecInterfaces... &gt; &gt;</td></tr>
<tr class="memdesc:a71ecee778dbdcaee4977cedd7341ef55"><td class="mdescLeft">&#160;</td><td class="mdescRight">This alias allows PluginPtr instances to have high-speed access to interfaces that can be anticipated at compile time. The plugin does not have to actually offer the specialized interface in order to get this performance improvement. This template is variadic, so it can support arbitrarily many interfaces.  <br /></td></tr>
<tr class="separator:a71ecee778dbdcaee4977cedd7341ef55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae73c6fdd6f2ae30655fb0639e53619c5" id="r_ae73c6fdd6f2ae30655fb0639e53619c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1plugin.html#ae73c6fdd6f2ae30655fb0639e53619c5">CleanupLostProducts</a> (<a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">const</a> <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> &amp;<a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">_safetyWait</a>=<a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(5))</td></tr>
<tr class="memdesc:ae73c6fdd6f2ae30655fb0639e53619c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function to cleanup the Factories of any Products which were not managed by a ProductPtr or deleted by a <a class="el" href="classgz_1_1plugin_1_1ProductDeleter.html" title="This class provides a unary operator for safely deleting pointers to plugin factory products with the...">ProductDeleter</a> (in other words, the Product was released from its ProductPtr and then its lifecycle was managed by a framework that does not know it has special deletion requirements).  <br /></td></tr>
<tr class="separator:ae73c6fdd6f2ae30655fb0639e53619c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93914cbac6e60f1a30188b47e5a6c6d4" id="r_a93914cbac6e60f1a30188b47e5a6c6d4"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1plugin.html#a93914cbac6e60f1a30188b47e5a6c6d4">DemangleSymbol</a> (<a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">const</a> <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;<a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">_symbol</a>)</td></tr>
<tr class="memdesc:a93914cbac6e60f1a30188b47e5a6c6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demangle the ABI typeinfo name of a symbol into a human-readable version.  <br /></td></tr>
<tr class="separator:a93914cbac6e60f1a30188b47e5a6c6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6af1661e7283de88c68ee4faf2fcc83" id="r_af6af1661e7283de88c68ee4faf2fcc83"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1plugin.html#af6af1661e7283de88c68ee4faf2fcc83">LostProductCount</a> ()</td></tr>
<tr class="memdesc:af6af1661e7283de88c68ee4faf2fcc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of lost products that have currently accumulated since the last time <a class="el" href="namespacegz_1_1plugin.html#ae73c6fdd6f2ae30655fb0639e53619c5" title="Call this function to cleanup the Factories of any Products which were not managed by a ProductPtr or...">CleanupLostProducts()</a> was called (or since the program began, if <a class="el" href="namespacegz_1_1plugin.html#ae73c6fdd6f2ae30655fb0639e53619c5" title="Call this function to cleanup the Factories of any Products which were not managed by a ProductPtr or...">CleanupLostProducts()</a> has not been called yet).  <br /></td></tr>
<tr class="separator:af6af1661e7283de88c68ee4faf2fcc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3e73dcc1ed3030650a0bf9a45f2ff442" id="r_a3e73dcc1ed3030650a0bf9a45f2ff442"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">const</a> <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegz_1_1plugin.html#a3e73dcc1ed3030650a0bf9a45f2ff442">INFO_API_VERSION</a> = 1</td></tr>
<tr class="memdesc:a3e73dcc1ed3030650a0bf9a45f2ff442"><td class="mdescLeft">&#160;</td><td class="mdescRight">sentinel value to check if a plugin was built with the same version of the <a class="el" href="structgz_1_1plugin_1_1v1_1_1Info.html" title="Holds info required to construct a plugin.">Info</a> struct  <br /></td></tr>
<tr class="separator:a3e73dcc1ed3030650a0bf9a45f2ff442"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3882c12f75ef6a08376e49eb26677033" name="a3882c12f75ef6a08376e49eb26677033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3882c12f75ef6a08376e49eb26677033">&#9670;&#160;</a></span>ConstCompatible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">typename</a> <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">To</a> , <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">typename</a> <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">From</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a> <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">ConstCompatible</a> =  detail::ConstCompatible&lt;<a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">To</a>, <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">From</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contains a static constexpr field named <code>value</code> which will be true if the type <code>From</code> has a const-quality less than or equal to the type <code>To</code>. </p>
<p>The following expressions will return true:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033" title="Contains a static constexpr field named value which will be true if the type From has a const-quality...">ConstCompatible&lt;T, T&gt;::value</a></div>
<div class="line"><a class="code hl_typedef" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033" title="Contains a static constexpr field named value which will be true if the type From has a const-quality...">ConstCompatible&lt;const T, T&gt;::value</a></div>
</div><!-- fragment --><p>The following expression will return false:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033" title="Contains a static constexpr field named value which will be true if the type From has a const-quality...">ConstCompatible&lt;T, const T&gt;::value</a></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab31a3fb90680b0a2ff48363847f68ac0" name="ab31a3fb90680b0a2ff48363847f68ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31a3fb90680b0a2ff48363847f68ac0">&#9670;&#160;</a></span>ConstInfoPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a> <a class="el" href="namespacegz_1_1plugin.html#ab31a3fb90680b0a2ff48363847f68ac0">ConstInfoPtr</a> =  <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt;<a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">const</a> <a class="el" href="structgz_1_1plugin_1_1v1_1_1Info.html">Info</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c78259418ddd2272e02aeb49811b4d2" name="a5c78259418ddd2272e02aeb49811b4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c78259418ddd2272e02aeb49811b4d2">&#9670;&#160;</a></span>ConstPluginPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a> <a class="el" href="namespacegz_1_1plugin.html#a5c78259418ddd2272e02aeb49811b4d2">ConstPluginPtr</a> =  <a class="el" href="classgz_1_1plugin_1_1TemplatePluginPtr.html">TemplatePluginPtr</a>&lt;<a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">const</a> <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This produces a PluginPtr whose <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> wrapper only grants access to const-qualified interfaces of the plugin instance. </p>

</div>
</div>
<a id="ad99dd9977a712a35a1c3c1e569dacb2e" name="ad99dd9977a712a35a1c3c1e569dacb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99dd9977a712a35a1c3c1e569dacb2e">&#9670;&#160;</a></span>ConstSpecializedPluginPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... SpecInterfaces&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a> <a class="el" href="namespacegz_1_1plugin.html#ad99dd9977a712a35a1c3c1e569dacb2e">ConstSpecializedPluginPtr</a> =  <a class="el" href="classgz_1_1plugin_1_1TemplatePluginPtr.html">TemplatePluginPtr</a>&lt; <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">const</a> <a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin.html">SpecializedPlugin</a>&lt;SpecInterfaces...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This alias creates a specialized PluginPtr whose interfaces are all const-qualified. </p>

</div>
</div>
<a id="a694e3f7a5775c792604a66742903cc21" name="a694e3f7a5775c792604a66742903cc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694e3f7a5775c792604a66742903cc21">&#9670;&#160;</a></span>InfoMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a> <a class="el" href="namespacegz_1_1plugin.html#a694e3f7a5775c792604a66742903cc21">InfoMap</a> =  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="el" href="structgz_1_1plugin_1_1v1_1_1Info.html">Info</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This typedef is used simultaneously by detail/Register.hh and Loader.cc, so we store it in a location that is visible to both of them. </p>

</div>
</div>
<a id="a6bbdc54110be7821705e387b9312816c" name="a6bbdc54110be7821705e387b9312816c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbdc54110be7821705e387b9312816c">&#9670;&#160;</a></span>PluginPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a> <a class="el" href="namespacegz_1_1plugin.html#a6bbdc54110be7821705e387b9312816c">PluginPtr</a> =  <a class="el" href="classgz_1_1plugin_1_1TemplatePluginPtr.html">TemplatePluginPtr</a>&lt;<a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typical usage for <a class="el" href="classgz_1_1plugin_1_1TemplatePluginPtr.html" title="This class manages the lifecycle of a plugin instance. It can receive a plugin instance from the Load...">TemplatePluginPtr</a> is to just hold a generic <a class="el" href="classgz_1_1plugin_1_1Plugin.html">Plugin</a> type. </p>

</div>
</div>
<a id="af2953d9d9b79271662f93df151945f52" name="af2953d9d9b79271662f93df151945f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2953d9d9b79271662f93df151945f52">&#9670;&#160;</a></span>ProductPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">typename</a> <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">Interface</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a> <a class="el" href="namespacegz_1_1plugin.html#af2953d9d9b79271662f93df151945f52">ProductPtr</a> =  <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">Interface</a>, <a class="el" href="classgz_1_1plugin_1_1ProductDeleter.html">ProductDeleter</a>&lt;<a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">Interface</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ProductPtr is a derivative of <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a> that can safely manage the products that come out of a plugin factory. It is strongly recommended that factory products use a ProductPtr to manage the lifecycle of a factory product. </p>
<p>If you MUST release a factory product pointer, then it should at least be passed to a <a class="el" href="classgz_1_1plugin_1_1ProductDeleter.html" title="This class provides a unary operator for safely deleting pointers to plugin factory products with the...">ProductDeleter</a> to be deleted at the end of its lifecycle. If it is not possible to delete the product with a <a class="el" href="classgz_1_1plugin_1_1ProductDeleter.html" title="This class provides a unary operator for safely deleting pointers to plugin factory products with the...">ProductDeleter</a>, then you will need to periodically call <a class="el" href="namespacegz_1_1plugin.html#ae73c6fdd6f2ae30655fb0639e53619c5" title="Call this function to cleanup the Factories of any Products which were not managed by a ProductPtr or...">CleanupLostProducts()</a> or else you will experience memory leaks, and your factory plugin libraries will never get unloaded. </p>

</div>
</div>
<a id="a71ecee778dbdcaee4977cedd7341ef55" name="a71ecee778dbdcaee4977cedd7341ef55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ecee778dbdcaee4977cedd7341ef55">&#9670;&#160;</a></span>SpecializedPluginPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... SpecInterfaces&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">using</a> <a class="el" href="namespacegz_1_1plugin.html#a71ecee778dbdcaee4977cedd7341ef55">SpecializedPluginPtr</a> =  <a class="el" href="classgz_1_1plugin_1_1TemplatePluginPtr.html">TemplatePluginPtr</a>&lt; <a class="el" href="classgz_1_1plugin_1_1SpecializedPlugin.html">SpecializedPlugin</a>&lt;SpecInterfaces...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This alias allows PluginPtr instances to have high-speed access to interfaces that can be anticipated at compile time. The plugin does not have to actually offer the specialized interface in order to get this performance improvement. This template is variadic, so it can support arbitrarily many interfaces. </p>
<p>Usage example:</p>
<p>Suppose you want to instantiate a plugin that might (or might not) have some combination of four interfaces which are known at compile time: <code>MyInterface1</code>, <code>FooInterface</code>, <code>MyInterface2</code>, and <code>BarInterface</code>. You can use SpecializedPluginPtr as shown here:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033" title="Contains a static constexpr field named value which will be true if the type From has a const-quality...">MySpecialPluginPtr</a> = <a class="code hl_class" href="classgz_1_1plugin_1_1TemplatePluginPtr.html" title="This class manages the lifecycle of a plugin instance. It can receive a plugin instance from the Load...">SpecializedPluginPtr</a>&lt;</div>
<div class="line">    <a class="code hl_typedef" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033" title="Contains a static constexpr field named value which will be true if the type From has a const-quality...">MyInterface1</a>, <a class="code hl_typedef" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033" title="Contains a static constexpr field named value which will be true if the type From has a const-quality...">FooInterface</a>, <a class="code hl_typedef" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033" title="Contains a static constexpr field named value which will be true if the type From has a const-quality...">MyInterface2</a>, <a class="code hl_typedef" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033" title="Contains a static constexpr field named value which will be true if the type From has a const-quality...">BarInterface</a>&gt;;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033" title="Contains a static constexpr field named value which will be true if the type From has a const-quality...">MySpecialPluginPtr</a> plugin = <a class="code hl_typedef" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033" title="Contains a static constexpr field named value which will be true if the type From has a const-quality...">loader</a>-&gt;Instantiate(<a class="code hl_typedef" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033" title="Contains a static constexpr field named value which will be true if the type From has a const-quality...">pluginName</a>);</div>
</div><!-- fragment --><p>Then, calling the function</p>
<div class="fragment"><div class="line">plugin-&gt;QueryInterface&lt;<a class="code hl_typedef" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033" title="Contains a static constexpr field named value which will be true if the type From has a const-quality...">FooInterface</a>&gt;();</div>
</div><!-- fragment --><p>will have extremely high speed associated with it. It will provide direct access to the the <code>FooInterface*</code> of <code>plugin</code>. If <code>plugin</code> does not actually offer <code>FooInterface</code>, then it will return a nullptr, still at extremely high speed.</p>
<p>This same rule also applies to <code>MyInterface1</code>, <code>MyInterface2</code>, and <code>BarInterface</code>, because those interfaces were also provided to SpecializedPluginPtr&lt;...&gt; at compile time. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae73c6fdd6f2ae30655fb0639e53619c5" name="ae73c6fdd6f2ae30655fb0639e53619c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73c6fdd6f2ae30655fb0639e53619c5">&#9670;&#160;</a></span>CleanupLostProducts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">void</a> CleanupLostProducts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">const</a> <a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a> &amp;&#160;</td>
          <td class="paramname"><em>_safetyWait</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::nanoseconds</a>(5)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function to cleanup the Factories of any Products which were not managed by a ProductPtr or deleted by a <a class="el" href="classgz_1_1plugin_1_1ProductDeleter.html" title="This class provides a unary operator for safely deleting pointers to plugin factory products with the...">ProductDeleter</a> (in other words, the Product was released from its ProductPtr and then its lifecycle was managed by a framework that does not know it has special deletion requirements). </p>
<p>If you never call the .release() function on a ProductPtr, then you will never need to call this function.</p>
<dl class="section warning"><dt>Warning</dt><dd>Note that this function should be called ONLY while there are no Products that are actively destructing, or else there is a minuscule probability of causing a segmentation fault. This is never an issue in a single-threaded application.</dd>
<dd>
If you have a multi-threaded application where you have absolutely no control over the lifecycle of the products, and you cannot reliably predict a safe window in which you know that no products are being actively deleted, then you can specify a short safety wait to the cleanup call. If any products were being deleted while this function is called, this wait can give them time to fully exit their destructors before we unload their libraries.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For some applications, it might not be important if there are tiny memory leaks or if plugin libraries remain loaded until the application exits. For those applications, it is okay to not bother calling this function at all.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_safetyWait</td><td>For multi-threaded applications, this short waiting window gives time for products that are currently being deleted to exit their destructors before we unload their libraries. If you can reliably predict a window of time in which no products are actively being destructed (or if you have a single-threaded application), then it is okay to set this waiting time to 0. Note that any threads which are about to destruct a product will be blocked until this wait is over. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93914cbac6e60f1a30188b47e5a6c6d4" name="a93914cbac6e60f1a30188b47e5a6c6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93914cbac6e60f1a30188b47e5a6c6d4">&#9670;&#160;</a></span>DemangleSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> DemangleSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">const</a> <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Demangle the ABI typeinfo name of a symbol into a human-readable version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_symbol</td><td>Pass in the result of <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033" title="Contains a static constexpr field named value which will be true if the type From has a const-quality...">typeid(T)</a>.name() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The demangled (human-readable) version of the symbol name </dd></dl>

</div>
</div>
<a id="af6af1661e7283de88c68ee4faf2fcc83" name="af6af1661e7283de88c68ee4faf2fcc83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6af1661e7283de88c68ee4faf2fcc83">&#9670;&#160;</a></span>LostProductCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a> LostProductCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of lost products that have currently accumulated since the last time <a class="el" href="namespacegz_1_1plugin.html#ae73c6fdd6f2ae30655fb0639e53619c5" title="Call this function to cleanup the Factories of any Products which were not managed by a ProductPtr or...">CleanupLostProducts()</a> was called (or since the program began, if <a class="el" href="namespacegz_1_1plugin.html#ae73c6fdd6f2ae30655fb0639e53619c5" title="Call this function to cleanup the Factories of any Products which were not managed by a ProductPtr or...">CleanupLostProducts()</a> has not been called yet). </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3e73dcc1ed3030650a0bf9a45f2ff442" name="a3e73dcc1ed3030650a0bf9a45f2ff442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e73dcc1ed3030650a0bf9a45f2ff442">&#9670;&#160;</a></span>INFO_API_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">const</a> <a class="el" href="namespacegz_1_1plugin.html#a3882c12f75ef6a08376e49eb26677033">int</a> INFO_API_VERSION = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sentinel value to check if a plugin was built with the same version of the <a class="el" href="structgz_1_1plugin_1_1v1_1_1Info.html" title="Holds info required to construct a plugin.">Info</a> struct </p>
<p>This must be incremented when the <a class="el" href="structgz_1_1plugin_1_1v1_1_1Info.html" title="Holds info required to construct a plugin.">Info</a> struct changes </p>

</div>
</div>
</div><!-- contents -->
      </div>
    </main>
  </div>
</body>
